---
layout: post
title: "数据结构01"
description: "数据结构简介"
date: 2019-04-12
tags: [数据结构]
comments: true
share: true
---

[![996.icu](https://img.shields.io/badge/link-996.icu-red.svg)](https://996.icu) [![LICENSE](https://img.shields.io/badge/license-Anti%20996-blue.svg)](https://github.com/996icu/996.ICU/blob/master/LICENSE)


ADT: Abstract Data Type 抽象数据类型.            
Linear data structures: 在线性数据结构中, 数据按照线性或是序列方式存储.             
Nonlinear data structures: 在非线性数据结构中, 数据并不是按序排列.

## 比较常用的数据结构           

Struct          
Array            
Linked list            
Doubly linked list          
Stack 栈         
Queue          
Priority queue           
Set            
Map             
Tree               
Graph          
Heap 堆

### Struct 结构体


一个结构体是可以通过名称来访问的值的容器. 结构体在C语言中比较常见.


### Array 数组

注意: PHP中的数组事实上是一个ordered map.              
通常, 数组这个东西是一个固定容量的集合, 其中的元素可以通过按次序的数值下标来访问.

### Linked list 链表

链表是一个线性的数据结构, 它是一个数据元素(节点)的集合并且容量可变.            
在链表中, 一个表元素通过指针(pointer)和下一个表元素相连.         

### Doubly linked list 双向链表        

一个双向链表是一个特殊类型的链表, 在其中我们不止在节点结构内部储存哪一个是下一个节点, 还储存哪一个是前一个节点. 从而它可以在表中前后移动.          


### Stack 栈    


栈是一种满足LIFO(后进先出)原则的线性数据结构. 栈只有一端来添加新元素或移除已有元素. 我们总是使用单个点——栈顶(top)来向栈添加或从栈移除元素.               
术语压入(push)用来表示向栈顶添加元素, 术语弹出(pop)用来表示从栈顶移除元素.


### Queue 队列


队列是一种满足FIFO(先进先出)原则的线性数据结构. 一个队列允许两个基本操作: 入队(enqueue)允许我们向队尾添加一个元素; 出队(dequeue)允许我们从队首移除一个元素.



### Set 集合

集合(Set)是一种用来存放特定值的ADT. 集合内的这些值不依照特定顺序来存储, 但也不应在集合中有重复的值.              
集合并不是像我们可以从中提取特定值的数据集(collection)那么用, 一个集合是用于检查其中是否存在某个值.                      
有时, 一个集合数据结构可以被排序, 我们称其为有序集(ordered set).



### Map 映射


一个映射是键(key)值(value)对的合集(collection), 在其中所有的键都是唯一的.         
我们可以把一个映射看作是一个关联数组, 在其中所有键都是唯一的.        
我们可以使用键值对来添加和删除, 也可以使用键来修改(update)和查询. 事实上, PHP的数组即是有序映射(ordered map)的实现.



### Tree 树

在计算机领域中, 树是最常用的非线性数据结构. 树经常用于分层的(hierarchical)数据结构. 一棵树由节点组成, 且有一个特殊的节点, 即为树的根(root), 树的结构从根开始. 其它的节点从根节点下降. 树结构是递归的, 这意味着一棵树可以包含一堆子树.            
树的节点之间通过边缘(edge)连起来.

![树](https://upload.cc/i1/2019/04/14/Tcft51.jpg)


### Graph 图


一个图结构是一个特殊的非线性数据结构, 其包含了有限数量的顶点(vertex, pl:vertices)抑或节点(node), 还包含了边缘(edge)抑或边(arc).        
一个图可以既是有向的(directed)也可以是无向的(undirected). 一个有向图明确指出了边的方向; 而一个无向图只关心边, 方向爱咋咋地. 因此, 在一个无向图里, 某个边的两个方向可以看作是同一的单个边.              
换句话说, 我们可以认为一个图是一个集合对(V, E), 其中V是顶点做成的集合, 而E是边做成的集合.          
举例来说:

V = {“申帝”, “右妃”, “长皇后”, “赤国师”, “艹帅”, “㐅大将”, “串相”, “厶将军”, “糖先锋”, “木贵人”},          
E = {“申帝”-“右妃”, “申帝”-“长皇后”, “申帝”-“赤国师”, “申帝”-“艹帅”, “申帝”-“㐅大将”, “申帝”-“串相”, “申帝”-“厶将军”, “申帝”-“糖先锋”, “申帝”-“木贵人”, “右妃”-“木贵人”, “艹帅”-“㐅大将”, “串相”-“木贵人”}.           

在一个有向图里, 边“申帝”-“右妃”和边“右妃”-“申帝”是不同的; 而在无向图里, 边“申帝”-“右妃”和边“右妃”-“申帝”都是一样的.

![图(无向)](https://upload.cc/i1/2019/04/14/PkSN94.png)



### Heap 堆



一个堆是一种特殊的基于树的数据结构, 其满足堆的属性. 最大的键是根且较小的那些键是叶这种为最大堆(max heap). 又或者, 最小的键为根且更大的那些键为叶这种的叫最小堆(min heap).                      
虽说一个堆结构的根要么是树的最大键要么是最小键, 它却不一定是一个排序过的结构.        

![堆](https://upload.cc/i1/2019/04/14/gdxyIn.png)


## 算法分析


资源: 时间类、存储(也就是空间)类.


为了了解在输入数据量增加的时候, 我们的算法表现如何, 以及了解算法利用了多少资源, 我们通常通过将输入的长度和算法执行的步数(时间复杂度time complexity)或是存储空间(空间复杂度space complexity)关联起来用以衡量.

我们可以在两个不同阶段进行算法分析, 一个是在算法实现前, 另一个是在算法实现后. 在算法实现前做的分析叫做理论分析(theoretical analysis), 并且我们假定其它的因素比如处理能力还有空间啥的都是常量. 在算法实现后做的分析叫做经验分析(empirical analysis), 这个根据平台或语言的差异也会各有不同.




