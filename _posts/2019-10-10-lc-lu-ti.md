---
layout: post
title: "LC 撸题(212/1230)"
description: "为公司上市而撸题."
date: 2019-10-10
tags: [提高姿势水平]
comments: true
share: true
---

> 为公司上市而撸题.

[![996.icu](https://img.shields.io/badge/link-996.icu-red.svg)](https://996.icu) [![LICENSE](https://img.shields.io/badge/license-Anti%20996-blue.svg)](https://github.com/996icu/996.ICU/blob/master/LICENSE) ![fuck-Scdiler](https://img.shields.io/badge/fuck-Scdiler-FD9827) ![sponsors-FUCengers](https://img.shields.io/badge/sponsors-FUCengers-brightgreen.svg) [![CS-PSR-1](https://img.shields.io/badge/code%20style-PSR--1-green.svg)](https://www.php-fig.org/psr/psr-1/) [![CS-PSR-12](https://img.shields.io/badge/code%20style-PSR--12-green.svg)](https://www.php-fig.org/psr/psr-12/)


* TOC
{:toc}


## 前言


长期更新, 通过撸题的方式写东西, 万一将来面点儿啥地方正好为自己增加 ZZ 资本, 顺便也拿这个练下 HTML, 至少我通过这个文档把 `<pre>`、`<strong>`、`<em>`、`<sup>`、`<sub>` 啥的都练会了...

除了在里面粘代码以外, 有时候兴许碰到合适的题目也会在代码后面讲一点用到的函数或是手法、谈一些自己对语言/算法的粗浅认识、或是回忆一下过去什么的.


撸题原则:


* 只做能用 PHP 提交到 OJ 的. 像需要氪会员才能解锁的上锁题目和使用语言选项里本来就没有 PHP 的 OJ 的题目就不做了...当然调几个 API 就能出结果的除外, 比如 190、191 这种的.
* 一切以能实现需求为先, 无条件接受调 API 开挂、用各类数学姿势/数学资源开挂等一切能解决问题的行为. 毕竟这也是能力的一部分.
* 如果不是特别开挂的题目, 一定要有较好的可读性. 不过就算开挂了, 你变量名什么的起码也可以起得差不多吧.
* 原题目有的参数名太矬了, 可能会有修改.




## 关于目录和格式


题目是按照题号递增的顺序排列的, 之前只能手翻, 没找到的就是因为各种原因没做或是没看而导致的没有.


现实和我设想的还不太一样, 等我研究研究怎么加目录. GitHub 用的 Markdown 是 Github Flavored Markdown, 简称 GFM, 参考[https://github.github.com/gfm/](https://github.github.com/gfm/). 总之没法直接 `[TOC]` 生成目录... 目前我个人比较看好[这个github-markdown-toc](https://github.com/ekalinin/github-markdown-toc).

重在撸题刷 KPI, 做目录什么的都是次要的. 要分清主要矛盾和次要矛盾.

当然了, 现在我知道目录可以用

```markdown
* TOC
{:toc}
```

生成(2019-07-14).

格式的话, 有时候会出现没有渲染 md 文本的情况, 这时候我的处理办法在出现问题的位置把空格删一删, 重新再打空格, 在编辑器里看一般都能好.


## 1. Two Sum

题目描述:

Given an array of integers, return **indices** of the two numbers such that they add up to a specific target.

You may assume that each input would have ***exactly*** one solution, and you may not use the *same* element twice.

**Example:**

<pre>
Given nums = [2, 7, 11, 15], target = 9,

Because nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9,
return [<strong>0</strong>, <strong>1</strong>].
</pre>

解答 1:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Integer[]
     */
    function twoSum($nums, $target) 
    {
        $count = count($nums);
        for ($i = 0; $i < $count; $i++) {
            $complement = $target - $nums[$i];
            if (in_array($complement, $nums)) {
                $last_occurrence = end(array_keys($nums, $complement));
                if ($i != $last_occurrence) {
                    return [$i, $last_occurrence];
                }
            }
        }
    }
}
```

效果 1:

> 执行用时: 140 ms, 在所有 PHP 提交中击败了 64.33% 的用户
> 
> 内存消耗: 15.7 MB, 在所有 PHP 提交中击败了 66.78% 的用户

解答 2:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Integer[]
     */
    function twoSum($nums, $target) 
    {
        $map = [];
        $count = count($nums);
        for ($i = 0; $i < $count; $i++) {
            $map[$nums[$i]] = $i;
        }
        for ($i = 0; $i < $count; $i++) {
            $complement = $target - $nums[$i];
            if (array_key_exists($complement, $map) && $map[$complement] != $i) {
                return [$i, $map[$complement]];
            }
        }
    }
}
```

效果 2:

> 执行用时: 12 ms, 在所有 PHP 提交中击败了 98.43% 的用户
> 
> 内存消耗: 16.1 MB, 在所有 PHP 提交中击败了 10.17% 的用户


## 4. Median of Two Sorted Arrays

题目描述:

There are two sorted arrays **nums1** and **nums2** of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

You may assume **nums1** and **nums2** cannot be both empty.

**Example 1**:

<pre>
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
</pre>

**Example 2:**

<pre>
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Float
     */
    function findMedianSortedArrays($nums1, $nums2) 
    {
        //PHP是世界上最好的语言.
        $mergedNums = array_merge($nums1, $nums2);
        //PHP是世界上最好的语言!!!
        sort($mergedNums, SORT_NUMERIC);
        $totalCount = count($mergedNums);
        $remainder = $totalCount % 2;
        $mid = $totalCount / 2;
        if ($remainder == 0) {
            return ($mergedNums[$mid - 1] + $mergedNums[$mid]) / 2;
        } else {
            $mid = floor($mid);
            return $mergedNums[$mid];
        }
    }
}
```

效果:
> 执行用时 : 44 ms, 在 Median of Two Sorted Arrays 的 PHP 提交中击败了 99.04% 的用户
> 
> 内存消耗 : 15 MB, 在 Median of Two Sorted Arrays 的 PHP 提交中击败了 24.65% 的用户

## 7. Reverse Integer

题目描述:

Given a 32-bit signed integer, reverse digits of an integer.

**Example 1:**

<pre>
<strong>Input:</strong> 123
<strong>Output:</strong> 321
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> -123
<strong>Output:</strong> -321
</pre>

**Example 3:**

<pre>
<strong>Input:</strong> 120
<strong>Output:</strong> 21
</pre>

**Note:**


Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2<sup>31</sup>,  2<sup>31</sup> − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.

解答:

```php
class Solution 
{

    /**
     * @param Integer $x
     * @return Integer
     */
    function reverse($x) 
    {
        $reverse = 0; 
        while ($x != 0) {
            $reverse = ($reverse * 10) + ($x % 10);
            $x = intval($x / 10);
        }
        // PHP_INT_MAX (integer):
        // The largest integer supported in this build of PHP. Usually int(2147483647) in 32 bit systems and int(9223372036854775807) in 64 bit systems. Available since PHP 5.0.5
        // PHP_INT_MIN (integer):
        // The smallest integer supported in this build of PHP. Usually int(-2147483648) in 32 bit systems and int(-9223372036854775808) in 64 bit systems. Available since PHP 7.0.0. Usually, PHP_INT_MIN === ~PHP_INT_MAX.
        if (intval($reverse) > 2 ** 31 - 1 || intval($reverse) < (- 2 ** 31)) {
            return 0;
        }
        return intval($reverse);
    }
}
```

效果:

> 执行用时 : 8 ms, 在 Reverse Integer 的 PHP 提交中击败了 99.63% 的用户
> 
> 内存消耗 : 14.6 MB, 在 Reverse Integer 的 PHP 提交中击败了 73.23% 的用户



## 8. String to Integer (atoi)


题目描述:

Implement `atoi` which converts a string to an integer.

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned.

**Note:**

* Only the space character `' '` is considered as whitespace character.
* Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2<sup>31</sup>,  2<sup>31</sup> − 1]. If the numerical value is out of the range of representable values, INT_MAX (2<sup>31</sup> − 1) or INT_MIN (−2<sup>31</sup>) is returned.


**Example 1:**


<pre>
Input: "42"
Output: 42
</pre>



**Example 2:**


<pre>
<strong>Input:</strong> "   -42"
<strong>Output:</strong> -42
<strong>Explanation:</strong> The first non-whitespace character is '-', which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.
</pre>


             
**Example 3:**


<pre>
<strong>Input:</strong> "4193 with words"
<strong>Output:</strong> 4193
<strong>Explanation:</strong> Conversion stops at digit '3' as the next character is not a numerical digit.
</pre>



**Example 4:**

<pre>
<strong>Input:</strong> "words and 987"
<strong>Output:</strong> 0
<strong>Explanation:</strong> The first non-whitespace character is 'w', which is not a numerical 
             digit or a +/- sign. Therefore no valid conversion could be performed.
</pre>


**Example 5:**

<pre>
<strong>Input:</strong> "-91283472332"
<strong>Output:</strong> -2147483648
<strong>Explanation:</strong> The number "-91283472332" is out of the range of a 32-bit signed integer.
             Thefore INT_MIN (−2<sup>31</sup>) is returned.
</pre>


解答:

```php
class Solution 
{

    /**
     * @param String $str
     * @return Integer
     */
    function myAtoi($str) 
    {
        if ($str[0] == 'e') {
            return 0;
        }
        $digit_parts = explode('e', trim($str));
        $str = $digit_parts[0];
        if ($str[0] == '-') {
            $str = substr($str, 1);
            if (preg_match("/[^0-9]/", $str[0]) > 0) {
                return 0;
            }
            $int_value = intval($str);
            if ($int_value >= 0 && $int_value <= 2 ** 31 - 1) {
                return -$int_value;
            }
            if ($int_value > (2 ** 31 - 1)) {
                return -2 ** 31;
            }
            return 0;
        } elseif ($str[0] == '+') {
            $str = substr($str, 1);
            if (preg_match("/[^0-9]/", $str[0]) > 0) {
                return 0;
            }
            $int_value = intval($str);
            if ($int_value >= 0 && $int_value <= 2 ** 31 - 1) {
                return $int_value;
            }
            if ($int_value > (2 ** 31 - 1)) {
                return (2 ** 31 - 1);
            }
            return 0;
        } elseif (preg_match("/[^0-9]/", $str[0]) > 0) {
            return 0;
        } else {
            $int_value = intval($str);
            if ($int_value >= -2 ** 31 && $int_value <= 2 ** 31 - 1) {
                return $int_value;
            }
            if ($int_value > (2 ** 31 - 1)) {
                return (2 ** 31 - 1);
            }
            if ($int_value < -2 ** 31) {
                return -2 ** 31;
            }
        }
        
    }
}
```

效果:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 95.24% 的用户
> 
> 内存消耗 : 15 MB, 在所有 PHP 提交中击败了 10.17% 的用户


倒不难, 但是比较费事儿...“年轻人多坚持坚持.”
文档看得比较多的话就会知道: `intval()` 这个函数是会对字符 `e` 进行转义的. 所以如果想保证实现需求不出岔子的话我个人建议是上来就砍掉, 以免出事儿.

## 9. Palindrome Number

题目描述:


Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

**Example 1:**

<pre>
<strong>Input:</strong> 121
<strong>Output:</strong> true
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> -121
<strong>Output:</strong> false
<strong>Explanation:</strong> From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
</pre>

**Example 3:**


<pre>
<strong>Input:</strong> 10
<strong>Output:</strong> false
<strong>Explanation:</strong> Reads 01 from right to left. Therefore it is not a palindrome.
</pre>

**Follow up:**

Could you solve it without converting the integer to a string?

解答1:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Boolean
     */
    function isPalindrome($num) 
    {
        if ($num < 0) {
            return false;
        }
        $orginal = $num;
        $reverse = 0;
        while ($num != 0) {
            $reverse = $reverse * 10 + $num % 10;
            $num = floor($num / 10);
        }
        return $reverse == $orginal;
    }
}
```


效果1:

> 执行用时 :  32 ms, 在 Palindrome Number 的 PHP 提交中击败了 97.50% 的用户
> 
> 内存消耗 : 14.8 MB, 在 Palindrome Number 的 PHP 提交中击败了 11.37% 的用户


在别的语言中, 解答1中的逆序数可能会粗现溢出的情况. 所以PHP是最好的语言!!!


解答2:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Boolean
     */
    function isPalindrome($num) 
    {
        if ($num < 0) {
            return false;
        }
        $org_str = strval($num);
        $rev_str = strrev($org_str);
        return $rev_str == $org_str;
    }
}
```

效果2:

> 执行用时 : 28 ms, 在 Palindrome Number 的 PHP 提交中击败了 98.47% 的用户
> 
> 内存消耗 : 14.6 MB, 在 Palindrome Number 的 PHP 提交中击败了 75.29% 的用户



解答3:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Boolean
     */
    function isPalindrome($num) 
    {
        if ($num < 0) {
            return false;
        }
        $div = 1;
        while ($num / $div >= 10) {
            $div *= 10; 
        }
        while ($num != 0) {
            $left = floor($num / $div);
            $right = $num % 10;
            if ($left != $right) {
                return false;
            }
            $num = floor($num % $div / 10);
            $div = floor($div / 100); 
        }
        return true;
    }
}
```


效果3:

> 执行用时 : 44 ms, 在 Palindrome Number 的 PHP 提交中击败了 93.46% 的用户
> 
> 内存消耗 : 14.6 MB, 在 Palindrome Number 的 PHP 提交中击败了 76.86% 的用户


## 11. Container With Most Water

题目描述:

Given *n* non-negative integers <em>a<sub>1</sub></em>, <em>a<sub>2</sub></em>, ..., <em>a<sub>n</sub></em>, where each represents a point at coordinate (i, <em>a<sub>i</sub></em>). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, <em>a<sub>i</sub></em>) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

**Note:** You may not slant the container and *n* is at least 2.


![11题配图.jpg](https://i.loli.net/2019/06/25/5d1179b1c6b3a52843.jpg)

The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.

 

**Example:**

<pre>
<strong>Input:</strong> [1,8,6,2,5,4,8,3,7]
<strong>Output:</strong> 49
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $height
     * @return Integer
     */
    function maxArea($height) 
    {
        $max_area = 0; 
        $left = 0; 
        $right = count($height) - 1;
        while ($left < $right) {
            $max_area = max($max_area, min($height[$left], $height[$right]) * ($right - $left));
            if ($height[$left] < $height[$right]) {
                $left++;
            } else {
                $right--;
            }
                
        }
        return $max_area;
    }
}
```

效果:

> 执行用时 : 44 ms, 在所有 PHP 提交中击败了 97.83% 的用户
> 
> 内存消耗 : 16.2 MB, 在所有 PHP 提交中击败了 70.59% 的用户


很明显是动态规划的题目. 就算没吃过猪肉, 现在也见过很多次猪跑了.



## 12. Integer to Roman

题目描述:

Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

<pre>
<strong>Symbol</strong>       <strong>Value</strong>
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
</pre>

For example, two is written as `II` in Roman numeral, just two one's added together. Twelve is written as, `XII`, which is simply `X` + `II`. The number twenty seven is written as `XXVII`, which is `XX` + `V` + `II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:

* `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. 
* `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. 
* `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.


Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

**Example 1:**

<pre>
<strong>Input:</strong> 3
<strong>Output:</strong> "III"
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> 4
<strong>Output:</strong> "IV"
</pre>

**Example 3:**

<pre>
<strong>Input:</strong> 9
<strong>Output:</strong> "IX"
</pre>

**Example 4:**

<pre>
<strong>Input:</strong> 58
<strong>Output:</strong> "LVIII"
<strong>Explanation:</strong> L = 50, V = 5, III = 3.
</pre>

**Example 5:**

<pre>
<strong>Input:</strong> 1994
<strong>Output:</strong> "MCMXCIV"
<strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.
</pre>

解答:

```php 
class Solution 
{

    /**
     * @param Integer $num
     * @return String
     */
    function intToRoman($num) 
    {
        $int2roman_map = array(
            'M' => 1000, 
            'CM' => 900, 
            'D' => 500, 
            'CD' => 400, 
            'C' => 100, 
            'XC' => 90, 
            'L' => 50, 
            'XL' => 40, 
            'X' => 10, 
            'IX' => 9, 
            'V' => 5, 
            'IV' => 4, 
            'I' => 1
        );
        $result = '';
        while ($num > 0) {
            foreach ($int2roman_map as $roman => $int) {
                if ($num >= $int) {
                    $num -= $int;
                    $result .= $roman;
                    break;
                }
            }
        }
        return $result;
    }
}
```

效果:

> 执行用时 : 12 ms, 在 Integer to Roman 的 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.7 MB, 在 Integer to Roman 的 PHP 提交中击败了 58.49% 的用户

## 13. Roman to Integer

题目描述:

Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

<pre>
<strong>Symbol</strong>       <strong>Value</strong>
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
</pre>

For example, two is written as `II` in Roman numeral, just two one's added together. Twelve is written as, `XII`, which is simply `X` + `II`. The number twenty seven is written as `XXVII`, which is `XX` + `V` + `II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:

* `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. 
* `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. 
* `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.


Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

**Example 1:**

<pre>
<strong>Input:</strong> "III"
<strong>Output:</strong> 3
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> "IV"
<strong>Output:</strong> 4
</pre>

**Example 3:**

<pre>
<strong>Input:</strong> "IX"
<strong>Output:</strong> 9
</pre>

**Example 4:**

<pre>
<strong>Input:</strong> "LVIII"
<strong>Output:</strong> 58
<strong>Explanation:</strong> L = 50, V= 5, III = 3.
</pre>


**Example 5:**

<pre>
<strong>Input:</strong> "MCMXCIV"
<strong>Output:</strong> 1994
<strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.
</pre>

解答:

```php
class Solution 
{

    /**
     * @param String $s
     * @return Integer
     */
    function romanToInt($s) 
    {
        $roman2int_map = array(
            'M' => 1000,
            'CM' => 900,
            'D' => 500,
            'CD' => 400,
            'C' => 100,
            'XC' => 90,
            'L' => 50,
            'XL' => 40,
            'X' => 10,
            'IX' => 9,
            'V' => 5,
            'IV' => 4,
            'I' => 1,
        );
        $result = 0;
        foreach ($roman2int_map as $roman => $int) {
            while (strpos($s, $roman) === 0) {
                $result += $int;
                $s = substr($s, strlen($roman));
            }
        }
        return $result;
    }
}
```

效果:

> 执行用时 : 20 ms, 在 Roman to Integer 的 PHP 提交中击败了 99.51% 的用户
> 
> 内存消耗 : 14.8 MB, 在 Roman to Integer的 PHP 提交中击败了 23.97% 的用户

罗马数字介绍: [Roman numerals](https://en.wikipedia.org/wiki/Roman_numerals)


## 14. Longest Common Prefix

题目描述:


Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string `""`.

**Example 1:**


<pre>
Input: ["flower","flow","flight"]
Output: "fl"
</pre>


**Example 2:**


<pre>
Input: ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
</pre>


**Note:**

All given inputs are in lowercase letters `a-z`.


解答:

```php
class Solution 
{

    /**
     * @param String[] $strs
     * @return String
     */
    function longestCommonPrefix($strs) 
    {
        sort($strs); // 先排个序, 以便少操儿心.
        $str1 = $strs[0]; // 排序后的字符串数组的第一项
        $str2 = $strs[count($strs) - 1]; // 排序后的字符串数组的最后一项
        $common_len = min(strlen($str1), strlen($str2));

        // 当还有字符串需要比较的时候, 只要两个字符串的同一下标对应字符相同, 就自增下标.
        // 由于我们只需要用这个下标, 所以就不用弄方法体了... 
        for ($i = 0; $i < $common_len && $str1[$i] == $str2[$i]; $i++);
        $common_prefix = substr($str1, 0, $i);
        return $common_prefix;
    }
}
```

效果:

> 执行用时 : 8 ms, 在 Longest Common Prefix 的 PHP 提交中击败了 98.98% 的用户
> 
> 内存消耗 : 14.7 MB, 在 Longest Common Prefix 的 PHP 提交中击败了 80.71% 的用户

## 15. 3Sum

题目描述:

Given an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.

**Note:**

The solution set must not contain duplicate triplets.

**Example:**

<pre>
Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer[][]
     */
    function threeSum($nums) 
    {
        $result = [];
        sort($nums, SORT_NUMERIC);
        $i = 0;
        $j = 0; 
        $count = count($nums); 
        $k = $count - 1;
        if ($k < 2 || $nums[$k] < 0) {
            return $result;
        }
        while ($i < $count - 2) {
            if ($nums[$i] > 0) {
                break;
            }
            $target = -$nums[$i];
            $j = $i + 1;
            $k = $count - 1;
            while ($j < $k) {
                if ($nums[$k] < 0) {
                    break;
                }
                if ($nums[$j] + $nums[$k] == $target) {
                    $result[] = [$nums[$i], $nums[$j], $nums[$k]];
                    while($j < $k && $nums[$j] == $nums[++$j]);
                    while($j < $k && $nums[$k] == $nums[--$k]);
                } elseif ($nums[$j] + $nums[$k] > $target) {
                    $k--;
                } else {
                    $j++;
                }
            }
            while ($i < $count - 2 && $nums[$i] == $nums[++$i]) {
                
            }
        }
        return $result;
    }
}
```

效果:

> 执行用时 : 300 ms, 在3Sum的PHP提交中击败了 88.83% 的用户
> 
> 内存消耗 : 24.1 MB, 在3Sum的PHP提交中击败了 54.84% 的用户

## 16. 3Sum Closest

Given an array `nums` of *n* integers and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.

**Example:**

<pre>
Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Integer
     */
    function threeSumClosest($nums, $target) 
    {
        sort($nums, SORT_NUMERIC);
        $min = PHP_INT_MAX;
        $result = 0;
        $count = count($nums);
        for ($i = 2; $i < $count; $i++) {
            $left = 0;
            $right = $i - 1;
            while ($left < $right) {
                $sum = $nums[$left] + $nums[$right] + $nums[$i];
                if ($sum == $target) {
                    return $target;
                }
                $difference = abs($target - $sum);
                if ($difference < $min) {
                    $min = $difference;
                    $result = $sum;
                }
                if ($sum < $target) {
                    $left++;
                } else {
                    $right--;
                }
            }
        }
        return $result;
    }
}
```

效果:

> 执行用时 : 48 ms, 在3Sum Closest的PHP提交中击败了 89.86% 的用户
> 
> 内存消耗 : 14.7 MB, 在3Sum Closest的PHP提交中击败了 74.07% 的用户



## 17. Letter Combinations of a Phone Number


题目描述:

Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.


![200px-Telephone-keypad2.svg.png](https://i.loli.net/2019/05/31/5cf09092d6aaf90977.png)


**Example:**


<pre>
Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
</pre>


**Note:**

Although the above answer is in lexicographical order, your answer could be in any order you want.


解答:


```php
class Solution 
{
    /**
     * @param Array[] $arrays 需要计算笛卡尔积的多个数组.
     * @return Array[] 返回笛卡尔积.
     */
    static function cartesianProduct($arrays) 
    {
        $results = [];
        $arrays = array_values($arrays);
        // 传进去的大数组中里面的数组的个数.
        $count = count($arrays);
        $array_size = $count > 0 ? 1 : 0;
        foreach ($arrays as $array) {
            $array_size = $array_size * count($array);
        }
        for ($i = 0; $i < $array_size; $i++) {
            $results[$i] = "";
            for ($j = 0; $j < $count; $j++) {
                $results[$i] .= current($arrays[$j]);
            }
            for ($j = $count - 1; $j >= 0; $j --) {
                if (next($arrays[$j])) {
                    break;
                } elseif (isset($arrays[$j])) {
                    reset($arrays[$j]);
                }
            }
        }
        return $results;
    }

    /**
     * @param String $digits
     * @return String[]
     */
    function letterCombinations($digits) 
    {
        $digit2letter = [
            "2" => ["a", "b", "c"],
            "3" => ["d", "e", "f"],
            "4" => ["g", "h", "i"],
            "5" => ["j", "k", "l"],
            "6" => ["m", "n", "o"],
            "7" => ["p", "q", "r", "s"],
            "8" => ["t", "u", "v"],
            "9" => ["w", "x", "y", "z"]
        ];
        $results = [];
        $str_len = strlen($digits);
        $arrays = [];
        for ($i = 0; $i < $str_len; $i++) {
            $arrays[] = $digit2letter[$digits[$i]];
        }
        return self::cartesianProduct($arrays);       
    }
}
```


效果:

> 执行用时 : 8 ms, 在 Letter Combinations of a Phone Number 的 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在 Letter Combinations of a Phone Number 的 PHP 提交中击败了 20.69% 的用户


直觉是用笛卡尔积做就可以了. 当然了, 我们当地有的大中型软件公司的废物虽然没听过笛卡尔积, 但并也不影响在行业中坚持到现在, 写个select标签都能达到虽然没有和后台交互但是他妈只有一个option的境界; 有的公司最高领导人成天在朋友圈发上课xx天有事儿微信, 自己却不管是企业管理还是项目管理都他妈一塌糊涂. 总之它们这水平我觉着是挺牛叉. 我想它们一定吃了很多苦吧. 


## 18. 4Sum

Given an array `nums` of *n* integers and an integer `target`, are there elements *a*, *b*, *c*, and *d* in `nums` such that *a* + *b* + *c* + *d* = `target`? Find all unique quadruplets in the array which gives the sum of `target`.

**Note:**

The solution set must not contain duplicate quadruplets.

**Example:**

<pre>
Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</pre>

解答:

```php
class Solution
{

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Integer[][]
     */
    function fourSum($nums, $target)
    {
        $result = [];
        sort($nums, SORT_NUMERIC);
        $sum = 0;
        $count = count($nums);
        for ($i = 0; $i < $count; $i++) {
            if ($i != 0 && $nums[$i - 1] == $nums[$i]) {
                continue;
            }
            for ($j = $i + 1; $j < $count; $j++) {
                if ($nums[$j - 1] == $nums[$j] && $i != $j - 1) {
                    continue;
                }
                $k = $j + 1;
                $l = $count - 1;
                while ($k < $l) {
                    $output = [];
                    if ($nums[$i] + $nums[$j] + $nums[$k] + $nums[$l] == $target) {
                        $output[] = $nums[$i];
                        $output[] = $nums[$j];
                        $output[] = $nums[$k];
                        $output[] = $nums[$l];
                        $result[] = $output;
                        $k++;
                        while($k < $l && $nums[$k - 1] == $nums[$k]) {
                            $k++;
                        }
                        $l--;
                        while ($k < $l && $nums[$l + 1] == $nums[$l]) {
                            $l--;
                        }
                    } elseif ($nums[$i] + $nums[$j] + $nums[$k] + $nums[$l] > $target) {
                        $l--;
                    } else {
                        $k++;
                    }
                }
            }
        }
        return $result;
    }
}
```

效果: 

> 执行用时 : 592 ms, 在 4Sum 的 PHP 提交中击败了 41.67% 的用户
> 
> 内存消耗 : 14.8 MB, 在 4Sum 的 PHP 提交中击败了 36.36% 的用户


## 20. Valid Parentheses


题目描述:



Given a string containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.


Note that an empty string is also considered valid.

**Example 1:**



<pre>
<strong>Input:</strong> "()"
<strong>Output:</strong> true
</pre>



**Example 2:**


<pre>
<strong>Input:</strong> "()[]{}"
<strong>Output:</strong> true
</pre>



**Example 3:**


<pre>
<strong>Input:</strong> "(]"
<strong>Output:</strong> false
</pre>



**Example 4:**


<pre>
<strong>Input:</strong> "([)]"
<strong>Output:</strong> false
</pre>



**Example 5:**


<pre>
<strong>Input:</strong> "{[]}"
<strong>Output:</strong> true
</pre>


解答:


```php
class Solution 
{

    /**
     * @param String $str
     * @return Boolean
     */
    function isValid($str) 
    {
        do {
            // PHP是最好的语言!
            $str = str_replace(['()', '[]', '{}'], '', $str, $count);
        } while ($count > 0);
        return empty($str);
    }
}
```

效果:

> 执行用时 : 52 ms, 在所有 PHP 提交中击败了 30.58% 的用户
> 
> 内存消耗 : 14.4 MB, 在所有 PHP 提交中击败了 98.78% 的用户


`str_replace ( mixed $search , mixed $replace , mixed $subject [, int &$count ] )` : `mixed`

参数:

如果 `search` 和 `replace` 为数组，那么 `str_replace()` 将对 `subject` 做二者的映射替换。如果 `replace` 的值的个数少于 `search` 的个数，多余的替换将使用空字符串来进行。如果 `search` 是一个数组而 `replace` 是一个字符串，那么 `search` 中每个元素的替换将始终使用这个字符串。该转换不会改变大小写。

如果 `search` 和 `replace` 都是数组，它们的值将会被依次处理。

`search` - 查找的目标值，也就是 *needle*。一个数组可以指定多个目标。

`replace` - `search` 的替换值。一个数组可以被用来指定多重替换。

`subject` - 执行替换的数组或者字符串。也就是 *haystack*。如果 `subject` 是一个数组，替换操作将遍历整个 `subject`，返回值也将是一个数组。

`count` - 如果被指定，它的值将被设置为替换发生的次数。


## 26. Remove Duplicates from Sorted Array

题目描述:

Given a sorted array nums, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by **modifying the input array** <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> with O(1) extra memory.

Example 1:

<pre>
Given <em>nums</em> = [<strong>1</strong>,<strong>1</strong>,<strong>2</strong>],

Your function should return length = <strong>2</strong>, with the first two elements of <em>nums</em> being <strong>1</strong> and <strong>2</strong> respectively.

It doesn't matter what you leave beyond the returned length. 
</pre>

Example 2:

<pre>
Given <em>nums</em> = [<strong>0</strong>,<strong>0</strong>,<strong>1</strong>,<strong>1</strong>,<strong>1</strong>,<strong>2</strong>,<strong>2</strong>,<strong>3</strong>,<strong>3</strong>,<strong>4</strong>],

Your function should return length = <strong>5</strong>, with the first five elements of <em>nums</em> being modified to <strong>0</strong>, <strong>1</strong>, <strong>2</strong>, <strong>3</strong>, and <strong>4</strong> respectively.

It doesn't matter what values are set beyond the returned length.
</pre>
 
**Clarification:**

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by <strong>reference</strong>, which means modification to the input array will be known to the caller as well.

Internally you can think of this:
 
<pre>
// <strong>nums</strong> is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums);

// any modification to <strong>nums</strong> in your function would be known by the caller.
// using the length returned by your function, it prints the first <strong>len</strong> elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function removeDuplicates(&$nums) 
    {
        $count = count($nums);
        if ($count == 0) {
            return 0;
        }
        $index = 0;
        for ($i = 0; $i < $count; $i++) {
            if ($nums[$index] != $nums[$i]) {
                $nums[++$index] = $nums[$i];
            }
        }
        return $index + 1;
    }
}
```

效果:

> 执行用时: 28 ms, 在 Remove Duplicates from Sorted Array 的 PHP 提交中击败了 99.70% 的用户
> 
> 内存消耗: 16.6 MB, 在 Remove Duplicates from Sorted Array 的 PHP 提交中击败了 72.66% 的用户

## 27. Remove Element

题目描述: 

Given an array *nums* and a value *val*, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> and return the new length.

Do not allocate extra space for another array, you must do this by **modifying the input array** <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

**Example 1:**

<pre>
Given <em>nums</em> = [<strong>3</strong>,<strong>2</strong>,<strong>2</strong>,<strong>3</strong>], <em>val</em> = <strong>3</strong>,

Your function should return length = <strong>2</strong>, with the first two elements of <em>nums</em> being <strong>2</strong>.

It doesn't matter what you leave beyond the returned length.
</pre>


**Example 2:**

<pre>
Given <em>nums</em> = [<strong>0</strong>,<strong>1</strong>,<strong>2</strong>,<strong>2</strong>,<strong>3</strong>,<strong>0</strong>,<strong>4</strong>,<strong>2</strong>], <em>val</em> = <strong>2</strong>,

Your function should return length = <strong>5</strong>, with the first five elements of nums containing <strong>0</strong>, <strong>1</strong>, <strong>3</strong>, <strong>0</strong>, and <strong>4</strong>.

Note that the order of those five elements can be arbitrary.

It doesn't matter what values are set beyond the returned length.
</pre>

**Clarification:**

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by **reference**, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

<pre>
// <strong>nums</strong> is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);

// any modification to <strong>nums</strong> in your function would be known by the caller.
// using the length returned by your function, it prints the first <strong>len</strong> elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $val
     * @return Integer
     */
    function removeElement(&$nums, $val) 
    {
        $result = 0;
        foreach ($nums as $key => $value) {
            if ($value == $val) {
                unset($nums[$key]);
                continue;
            }
            $result++;
        }
        return $result;
    }
}
```

效果:

> 执行用时 : 8 ms, 在Remove Element的PHP提交中击败了 99.34% 的用户
> 
> 内存消耗 : 15 MB, 在Remove Element的PHP提交中击败了 5.60% 的用户

## 28. Implement strStr()

题目描述:

Implement [strStr()](http://www.cplusplus.com/reference/cstring/strstr/).

Return the index of the first occurrence of needle in haystack, or **-1** if needle is not part of haystack.

**Example 1:**

<pre>
<strong>Input:</strong> haystack = "hello", needle = "ll"
<strong>Output:</strong> 2
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> haystack = "aaaaa", needle = "bba"
<strong>Output:</strong> -1
</pre>


**Clarification:**

What should we return when `needle` is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when `needle` is an empty string. This is consistent to C's [strstr()](http://www.cplusplus.com/reference/cstring/strstr/) and Java's [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)).

解答:

```php
class Solution 
{

    /**
     * @param String $haystack
     * @param String $needle
     * @return Integer
     */
    function strStr($haystack, $needle) 
    {
        if ($needle === "") {
            return 0;
        }
        if (($pos = strpos($haystack, $needle)) !== false) {
            return $pos;
        }
        return -1;
    }
}
```

效果:

> 执行用时 : 8 ms, 在Implement strStr()的PHP提交中击败了100.00% 的用户
> 
> 内存消耗 : 14.8 MB, 在Implement strStr()的PHP提交中击败了69.56% 的用户

注意对API的理解, 多看手册. 题目中的`strstr()`对应的是PHP中的`strpos()`而非PHP中的`strstr()`.

只要能把需求还算有效率的实现就是好做法. 实在不行就升级硬件. 咱是来干出产值, 而不是来表演杂技.


## 33. Search in Rotated Sorted Array

题目描述:

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`).

You are given a target value to search. If found in the array return its index, otherwise return `-1`.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log *n*).

**Example 1:**

<pre>
<strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0
<strong>Output:</strong> 4
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3
<strong>Output:</strong> -1
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Integer
     */
    function search($nums, $target) 
    {
        $count = count($nums);
        if ($count == 1 && $nums[0] == $target) {
            return 0;
        }
        $left = 0;
        $right = $count - 1;
        $mid = 0;
        while ($left < $right) {
            $mid = floor(($left + $right) / 2);
            if ($nums[$left] == $target) {
                return $left;
            }
            if ($nums[$right] == $target) {
                return $right;
            }
            if ($nums[$mid] == $target) {
                return $mid;
            }
            if ($nums[$mid] > $nums[$left]) { 
                //第一种情况
                if ($target > $nums[$mid]) {
                    $left = $mid + 1;
                } else {
                    if ($target > $nums[$left]) {
                        $right = $mid - 1;
                    } else {
                        $left = $mid + 1;
                    }
                }
            } else { 
                //第二种情况
                if ($target > $nums[$mid]) {
                    if ($target < $nums[$right]) {
                        $left = $mid + 1;
                    } else {
                        $right = $mid -1;
                    }
                } else {
                    $right = $mid -1;
                }
            }
        }
        return -1;
    }
}
```

效果:

> 执行用时 : 24 ms, 在Search in Rotated Sorted Array的PHP提交中击败了67.86% 的用户
> 
> 内存消耗 : 15.2 MB, 在Search in Rotated Sorted Array的PHP提交中击败了9.52% 的用户



## 34. Find First and Last Position of Element in Sorted Array

题目描述:

Given an array of integers `nums` sorted in ascending order, find the starting and ending position of a given `target` value.

Your algorithm's runtime complexity must be in the order of O(log *n*).

If the target is not found in the array, return `[-1, -1]`.

**Example 1:**


<pre>
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
</pre>



**Example 2:**


<pre>
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
</pre>

解答 1:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Integer[]
     */
    function searchRange($nums, $target) 
    {
        if (!in_array($target, $nums)) {
            return [-1, -1];
        }
        $start = array_search($target, $nums);
        // PHP是最好的语言!
        $end = count($nums) - 1 - array_search($target, array_reverse($nums));
        return [$start, $end];
    }
}
```


效果 1:

> 执行用时 : 32 ms, 在所有PHP提交中击败了 95.12% 的用户
> 
> 内存消耗 : 19 MB, 在所有PHP提交中击败了 50.00% 的用户


解答 2:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Integer[]
     */
    function searchRange($nums, $target) 
    {
        if (!in_array($target, $nums)) {
            return [-1, -1];
        }
        // PHP 是最好的语言!
        $positions = array_keys($nums, $target);
        return [min($positions), max($positions)];
    }
}
```


效果 2:

> 执行用时: 28 ms, 在所有 PHP 提交中击败了 96.36% 的用户
> 
> 内存消耗: 18.9 MB, 在所有 PHP 提交中击败了 62.50% 的用户


实现 API 的人比你聪明多了, 不要重复造轮子.

解答 2 不管是从速度还是从手法还是从可读性上都比较好, 算是一个比较好的做法, 比写了一长串的二分查找好多了. 不是说反对用二分查找, 只是说在有的场合明明正常调 API 就可以解决的话, 那就不用按照某某算法的流程来. 而且这两个做法都适合无序的情形, 可以上来就用. 

这个题也可以拿来考萌新用. 对数组和字符串这两种数据结构有一个基本的认识, 不管在啥语言里都还是有必要的...


## 35. Search Insert Position

题目描述:

Given a **sorted** array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

**Example 1:**


<pre>
Input: [1,3,5,6], 5
Output: 2
</pre>


**Example 2:**


<pre>
Input: [1,3,5,6], 2
Output: 1
</pre>


**Example 3:**


<pre>
Input: [1,3,5,6], 7
Output: 4
</pre>


**Example 4:**


<pre>
Input: [1,3,5,6], 0
Output: 0
</pre>

解答1:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Integer
     */
    function searchInsert($nums, $target)
    {
        if (in_array($target, $nums)) {
            return array_search($target, $nums);
        }
        $count = count($nums);
        if ($target < $nums[0]) {
            return 0;
        }
        if ($target > end($nums)) {
            return $count;
        }
        for ($i = 0; $i < $count - 1; $i++) {
            if ($target > $nums[$i] && $target < $nums[$i + 1]) {
                return $i + 1;
            }
        }
    }
}
```


效果1:

> 执行用时 : 8 ms, 在所有PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 15.8 MB, 在所有PHP提交中击败了 17.07% 的用户



解答2:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Integer
     */
    function searchInsert($nums, $target)
    {
        if (in_array($target, $nums)) {
            return array_search($target, $nums);
        }
        $nums[] = $target;
        sort($nums);
        return array_search($target, $nums);
    }
}
```

效果2:

> 执行用时 : 20 ms, 在所有PHP提交中击败了 85.86% 的用户
> 
> 内存消耗 : 15.6 MB, 在所有PHP提交中击败了 73.17% 的用户


注意这个题给的是sorted, 不是什么rsorted, 不用瞎想.


## 38. Count and Say

题目描述:

The count-and-say sequence is the sequence of integers with the first five terms as following:

<pre>
1. 1
2. 11
3. 21
4. 1211
5. 111221
</pre>


`1` is read off as `"one 1"` or `11`.
`11` is read off as `"two 1s"` or k.
`21` is read off as` "one 2, then one 1"` or `1211`.

Given an integer *n* where 1 ≤ *n* ≤ 30, generate the *n*^th term of the count-and-say sequence.

Note: Each term of the sequence of integers will be represented as a string.

 

**Example 1:**


<pre>
Input: 1
Output: "1"
</pre>

**Example 2:**


<pre>
Input: 4
Output: "1211"
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @return String
     */
    function countAndSay($n) 
    {
        // 初始情况
        $str = "1";
        $i == 1;
        if ($n == $i) {
            return $str;
        }
        // 从第二项开始用前一项的结果递归.
        for ($i = 2; $i <= $n; $i++) {
            $str = preg_replace_callback('#(.)\1*#', function ($matches) {
                return strlen($matches[0]) . $matches[1];
            }, $str);
        }
        
        return $str;
    }
}
```


效果:

> 执行用时 : 12 ms, 在Count and Say的PHP提交中击败了 96.61% 的用户
> 
> 内存消耗 : 15.1 MB, 在Count and Say的PHP提交中击败了 5.26% 的用户


这是个很漂亮的数学发现, 有很多数学名家研究过, 自然而然也出现了一堆有意思的衍生品. 领域原始论文参见[Conway论文: The weird and wonderful chemistry of audioactive decay](https://static01.nyt.com/packages/pdf/crossword/GENIUS_AT_PLAY_Eureka_Article.pdf). 或者通过[全国图书馆论文搜索网](http://eng.ucdrs.superlib.net/views/specific/2929/FJourDetail.jsp?dxNumber=370104395815&d=F89AFD470852242F11F87777805CDD82)根据提示操作等人给你发也可以.


## 41. First Missing Positive

题目描述:

Given an unsorted integer array, find the smallest missing positive integer.

**Example 1:**


<pre>
Input: [1,2,0]
Output: 3
</pre>


**Example 2:**


<pre>
Input: [3,4,-1,1]
Output: 2
</pre>


**Example 3:**


<pre>
Input: [7,8,9,11,12]
Output: 1
</pre>


**Note:**

Your algorithm should run in O(*n*) time and uses constant extra space.



解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function firstMissingPositive($nums) 
    {
        $i = 1;
        // 反正是能过OJ.
        while (in_array($i, $nums)) {
            $i++;
        }
        return $i;
    }
}
```


效果:

> 执行用时 : 8 ms, 在First Missing Positive的PHP提交中击败了 98.15% 的用户
> 
> 内存消耗 : 15 MB, 在First Missing Positive的PHP提交中击败了 9.52% 的用户


能实现需求就行. 


## 42. Trapping Rain Water

题目描述:

Given *n* non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

![42题图](https://i.loli.net/2019/06/25/5d117ea1b73f130024.png)


The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. **Thanks Marcos** for contributing this image!

**Example:**


<pre>
Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $height
     * @return Integer
     */
    function trap($height) 
    {
        $count = count($height);
        if ($height == null || $count == 0) {
            return 0;
        }
        
        $left_max = [];
        $right_max = [];
        
        $left_max[0] = $height[0];
        for ($i = 1; $i < $count; $i++) {
            $left_max[$i] = max($height[$i], $left_max[$i - 1]);
        }
        
        $right_max[$count - 1] = $height[$count - 1];
        for ($i = $count - 2; $i >= 0; $i--) {
            $right_max[$i] = max($height[$i], $right_max[$i + 1]);
        }
        
        $volume = 0;
        for ($i = 1; $i < $count - 1; $i++) {
            $volume += (min($left_max[$i], $right_max[$i]) - $height[$i]);
        }
        return $volume;
    }
}
```


效果:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 97.44% 的用户
> 
> 内存消耗 : 16.2 MB, 在所有 PHP 提交中击败了 31.25% 的用户

![trapping_rain_water题解.png](https://i.loli.net/2019/06/25/5d11a7711550322901.png)

算法:

* Find maximum height of bar from the left end upto an index `$i` in the array `$left_max`.
* Find maximum height of bar from the right end upto an index `$i` in the array `$right_max`.
* Iterate over the array and update `$volume`.
  * Add `min($left_max[$i], $right_max[$i]) - $height[$i]` to `$volume`.


动态规划, 写得比较优雅可读性也比较好的一个做法. 其实可以通过更新两次极高点数组`array_fill(0, count($height), 0)`来避免使用`$left_max`、`$right_max`, 能省一点内存, 但可读性稍微差一些. 我个人认为, 满足需求的前提下, 可以牺牲一部分性能来获取更好的可读性.


## 43. Multiply Strings

题目描述:


Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.

**Example 1:**


<pre>
Input: num1 = "2", num2 = "3"
Output: "6"
</pre>


**Example 2:**


<pre>
Input: num1 = "123", num2 = "456"
Output: "56088"
</pre>


**Note:**


1. The length of both `num1` and `num2` is < 110.
2. Both `num1` and `num2` contain only digits `0-9`.
3. Both `num1` and `num2` do not contain any leading zero, except the number 0 itself.
4. You **must not use any built-in BigInteger library** or **convert the inputs to integer** directly.


解答:

```php
class Solution 
{

    /**
     * @param String $num1
     * @param String $num2
     * @return String
     */
    function multiply($num1, $num2) 
    {
        // 先把结果为零的情况先写了, 要不放在最后写太费事儿.
        if ($num1 === '0' || $num2 === '0') {
            return '0';
        }
        $num1Len = strlen($num1);
        $num2Len = strlen($num2);
        // 初始化一个容量为两个数位数和的数组用来存放结果, 因为结果最长不会超过这个容量. 
        $resultArr = array_fill(0, $num1Len + $num2Len, 0);
        for ($i = $num1Len - 1; $i >= 0; $i--) {
            for ($j = $num2Len - 1; $j >= 0; $j--) {
                $high = $i + $j; // 高位
                $low = $i + $j + 1; // 低位
                // 对应位相乘加上本来有的位(就是进位)再做处理的中间结果
                $temp = $num1[$i] * $num2[$j] + $resultArr[$low];
                $resultArr[$high] += floor($temp / 10); // 高位就是乘完加进位取整除以10
                $resultArr[$low] = $temp % 10; // 低位就是乘完加进位模10取余
            }
        }
        // 去掉前面的0. PHP是最好的语言!
        return ltrim(implode('', $resultArr), '0');
    }
}
```


效果:

> 执行用时 : 56 ms, 在所有 PHP 提交中击败了 94.23% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 90.00% 的用户


直接`intval()`乘完再`strval()`转换不行, `e`符号开始的那串东西没有bcmath弄不了. 

就是和小学教的竖式乘法差不多的想法. 至于为什么乘数均非零的时候, 乘积位数不会超过两个数各自的位数之和, 很简单, 注意到`intval($num1) * (10 ** strlen($num2)) > intval($num1) * intval($num2) ≥ intval($num1) * (10 ** (strlen($num2) - 1))`即可理解. 所以说乘数均非零的时候, 乘积位数的下界是`strlen($num1) + strlen($num2) - 1`, 乘积位数的上界为`strlen($num1) + strlen($num2)`. 当然当你至少有一个乘数为零的时候就另当别论了, 乘积位数为1.


我记得这个题在数据结构教材里好像也比较有名. 大整数乘法什么的.


## 49. Group Anagrams

题目描述:


Given an array of strings, group anagrams together.

**Example:**


<pre>
<strong>Input:</strong> ["eat", "tea", "tan", "ate", "nat", "bat"],
<strong>Output:</strong>
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
</pre>



**Note:**

* All inputs will be in lowercase.
* The order of your output does not matter.



解答:


```php
class Solution 
{

    /**
     * @param String[] $strs
     * @return String[][]
     */
    function groupAnagrams($strs) 
    {
        // 建立排序后的字符串和异位词组的映射.
        $map = [];
        foreach ($strs as $str) {
            $temp = str_split($str);
            sort($temp);
            $sorted = implode($temp);
            if (empty($map[$sorted])) {
                $map[$sorted] = [];
            }
            $map[$sorted][] = $str;
        }
        return array_values($map);
    }
}
```


效果:

> 执行用时 :36 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 21.1 MB, 在所有 PHP 提交中击败了 93.33% 的用户


主要在于怎么弄出一个合适的对应关系.


## 50. Pow(x, n)

题目描述:

Implement pow(*x*, *n*), which calculates *x* raised to the power *n* (x<sup>n</sup>).

**Example 1:**

<pre>
Input: 2.00000, 10
Output: 1024.00000
</pre>

**Example 2:**

<pre>
Input: 2.10000, 3
Output: 9.26100
</pre>

**Example 3:**

<pre>
Input: 2.00000, -2
Output: 0.25000
Explanation: 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25
</pre>

**Note:**

* -100.0 < *x* < 100.0
* *n* is a 32-bit signed integer, within the range [−2<sup>31</sup> , 2<sup>31</sup> − 1]


解答1:

```php
class Solution 
{
    /**
     * @param Float $x
     * @param Integer $n
     * @return Float
     */
    function myPow($x, $n) 
    {
        return $x ** $n;
    }
    
}
```

效果1:

> 执行用时 : 12 ms, 在Pow(x, n)的PHP提交中击败了93.65% 的用户
> 
> 内存消耗 : 14.9 MB, 在Pow(x, n)的PHP提交中击败了41.67% 的用户


解答2:

```php
class Solution 
{
    static function power($x, $n) 
    {
        if ($n == 0) {
          // 注意: 0 ** 0被看作是1.
          return 1;
        }
        $v = self::power($x, floor($n / 2));
        if ($n % 2 == 0) {
          return $v * $v;
        } else {
          return $v * $v * $x;
        }
    }

    /**
     * @param Float $x
     * @param Integer $n
     * @return Float
     */
    function myPow($x, $n) 
    {
        if ($n < 0) {
            return 1 / self::power($x, -$n);
        } else {
            return self::power($x, $n);
        }
    }
    
}
```

效果2:

> 执行用时 : 8 ms, 在Pow(x, n)的PHP提交中击败了100.00% 的用户
> 
> 内存消耗 : 14.5 MB, 在Pow(x, n)的PHP提交中击败了83.33% 的用户


分治法.


## 53. Maximum Subarray


题目描述:

Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.


**Example:**


<pre>
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
</pre>


**Follow up:**

If you have figured out the O(*n*) solution, try coding another solution using the divide and conquer approach, which is more subtle.



解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maxSubArray($nums) 
    {
        $global_max_sub_array_sum = PHP_INT_MIN; 
        $local_max_sub_array_sum = 0; 
        $count = count($nums);
        for ($i = 0; $i < $count; $i++) { 
            $local_max_sub_array_sum += $nums[$i];
            if ($global_max_sub_array_sum < $local_max_sub_array_sum) {
                $global_max_sub_array_sum = $local_max_sub_array_sum; 
            }
            // 局部子序列和小于0的时候则将其重置为0, 重启新一轮.
            if ($local_max_sub_array_sum < 0) {
                $local_max_sub_array_sum = 0; 
            }
        }
        return $global_max_sub_array_sum; 
    }
}
```

效果:

> 执行用时 : 32 ms, 在所有PHP提交中击败了 69.35% 的用户
> 
> 内存消耗 : 15.9 MB, 在所有PHP提交中击败了 76.00% 的用户

## 58. Length of Last Word

题目描述:

Given a string s consists of upper/lower-case alphabets and empty space characters `' '`, return the length of last word in the string.

If the last word does not exist, return 0.

**Note:** A word is defined as a character sequence consists of non-space characters only.

**Example:**


<pre>
Input: "Hello World"
Output: 5
</pre>

解答:

```php
class Solution 
{

    /**
     * @param String $s
     * @return Integer
     */
    function lengthOfLastWord($s) 
    {
        $word_array = explode(' ', $s);
        $word_array = array_filter($word_array);
        return strlen(end($word_array));
    }
}
```

效果:

> 执行用时 : 8 ms, 在Length of Last Word的PHP提交中击败了 97.56% 的用户
>
> 内存消耗 : 14.7 MB, 在Length of Last Word的PHP提交中击败了 77.94% 的用户

## 66. Plus One


题目描述:

Given a **non-empty** array of digits representing a non-negative integer, plus one to the integer.

The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.

You may assume the integer does not contain any leading zero, except the number 0 itself.

**Example 1:**


<pre>
Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
</pre>


**Example 2:**


<pre>
Input: [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $digits
     * @return Integer[]
     */
    function plusOne($digits) 
    {
        $count = count($digits);
        for ($i = $count - 1; $i >= 0; $i--) {
            $digit = $digits[$i];
            if ($digit < 9) {
                $digits[$i] = $digit + 1;
                return $digits;
            } else {
                $digits[$i] = 0;
            }
        }
        $digits[] = 0;
        $digits[0] = 1;
        return $digits;
    }
}
```

效果:

> 执行用时 : 16 ms, 在Plus One的PHP提交中击败了 76.09% 的用户
> 
> 内存消耗 : 14.8 MB, 在Plus One的PHP提交中击败了 25.93% 的用户



## 67. Add Binary


题目描述:

Given two binary strings, return their sum (also a binary string).

The input strings are both **non-empty** and contains only characters `1` or `0`.

**Example 1:**


<pre>
Input: num1 = "11", num2 = "1"
Output: "100"
</pre>


**Example 2:**


<pre>
Input: num1 = "1010", num2 = "1011"
Output: "10101"
</pre>

解答:

```php
class Solution {

    /**
     * @param String $num1
     * @param String $num2
     * @return String
     */
    function addBinary($num1, $num2) {
        if ($num1 === '0' && $num2 === '0') {
            return '0';
        }
        $num1Len = strlen($num1);
        $num2Len = strlen($num2);
        $largerLen = max($num1Len, $num2Len);
        // 初始化一个容量为两个数长度较大的那个长度+1的数组用来存放结果, 因为结果最长不会超过这个容量. 
        $resultArr = array_fill(0, $largerLen + 1, 0);
        // 在加数前面补0直到位数一样(较大的位数). 
        $paddedNum1 = str_pad($num1, $largerLen, '0', STR_PAD_LEFT);
        $paddedNum2 = str_pad($num2, $largerLen, '0', STR_PAD_LEFT);
        for ($i = $largerLen - 1; $i >= 0; $i--) {
            // 同一位置的对应位相加再加上本来有的位(就是进位)再做处理的中间结果
            $temp = $paddedNum1[$i] + $paddedNum2[$i] + $resultArr[$i + 1];
            $resultArr[$i + 1] = $temp % 2;
            $resultArr[$i] += floor($temp / 2); // 高位就是乘完加进位取整除以2   
        }
        // 去掉前面的0. PHP是最好的语言!
        return ltrim(implode('', $resultArr), '0');
    }
}
```


效果:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 87.27% 的用户
> 
> 内存消耗 : 14.7 MB, 在所有 PHP 提交中击败了 75.00% 的用户



这个题和43. Multiply Strings的想法其实差不多.

`decbin()`和`bindec()`之类的还是不行, `e`符号开始的那串东西没有bcmath弄不了. 


注意到`max($num1, $num2) << 1 ≥ intval($num1) + intval($num2) ≥ max($num1, $num2)`. 所以说加数均非零的时候, 和的位数的上界是`max(strlen($num1), strlen($num2)) + 1`, 乘积位数的下界为`max(strlen($num1), strlen($num2))`. 


再一个也是要注意边界情况的讨论.


## 69. Sqrt(x)

题目描述:

Implement `int sqrt(int x)`.

Compute and return the square root of *x*, where *x* is guaranteed to be a non-negative integer.

Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.

**Example 1:**

<pre>
Input: 4
Output: 2
</pre>

**Example 2:**

<pre>
Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.
</pre>

解答: 

```php
class Solution 
{

    /**
     * @param Integer $x
     * @return Integer
     */
    function mySqrt($x) 
    {
        // PHP是最好的语言!
        return floor($x ** (1/2));
    }
}
```

效果:

> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 98.99% 的用户
> 
> 内存消耗 : 14.4 MB, 在所有 PHP 提交中击败了 93.88% 的用户


## 70. Climbing Stairs



题目描述:

You are climbing a stair case. It takes *n* steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Note:** Given *n* will be a positive integer.

**Example 1:**

<pre>
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
</pre>


**Example 2:**


<pre>
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</pre>

解答1:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @return Integer
     */
    function climbStairs($n) 
    {
        $fib_array = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049];
        return $fib_array[$n - 1];
    }
}
```



效果1:

> 执行用时 : 4 ms, 在Climbing Stairs的PHP提交中击败了 99.43% 的用户
> 
> 内存消耗 : 14.9 MB, 在Climbing Stairs的PHP提交中击败了 6.03% 的用户



解答2: 动态规划


```php
class Solution 
{

    /**
     * @param Integer $n
     * @return Integer
     */
    function climbStairs($n) 
    {
        if ($n == 1) {
            return 1;
        }
        $dp = [];
        $dp[1] = 1;
        $dp[2] = 2;
        for ($i = 3; $i <= $n; $i++) {
            $dp[$i] = $dp[$i - 1] + $dp[$i - 2];
        }
        return $dp[$n];
    }
}
```

效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 79.87% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 81.93% 的用户






解答1同509, 拿来变一变就能用了, 但是得多查几项追加到后面, 否则过不了OJ. 再就是你得看出来这是个Fibonacci序列. 占内存多就加内存.


解答2:

显而易见, 这个问题可以被分解为一些包含最优子结构 property 的子问题, 即它的最优解可以从其子问题的最优解来有效构建, 我们可以使用动态规划来解决这个题.

去到第 *i*<sup><em>th</em></sup> 个台阶有以下两种方法:

1. 在第 (*i − 1*)<sup><em>th</em></sup> 个台阶处再向上爬一个台阶.
2. 在第 (*i − 2*)<sup><em>th</em></sup> 个台阶处再向上一下爬两个台阶.

所以到达第  *i*<sup><em>th</em></sup> 个台阶的方法总数就是到第 (*i − 1*)<sup><em>th</em></sup> 个台阶和第 (*i − 2*)<sup><em>th</em></sup> 个台阶的方法数之和.

令 `dp[i]` 表示能到达第 *i*<sup><em>th</em></sup> 个台阶的方法总数, 则有 `dp[i] = dp[i − 1] + dp[i − 2]` .


象征性看看, 万一以后用上了呢.



## 71. Simplify Path

题目描述:


Given an **absolute path** for a file (Unix-style), simplify it. Or in other words, convert it to the **canonical path**.

In a UNIX-style file system, a period `.` refers to the current directory. Furthermore, a double period `..` moves the directory up a level. For more information, see: [Absolute path vs relative path in Linux/Unix](https://www.linuxnix.com/abslute-path-vs-relative-path-in-linuxunix/).

Note that the returned canonical path must always begin with a slash `/`, and there must be only a single slash `/` between two directory names. The last directory name (if it exists) **must not** end with a trailing `/`. Also, the canonical path must be the **shortest** string representing the absolute path.

**Example 1:**


<pre>
Input: "/home/"
Output: "/home"
Explanation: Note that there is no trailing slash after the last directory name.
</pre>

**Example 2:**


<pre>
Input: "/../"
Output: "/"
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.
</pre>


**Example 3:**


<pre>
Input: "/home//foo/"
Output: "/home/foo"
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.
</pre>


**Example 4:**


<pre>
Input: "/a/./b/../../c/"
Output: "/c"
</pre>


**Example 5:**


<pre>
Input: "/a/../../b/../c//.//"
Output: "/c"
</pre>


**Example 6:**


<pre>
Input: "/a//b////c/d//././/.."
Output: "/a/b/c"
</pre>


解答1:

```php
class Solution 
{

    /**
     * @param String $path
     * @return String
     */
    function simplifyPath($path) 
    {
        $path = str_replace(array('/', '\\'), DIRECTORY_SEPARATOR, $path);
        $parts = array_filter(explode(DIRECTORY_SEPARATOR, $path), 'strlen');
        $absolute_path = [];
        foreach ($parts as $part) {
            if ('.' == $part) {
                continue;
            }
            if ('..' == $part) {
                array_pop($absolute_path);
            } else {
                $absolute_path[] = $part;
            }
        }
        return '/' . implode(DIRECTORY_SEPARATOR, $absolute_path);
    }
}
```


效果1:

> 执行用时 : 16 ms, 在Simplify Path的PHP提交中击败了 90.91% 的用户
> 
> 内存消耗 : 14.7 MB, 在Simplify Path的PHP提交中击败了 66.67% 的用户


解答2:

```php
class Solution 
{

    /**
     * @param String $path
     * @return String
     */
    function simplifyPath($path) 
    {
        $parts = array_filter(explode('/', $path));
        $absolute_path = [];
        foreach ($parts as $part) {
            if ('.' == $part) {
                continue;
            }
            if ('..' == $part) {
                array_pop($absolute_path);
            } else {
                $absolute_path[] = $part;
            }
        }
        return '/' . implode('/', $absolute_path);
    }
}
```


效果2:


> 执行用时 : 16 ms, 在Simplify Path的PHP提交中击败了 90.91% 的用户
> 
> 内存消耗 : 14.7 MB, 在Simplify Path的PHP提交中击败了 50.00% 的用户


注意: 不能直接上`realpath`函数, 因为当文件不存在的时候这个函数是会返回`false`的.

这个题还是比较有实际应用价值的, 建议好好看看. 


## 72. Edit Distance

题目描述:

Given two words *word1* and *word2*, find the minimum number of operations required to convert *word1* to *word2*.

You have the following 3 operations permitted on a word:

1. Insert a character
2. Delete a character
3. Replace a character



**Example 1:**


<pre>
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
</pre>


**Example 2:**


<pre>
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
</pre>


解答:

```php
class Solution 
{

    /**
     * @param String $word1
     * @param String $word2
     * @return Integer
     */
    function minDistance($word1, $word2) 
    {
        $word1_len = strlen($word1);
        $word2_len = strlen($word2);
        $dp = [];
        for ($i = 0; $i <= $word1_len; $i++) {
            $dp[$i][0] = $i;
        }
        for ($j = 0; $j <= $word2_len; $j++) {
            $dp[0][$j] = $j;
        }      
        for ($i = 1; $i <= $word1_len; $i++) {
            for ($j = 1; $j <= $word2_len; $j++) {
                if (substr($word1, $i - 1, 1) == substr($word2, $j - 1, 1)) {
                    $dp[$i][$j] = $dp[$i - 1][$j - 1];
                } else {
                    $dp[$i][$j] = min($dp[$i - 1][$j], $dp[$i][$j - 1], $dp[$i - 1][$j - 1]) + 1;
                }
            }
        }
        return $dp[$word1_len][$word2_len];
    }
}
```


效果:

> 执行用时 : 64 ms, 在所有 PHP 提交中击败了 85.71% 的用户
> 
> 内存消耗 : 22.5 MB, 在所有 PHP 提交中击败了 100.00% 的用户


动态规划. 如果规模小一些的话, 其实用`levenshtein()`函数也是可以滴...但是呢, 官方文档明确在Return Values那里说了:“This function returns the Levenshtein-Distance between the two argument strings or -1, if one of the argument strings is longer than the limit of 255 characters.”所以只能自行实现了. 

不过话说回来, `levenshtein()`这样的函数PHP都能有, PHP确实是最好的语言.


## 73. Set Matrix Zeroes

题目描述:

Given a *m* x *n* matrix, if an element is 0, set its entire row and column to 0. Do it <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a>.

**Example 1:**


<pre>
<strong>Input: </strong> 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
<strong>Output: </strong> 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
</pre>


**Example 2:**

<pre>
<strong>Input: </strong>
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
<strong>Output: </strong>
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
</pre>


**Follow up:**

* A straight forward solution using O(*mn*) space is probably a bad idea.
* A simple improvement uses O(*m* + *n*) space, but still not the best solution.
* Could you devise a constant space solution?


解答:

```php
class Solution 
{

    /**
     * @param Integer[][] $matrix
     * @return NULL
     */
    function setZeroes(&$matrix) 
    {
        $rowCount = count($matrix);
        $columnCount = count($matrix[0]);
        if ($rowCount == 0 || $columnCount == 0) {
            return;
        }
        // 检查第一行是否有0元素.
        $hasZeroInFirstRow = in_array(0, $matrix[0], true);
        // 把往后所有有0元素的行设为0, 再在第一行中标记含有0元素的列.
        for ($i = 1; $i < $rowCount; $i++) {
            $hasZeroFromSecondRow = false;
            for ($j = 0; $j < $columnCount; $j++) {
                if ($matrix[$i][$j] == 0) {
                    $hasZeroFromSecondRow = true;
                    $matrix[0][$j] = 0;
                }
            }
            if ($hasZeroFromSecondRow) {
                $matrix[$i] = array_fill(0, $columnCount, 0);
            }
        }
        // 将所有含有0元素的列设为0.
        for ($j = 0; $j < $columnCount; $j++) {
            if ($matrix[0][$j] == 0) {
                for ($i = 1; $i < $rowCount; $i++) {
                    $matrix[$i][$j] = 0;
                }
            }
                
        }
        // 回过头把第一行处理一下.
        if ($hasZeroInFirstRow) {
            $matrix[0] = array_fill(0, $columnCount, 0);
        }
        
    }
}
```

效果:

> 执行用时 : 56 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 19.2 MB, 在所有 PHP 提交中击败了 16.67% 的用户


有些麻烦...


## 74. Search a 2D Matrix


题目描述:


Write an efficient algorithm that searches for a value in an *m* x *n* matrix. This matrix has the following properties:

* Integers in each row are sorted from left to right.
* The first integer of each row is greater than the last integer of the previous row.


**Example 1:**


<pre>
<strong>Input:</strong>
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
<strong>Output:</strong> true
</pre>


**Example 2:**


<pre>
<strong>Input:</strong>
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
<strong>Output:</strong>  false
</pre>



解答:

```php
class Solution 
{

    /**
     * @param Integer[][] $matrix
     * @param Integer $target
     * @return Boolean
     */
    function searchMatrix($matrix, $target) 
    {
        foreach ($matrix as $row) {
            if ($target <= end($row)) {
                return in_array($target, $row);
            }
        }
        return false;
    }
}
```


效果:

> 执行用时 : 24 ms, 在所有 PHP 提交中击败了 91.67% 的用户
>
> 内存消耗 : 16.7 MB, 在所有 PHP 提交中击败了 90.00% 的用户




## 75. Sort Colors


题目描述:


Given an array with *n* objects colored red, white or blue, sort them [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

**Note:** You are not suppose to use the library's sort function for this problem.

**Example:**


<pre>
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
</pre>



**Follow up:**

* A rather straight forward solution is a two-pass algorithm using counting sort.
  
  First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.

* Could you come up with a one-pass algorithm using only constant space?



解答1:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return NULL
     */
    function sortColors(&$nums) 
    {
        // PHP是最好的语言!
        $occurrence_count = array_count_values($nums);
        $count_of_zero = $occurrence_count['0'];
        $count_of_one = $occurrence_count['1'];
        $count_of_two = $occurrence_count['2'];
        $count = $count_of_zero + $count_of_one + $count_of_two;
        for ($i = 0; $i < $count; $i++) {
            if ($i < $count_of_zero) {
                $nums[$i] = 0;
            }
            if ($count_of_zero <= $i && $i < $count_of_zero + $count_of_one) {
                $nums[$i] = 1;
            }
            if ($i >= $count_of_zero + $count_of_one) {
                $nums[$i] = 2;
            }
        }
    }
}
```

效果1:


> 执行用时 : 8 ms, 在所有PHP提交中击败了 90.48% 的用户
> 
> 内存消耗 : 14.8 MB, 在所有PHP提交中击败了 11.11% 的用户


解答2:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return NULL
     */
    function sortColors(&$nums) 
    {
        // PHP是最好的语言!
        $occurrence_count = array_count_values($nums);
        $count_of_zero = $occurrence_count['0'];
        $count_of_one = $occurrence_count['1'];
        $count_of_two = $occurrence_count['2'];
        $nums = array_merge(array_fill(0, $count_of_zero, 0), array_fill($count_of_zero, $count_of_one, 1), array_fill($count_of_zero + $count_of_one, $count_of_two, 2));
    }
}
```


效果2:


> 执行用时 : 8 ms, 在所有PHP提交中击败了 90.48% 的用户
> 
> 内存消耗 : 14.5 MB, 在所有PHP提交中击败了 77.78% 的用户


内存这方面倒是有大概的认识, 但是从没真正理解...

## 78. Subsets


题目描述:


Given a set of **distinct** integers, nums, return all possible subsets (the power set).


**Note:** The solution set must not contain duplicate subsets.

**Example:**


<pre>
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</pre>


解答:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer[][]
     */
    function subsets($nums) 
    {
        $results = [[]];
        foreach ($nums as $element) {
            foreach ($results as $combination) {
                array_push($results, array_merge([$element], $combination));
            }  
        }
        return $results;
    }
}
```


效果:

> 执行用时 : 12 ms, 在所有PHP提交中击败了 95.16% 的用户
> 
> 内存消耗 : 15.3 MB, 在所有PHP提交中击败了 67.57% 的用户


这个题感觉也比较有用, 当然是指数学上的那方面的有用.



## 80. Remove Duplicates from Sorted Array II

题目描述:

Given a sorted array *nums*, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that duplicates appeared at most *twice* and return the new length.

Do not allocate extra space for another array, you must do this by **modifying the input array** <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> with O(1) extra memory.

**Example 1:**

<pre>
Given <em>nums</em> = [<strong>1</strong>,<strong>1</strong>,<strong>1</strong>,<strong>2</strong>,<strong>2</strong>,<strong>3</strong>],

Your function should return length = <strong>5</strong>, with the first five elements of <em>nums</em> being <strong>1</strong>, <strong>1</strong>, <strong>2</strong>, <strong>2</strong> and <strong>3</strong> respectively.

It doesn't matter what you leave beyond the returned length.
</pre>

**Example 2:**


<pre>
Given <em>nums</em> = [<strong>0</strong>,<strong>0</strong>,<strong>1</strong>,<strong>1</strong>,<strong>1</strong>,<strong>1</strong>,<strong>2</strong>,<strong>3</strong>,<strong>3</strong>],

Your function should return length = <strong>7</strong>, with the first seven elements of <em>nums</em> being modified to <strong>0</strong>, <strong>0</strong>, <strong>1</strong>, <strong>1</strong>, <strong>2</strong>, <strong>3</strong> and <strong>3</strong> respectively.

It doesn't matter what values are set beyond the returned length.
</pre>

**Clarification:**


Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by **reference**, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

<pre>
// <strong>nums</strong> is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to <strong>nums</strong> in your function would be known by the caller.
// using the length returned by your function, it prints the first <strong>len</strong> elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function removeDuplicates(&$nums) 
    {
        $count = count($nums);
        if ($count <= 2) {
            return $count;
        }
        $index = 2;
        for ($i = 2; $i < $count; $i++) {
            if ($nums[$i] != $nums[$index - 2]) {
                $nums[$index++] = $nums[$i];
            }
        }
        return $index;
    }
}
```

效果:

> 执行用时 : 24 ms, 在Remove Duplicates from Sorted Array II的PHP提交中击败了 95.65% 的用户
> 
> 内存消耗 : 15 MB, 在Remove Duplicates from Sorted Array II的PHP提交中击败了 14.29% 的用户

## 81. Search in Rotated Sorted Array II

题目描述:

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., `[0,0,1,2,2,5,6]` might become `[2,5,6,0,0,1,2]`).

You are given a target value to search. If found in the array return true, otherwise return false.

**Example 1:**

<pre>
Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
</pre>

**Example 2:**

<pre>
Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
</pre>

**Follow up:**

* This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.
* Would this affect the run-time complexity? How and why?


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $target
     * @return Boolean
     */
    function search($nums, $target) 
    {
        $count = count($nums);
        if ($count == 0) {
            return false;
        }
        $left = 0;
        $right = $count - 1;
        while ($left <= $right) {
            $mid = floor(($left + $right) / 2);
            if ($nums[$mid] == $target) {
                return true;
            } elseif ($nums[$mid] < $nums[$right]) {
                if ($nums[$mid] < $target && $nums[$right] >= $target) {
                    $left = $mid + 1;
                } else {
                    $right = $mid - 1;
                }
            } elseif ($nums[$mid] > $nums[$right]) {
                if ($nums[$left] <= $target && $nums[$mid] > $target) {
                    $right = $mid - 1;
                } else {
                    $left = $mid + 1;
                }
            } else {
                --$right;
            }
        }
        return false;
    }
}
```

效果:

> 执行用时 : 28 ms, 在Search in Rotated Sorted Array II的PHP提交中击败了100.00% 的用户
> 
> 内存消耗 : 15.5 MB, 在Search in Rotated Sorted Array II的PHP提交中击败了50.00% 的用户


## 88. Merge Sorted Array

题目描述:

Given two sorted integer arrays *nums1* and *nums2*, merge *nums2* into *nums1* as one sorted array.

**Note:**

* The number of elements initialized in *nums1* and *nums2* are *m* and *n* respectively.
* You may assume that *nums1* has enough space (size that is greater or equal to *m* + *n*) to hold additional elements from *nums2*.


**Example:**


<pre>
<strong>Input:</strong>
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

<strong>Output:</strong> [1,2,2,3,5,6]
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums1
     * @param Integer $m
     * @param Integer[] $nums2
     * @param Integer $n
     * @return NULL
     */
    function merge(&$nums1, $m, $nums2, $n) 
    {
        for ($i = 0; $i < $n; $i++) {
            $nums1[$i + $m] = $nums2[$i];
        }
        sort($nums1, SORT_NUMERIC);
    }
}
```

效果:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 90.98% 的用户
> 
> 内存消耗 : 14.8 MB, 在所有 PHP 提交中击败了 48.89% 的用户


这种用地址的, 得循环挨个元素洗. 那种生成副本的函数用不了.

## 89. Gray Code


题目描述:


The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer *n* representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

**Example 1:**


<pre>
Input: 2
Output: [0,1,3,2]
Explanation:
00 - 0
01 - 1
11 - 3
10 - 2

For a given n, a gray code sequence may not be uniquely defined.
For example, [0,2,3,1] is also a valid gray code sequence.

00 - 0
10 - 2
11 - 3
01 - 1
</pre>



**Example 2:**


<pre>
Input: 0
Output: [0]
Explanation: We define the gray code sequence to begin with 0.
             A gray code sequence of n has size = 2n, which for n = 0 the size is 2 ** 0 = 1.
             Therefore, for n = 0 the gray code sequence is [0].
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @return Integer[]
     */
    function grayCode($n) 
    {
        $result = [];
        for ($i = 0; $i < 1 << $n; $i++) {
            $result[] = $i ^ $i >> 1;
        }
        return $result;
    }
}
```


效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 15 MB, 在所有 PHP 提交中击败了 50.00% 的用户


关于格雷编码的介绍, 可以看一下:[wiki/Gray_code](https://en.wikipedia.org/wiki/Gray_code). 再看看[The Gray Code](https://www.cs.auckland.ac.nz/research/groups/CDMTCS//researchreports/304bob.pdf)

这个应该是CS专业的常识题吧, 似乎是数字电子/数字电路里的, 记住就完事儿了...我目前接触或了解的任何岗位都没有用到这个的...不过说实话看起来确实还挺有用的.

看了一下, 数学上的形式确实是很不错. 此外可以看看Martin Gardner的文章: “CURIOUS PROPERTIES OF GRAY CODE AND HOW IT CAN BE USED TO SOLVE PUZZLES”(【作 者】GARDNER, M;【刊 名】Scientific American;【出版日期】1972;【卷 号】Vol.227;【期 号】No.2)



## 118. Pascal's Triangle

Given a non-negative integer *numRows*, generate the first *numRows* of Pascal's triangle.

先放一个gif看看好不好用, 不过也许够呛...

![PascalTriangleAnimated2.gif](https://i.loli.net/2019/07/04/5d1d97f3b09cb89960.gif)

<small>In Pascal's triangle, each number is the sum of the two numbers directly above it.</small>

再放一个png图试试...我觉着是个人都应该知道帕斯卡三角形, 除非你上到高二就辍学了:

<img src="https://i.loli.net/2019/07/04/5d1d9888dfb4845036.png" style="width:420px"/>


**Example:**


<pre>
<strong>Input:</strong> 5
<strong>Output:</strong>
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer $numRows
     * @return Integer[][]
     */
    function generate($numRows) 
    {
        $triangle = [];
        for ($i = 0; $i < $numRows; $i++) {
            for ($j = 0; $j <= $i; $j++) {
                if ($i === 0 && $j === 0) {
                    // 套定义.
                    $triangle[0][0] = 1;
                } else {
                    $triangle[$i][$j] = $triangle[$i - 1][$j - 1] + $triangle[$i - 1][$j];
                }  
            }
        }
        return $triangle;
    }
}
```

效果:

> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 98.44% 的用户
> 
> 内存消耗 : 14.8 MB, 在所有 PHP 提交中击败了 27.27% 的用户


在本地跑的话页面会报Notice, 不过结果是对的, 你可以上`php.ini`里把警告调小点儿的值. 



## 119. Pascal's Triangle II

题目描述:

Given a non-negative index *k* where *k* ≤ 33, return the *k*<sup>th</sup> index row of the Pascal's triangle.

Note that the row index starts from 0.


gif动画:

![PascalTriangleAnimated2.gif](https://i.loli.net/2019/07/04/5d1d97f3b09cb89960.gif)

<small>In Pascal's triangle, each number is the sum of the two numbers directly above it.</small>

png图备用:

<img src="https://i.loli.net/2019/07/04/5d1d9888dfb4845036.png" style="width:420px"/>


**Example:**

<pre>
<strong>Input:</strong> 3
<strong>Output:</strong> [1,3,3,1]
</pre>


<strong>Follow up:</strong>

Could you optimize your algorithm to use only *O(k)* extra space?


解答:

```php
class Solution 
{

    /**
     * @param Integer $rowIndex
     * @return Integer[]
     */
    function getRow($rowIndex) 
    {
        $triangle = [];
        for ($i = 0; $i < $rowIndex + 1; $i++) {
            for ($j = 0; $j <= $i; $j++) {
                if ($i === 0 && $j === 0) {
                    // 套定义.
                    $triangle[0][0] = 1;
                } else {
                    $triangle[$i][$j] = $triangle[$i - 1][$j - 1] + $triangle[$i - 1][$j];
                }  
            }
        }
        return $triangle[$rowIndex];
    }
}
```

效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 87.88% 的用户
> 
> 内存消耗 : 14.7 MB, 在所有 PHP 提交中击败了 37.50% 的用户


要是能找到资料的话, 把每一行都找出来然后都放到二维数组里也可以...或者你愿意慢慢整理的话直接118题的结果传个33然后操作编辑器.

## 121. Best Time to Buy and Sell Stock

题目描述:


Say you have an array for which the *i*<sup>th</sup> element is the price of a given stock on day *i*.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

**Example 1:**


<pre>
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
</pre>

             
**Example 2:**


<pre>
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $prices
     * @return Integer
     */
    function maxProfit($prices) 
    {
        $count = count($prices);
        if ($count <= 1) {
            return 0;
        }
        $buy = $prices[0];
        $profit = 0;
        for ($i = 1; $i < $count; $i++) {
            $profit = max($profit, $prices[$i] - $buy);
            $buy = min($buy, $prices[$i]);
        }
        return $profit;
    }
}
```

效果:

> 执行用时 : 20 ms, 在Best Time to Buy and Sell Stock的PHP提交中击败了99.32% 的用户
> 
> 内存消耗 : 16.7 MB, 在Best Time to Buy and Sell Stock的PHP提交中击败了28.09% 的用户


这他妈简直是暴利啊...


## 125. Valid Palindrome

题目描述:

Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

**Note:** For the purpose of this problem, we define empty string as valid palindrome.

**Example 1:**

<pre>
Input: "A man, a plan, a canal: Panama"
Output: true
</pre>

**Example 2:**

<pre>
Input: "race a car"
Output: false
</pre>

解答:

```php
class Solution 
{

    /**
     * @param String $str
     * @return Boolean
     */
    function isPalindrome($str) 
    {
        // 匹配非字母数字的字符.
        $str = preg_replace('/[^a-zA-Z0-9]/', '', $str);
        $str = strtolower($str);
        $reverse = strrev($str);
        return ($str == $reverse ? true : false);
    }
}
```


效果:

> 执行用时 : 8 ms, 在Valid Palindrome的PHP提交中击败了100.00% 的用户
> 
> 内存消耗 : 15.5 MB, 在Valid Palindrome的PHP提交中击败了22.73% 的用户



## 128. Longest Consecutive Sequence

题目描述:

Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Your algorithm should run in O(n) complexity.

**Example:**

<pre>
Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
</pre>

解答: 

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function longestConsecutive($nums) 
    {
        $count = count($nums);
        if ($nums === null || $count == 0) {
            return 0;
        }
        
        $map = [];
        $result = 1;
        for ($i = 0; $i < $count; $i++) {
            $num = $nums[$i];
            if (array_key_exists($num, $map)) {
                continue;
            }
            
            $left = array_key_exists($num - 1, $map) ? $map[$num - 1] : 0;
            $right = array_key_exists($num + 1, $map) ? $map[$num + 1] : 0;
            $length = $left + $right + 1;
            $result = max($result, $length);
            
            $map[$num] = $length;
            $map[$num - $left] = $length;
            $map[$num + $right] = $length;
        }
        
        return $result;
    }
}
```

效果:

> 执行用时 : 28 ms, 在Longest Consecutive Sequence的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 16.1 MB, 在Longest Consecutive Sequence的PHP提交中击败了 25.00% 的用户


## 136. Single Number


题目描述:

Given a **non-empty** array of integers, every element appears *twice* except for one. Find that single one.

**Note:**

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

**Example 1:**

<pre>
<strong>Input:</strong> [2,2,1]
<strong>Output:</strong> 1
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> [4,1,2,1,2]
<strong>Output:</strong> 4
</pre>


解答 1:


```php
class Solution 
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function singleNumber($nums) 
    {
        // PHP是最好的语言!
        $nums_info = array_count_values($nums);
        foreach ($nums_info as $num => $frequency) {
            if ($frequency == 1) {
                return $num;
            }
        }
    }
}
```


效果 1:

> 执行用时: 36 ms, 在所有 PHP 提交中击败了 70.83% 的用户
> 
> 内存消耗: 17.2 MB, 在所有 PHP 提交中击败了 80.57% 的用户


解答 2:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function singleNumber($nums) 
    {
        // PHP是最好的语言!
        $nums_info = array_count_values($nums);
        return array_search(1, $nums_info);
    }
}
```

效果 2:

> 执行用时: 24 ms, 在所有 PHP 提交中击败了 99.68% 的用户
> 
> 内存消耗: 17.3 MB, 在所有 PHP 提交中击败了 55.41% 的用户


参考137题、442题.



## 137. Single Number II

题目描述:


Given a **non-empty** array of integers, every element appears *three* times except for one, which appears exactly once. Find that single one.

**Note:**

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

**Example 1:**

<pre>
<strong>Input:</strong> [2,2,3,2]
<strong>Output:</strong> 3
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> [0,1,0,1,0,1,99]
<strong>Output:</strong> 99
</pre>

解答 1:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function singleNumber($nums) 
    {
        // PHP是最好的语言!
        $nums_info = array_count_values($nums);
        foreach ($nums_info as $num => $frequency) {
            if ($frequency == 1) {
                return $num;
            }
        }
    }
}
```

效果 1:

> 执行用时: 16 ms, 在所有 PHP 提交中击败了 95.65% 的用户
> 
> 内存消耗: 16.9 MB, 在所有 PHP 提交中击败了 27.27% 的用户

解答 2:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function singleNumber($nums) 
    {
        // PHP是最好的语言!
        $nums_info = array_count_values($nums);
        return array_search(1, $nums_info);
    }
}
```

效果 2:

> 执行用时: 12 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 16.9 MB, 在所有 PHP 提交中击败了 18.18% 的用户


抄 136 题的代码即可, 和 442 题也比较类似.

## 139. Word Break

题目描述:

Given a **non-empty** string *str* and a dictionary *wordDict* containing a list of **non-empty** words, determine if *str* can be segmented into a space-separated sequence of one or more dictionary words.

**Note:**

* The same word in the dictionary may be reused multiple times in the segmentation.
* You may assume the dictionary does not contain duplicate words.


**Example 1:**


<pre>
Input: str = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
</pre>


**Example 2:**


<pre>
Input: str = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
</pre>


**Example 3:**


<pre>
Input: str = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false
</pre>


解答:


```php
class Solution 
{

    /**
     * @param String $s
     * @param String[] $wordDict
     * @return Boolean
     */
    function wordBreak($str, $wordDict) 
    {
        $len = strlen($str);
        $dp = array_fill(0, $len + 1, false);
        $dp[0] = true;
        for ($i = 0; $i < $len; $i++) {
            for ($j = $i; $j >= 0; $j--) {
                if ($dp[$j] && in_array(substr($str, $j, $i + 1 - $j), $wordDict)) {
                    $dp[$i + 1] = true;
                    break;
                }
            }
        }
        return $dp[$len];
    }
}
```

效果:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 90.00% 的用户
> 
> 内存消耗 : 14.7 MB, 在所有 PHP 提交中击败了 83.33% 的用户

`$dp[$i]`表示`substr($str, 0, $i)`是否可以切割.


## 151. Reverse Words in a String

题目描述:

Given an input string, reverse the string word by word.

 

**Example 1:**

<pre>
<strong>Input:</strong> "the sky is blue"
<strong>Output:</strong> "blue is sky the"
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> "  hello world!  "
<strong>Output:</strong>  "world! hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> "a good   example"
<strong>Output:</strong>  "example good a"
<strong>Explanation:</strong>  You need to reduce multiple spaces between two words to a single space in the reversed string.
</pre>
 

**Note:**

* A word is defined as a sequence of non-space characters.
* Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.
* You need to reduce multiple spaces between two words to a single space in the reversed string.
 

**Follow up:**

For C programmers, try to solve it *in-place* in O(1) extra space.


解答1:

```php
class Solution 
{

    /**
     * @param String $s
     * @return String
     */
    function reverseWords($s) 
    {
        $s = preg_replace("/\s(?=\s)/","\\1", trim($s));
        $pieces = array_reverse(explode(' ', $s));
        return implode(' ', $pieces);
    }
}
```

效果1:

> 执行用时 : 8 ms, 在Reverse Words in a String的PHP提交中击败了 100.00% 的用户
内存消耗 : 15.5 MB, 在Reverse Words in a String的PHP提交中击败了 15.38% 的用户

解答2:

```php
class Solution 
{

    /**
     * @param String $s
     * @return String
     */
    function reverseWords($s)
    {
        // 正则引擎好像吃硬件, 换个别的方法.
        return implode(' ', array_reverse(array_filter(explode(' ', trim($s)))));
    }
}
```

效果2:

> 执行用时 : 12 ms, 在Reverse Words in a String的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 15.1 MB, 在Reverse Words in a String的PHP提交中击败了 76.92% 的用户


## 152. Maximum Product Subarray

题目描述:

Given an integer array `nums`, find the contiguous subarray within an array (containing at least one number) which has the largest product.

**Example 1:**


<pre>
Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
</pre>


**Example 2:**


<pre>
Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maxProduct($nums) 
    {
        $count = count($nums);
        $temp_max[0] = $nums[0];
        $temp_min[0] = $nums[0];
        $max = $nums[0];
        for ($i = 1; $i < $count; $i++) {
            $temp_max[$i] = max($temp_max[$i - 1] * $nums[$i], $temp_min[$i - 1] * $nums[$i], $nums[$i]);
            $temp_min[$i] = min($temp_max[$i - 1] * $nums[$i], $temp_min[$i - 1] * $nums[$i], $nums[$i]);
            $max = max($max, $temp_max[$i]);
        }
        return $max;
    }
}
```

效果:

> 执行用时 : 16 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 16.4 MB, 在所有 PHP 提交中击败了 23.08% 的用户

注意到当前最大乘积、当前最小乘积一定是在当前元素、前一元素时的最大乘积乘以当前元素, 以及前一元素时的最小乘积乘以当前元素这三者中.

## 153. Find Minimum in Rotated Sorted Array


题目描述:

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  `[0,1,2,4,5,6,7]` might become  `[4,5,6,7,0,1,2]`).

Find the minimum element.

You may assume no duplicate exists in the array.

**Example 1:**


<pre>
Input: [3,4,5,1,2] 
Output: 1
</pre>


**Example 2:**


<pre>
Input: [4,5,6,7,0,1,2]
Output: 0
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findMin($nums) 
    {
        return min($nums);
    }
}
```


效果:


> 执行用时 : 16 ms, 在所有 PHP 提交中击败了 95.00% 的用户
> 
> 内存消耗 : 15.1 MB, 在所有 PHP 提交中击败了 38.46% 的用户


反正也是能跑出来需求的.



## 154. Find Minimum in Rotated Sorted Array II


题目描述:


Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  `[0,1,2,4,5,6,7]` might become  `[4,5,6,7,0,1,2]`).

Find the minimum element.

The array may contain duplicates.

**Example 1:**


<pre>
Input: [1,3,5]
Output: 1
</pre>


**Example 2:**


<pre>
Input: [2,2,2,0,1]
Output: 0
</pre>


**Note:**

* This is a follow up problem to 153. Find Minimum in Rotated Sorted Array.
* Would allow duplicates affect the run-time complexity? How and why?



解答:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findMin($nums) 
    {
        return min($nums);
    }
}
```


效果:

> 执行用时 : 28 ms, 在所有 PHP 提交中击败了 50.00% 的用户
> 
> 内存消耗 : 15.2 MB, 在所有 PHP 提交中击败了 100.00% 的用户

这个直接 `min()` 就可以跑出来了, 省下来的时间干点儿别的不好吗...至于这个 `min()` 函数是不是 O(*n*) 复杂度, 看看源码就知道了: [php-src/ext/standard/array.c](https://github.com/php/php-src/blob/master/ext/standard/array.c). 不知道网上号称能看懂源码的大佬有什么想法.


## 156. Binary Tree Upside Down (上锁题目, 需要氪会员)


题目描述:

Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.

**Example:**


<pre>
Input: [1,2,3,4,5]

    1
   / \
  2   3
 / \
4   5

Output: return the root of the binary tree [4,5,2,#,#,3,1]

   4
  / \
 5   2
    / \
   3   1  
</pre>

   
**Clarification:**

Confused what `[4,5,2,#,#,3,1]` means? Read more below on how binary tree is serialized on OJ.

The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below.

Here's an example:


<pre>
   1
  / \
 2   3
    /
   4
    \
     5
</pre>

     
The above binary tree is serialized as `[1,2,3,#,#,4,#,#,5]`.


## 159. Longest Substring with At Most Two Distinct Characters (上锁题目, 需要氪会员)

题目描述:


Given a string ***s*** , find the length of the longest substring ***t***  that contains **at most** 2 distinct characters.

**Example 1:**

<pre>
<strong>Input:</strong> "eceba"
<strong>Output:</strong> 3
<strong>Explanation:</strong> <strong><em>t</em></strong> is "ece" which its length is 3.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> "ccaabbb"
<strong>Output:</strong> 5
<strong>Explanation:</strong> <strong><em>t</em></strong> is "aabbb" which its length is 5.
</pre>


## 161. One Edit Distance (上锁题目, 需要氪会员)

题目描述:

Given two strings ***s*** and ***t***, determine if they are both one edit distance apart.

**Note:** 

There are 3 possiblities to satisify one edit distance apart:

1. Insert a character into s to get t
2. Delete a character from s to get t
3. Replace a character of s to get t


**Example 1:**

<pre>
Input: s = "ab", t = "acb"
Output: true
Explanation: We can insert 'c' into s to get t.
</pre>

**Example 2:**


<pre>
Input: s = "cab", t = "ad"
Output: false
Explanation: We cannot get t from s by only one step.
</pre>


**Example 3:**


<pre>
Input: s = "1203", t = "1213"
Output: true
Explanation: We can replace '0' with '1' to get t.
</pre>


## 162. Find Peak Element

题目描述:

A peak element is an element that is greater than its neighbors.

Given an input array `nums`, where `nums[i] ≠ nums[i+1]`, find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that `nums[-1] = nums[n] = -∞`.

**Example 1:**


<pre>
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
</pre>


**Example 2:**


<pre>
Input: nums = [1,2,1,3,5,6,4]
Output: 1 or 5 
Explanation: Your function can return either index number 1 where the peak element is 2, 
             or index number 5 where the peak element is 6.
</pre>


**Note:**

Your solution should be in logarithmic complexity.


解答1:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findPeakElement($nums) 
    {
        $count = count($nums);
        for ($i = 0; $i < $count - 1; $i++) {
            if ($nums[$i] > $nums[$i + 1])
                return $i;
        }
        return $count - 1;
    }
}
```

效果1:

> 执行用时 : 16 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在所有 PHP 提交中击败了 50.00% 的用户


解答2:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findPeakElement($nums) 
    {
        $left = 0;
        $right = count($nums) - 1;
        $mid = 0;
        while ($left < $right) {
            $mid = $left + floor(($right - $left) / 2);
            if ($nums[$mid] > $nums[$mid + 1]) {
                $right = $mid;
            } else {
                $left = $mid + 1;
            }
        }
        return $left;
    }
}
```

效果2:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.8 MB, 在所有 PHP 提交中击败了 50.00% 的用户


## 164. Maximum Gap


题目描述:

Given an unsorted array, find the maximum difference between the successive elements in its sorted form.

Return 0 if the array contains less than 2 elements.

**Example 1:**


<pre>
<strong>Input:</strong> [3,6,9,1]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The sorted form of the array is [1,3,6,9], either
             (3,6) or (6,9) has the maximum difference 3.
</pre>



             
**Example 2:**


<pre>
<strong>Input:</strong> [10]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The array contains less than 2 elements, therefore return 0.
</pre>


**Note:**

* You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.
* Try to solve it in linear time/space.


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maximumGap($nums) 
    {
        $count = count($nums);
        if ($count == 1) {
            return 0;
        }
        sort($nums, SORT_NUMERIC);
        $maxDifference = 0;
        for ($i = 0; $i < $count - 1; $i++) {
            if ($nums[$i] < $nums[$i + 1]) {
                if ($maxDifference < $nums[$i + 1] - $nums[$i]) {
                    $maxDifference = $nums[$i + 1] - $nums[$i];
                }
            }
        }
        return $maxDifference;
    }
}
```

效果:

> 执行用时: 28 ms, 在所有 PHP 提交中击败了 71.43% 的用户
> 
> 内存消耗: 15.7 MB, 在所有 PHP 提交中击败了 66.67% 的用户


PHP 的这个 `sort()` 是基于[快排](http://en.wikipedia.org/wiki/Quicksort)实现的, 所以时间复杂度是 O(log*n*) (最差情形), 不过空间复杂度 O(log*n*) 倒是及格了. 总之, 能实现需求的就是合理的做法. 

我看似乎有拿基数排序和桶排序做的. 不过我手里的两本 JavaScript 书比较坑没讲这两个排序, 准备以后照《学习 JavaScript 数据结构与算法.第 2 版》看看...


## 165. Compare Version Numbers

题目描述:

Compare two version numbers *version1* and *version2*.
If <code><i>version1</i> > <i>version2</i></code> return `1`; if <code><i>version1</i> < <i>version2</i></code> return -1; otherwise return `0`.

You may assume that the version strings are non-empty and contain only digits and the `.` character.

The . character does not represent a decimal point and is used to separate number sequences.

For instance, `2.5` is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.

You may assume the default revision number for each level of a version number to be `0`. For example, version number `3.4` has a revision number of `3` and `4` for its first and second level revision number. Its third and fourth level revision number are both 0.

 

**Example 1:**


<pre>
<strong>Input:</strong> <i>version1</i> = "0.1", <i>version2</i> = "1.1"
<strong>Output:</strong> -1
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> <i>version1</i> = "1.0.1", <i>version2</i> = "1"
<strong>Output:</strong> 1
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> <i>version1</i> = "7.5.2.4", <i>version2</i> = "7.5.3"
<strong>Output:</strong> -1
</pre>


**Example 4:**


<pre>
<strong>Input:</strong> <i>version1</i> = "1.01", <i>version2</i> = "1.001"
<strong>Output:</strong> 0
<strong>Explanation:</strong> Ignoring leading zeroes, both “01” and “001" represent the same number “1”
</pre>


**Example 5:**


<pre>
<strong>Input:</strong> <i>version1</i> = "1.0", <i>version2</i> = "1.0.0"
<strong>Output:</strong> 0
<strong>Explanation:</strong> The first version number does not have a third level revision number, which means its third level revision number is default to "0"
</pre>


**Note:**


1. Version strings are composed of numeric strings separated by dots `.` and this numeric strings **may** have leading zeroes.
2. Version strings do not start or end with dots, and they will not be two consecutive dots.
 

解答: 

```php
class Solution 
{

    /**
     * @param String $version1
     * @param String $version2
     * @return Integer
     */
    function compareVersion($version1, $version2) 
    {
        $v1_pieces = [];
        $v2_pieces = [];
        $v1_pieces = explode('.', $version1);
        $v2_pieces = explode('.', $version2);
        $v1pieces_count = count($v1_pieces);
        $v2pieces_count = count($v2_pieces);
        $longer_length = max($v1pieces_count, $v2pieces_count);
        for ($i = 0; $i < $longer_length; $i++) {
            $v1_piece = ($i < $v1pieces_count) ? intval($v1_pieces[$i]) : 0;
            $v2_piece = ($i < $v2pieces_count) ? intval($v2_pieces[$i]) : 0;
            if ($v1_piece < $v2_piece) {
                return -1;
            } elseif ($v1_piece > $v2_piece) {
                return 1;
            }
        }
        return 0;
    }
}
```

效果:

> 执行用时: 8 ms, 在所有 PHP 提交中击败了 85.71% 的用户
> 
> 内存消耗: 14.7 MB, 在所有 PHP 提交中击败了 100.00% 的用户


## 167. Two Sum II - Input array is sorted

题目描述:

Given an array of integers that is already ***sorted in ascending order***, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.

**Note:**

* Your returned answers (both index1 and index2) are not zero-based.
* You may assume that each input would have exactly one solution and you may not use the same element twice.


**Example:**


<pre>
<strong>Input:</strong> numbers = [2,7,11,15], target = 9
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $numbers
     * @param Integer $target
     * @return Integer[]
     */
    function twoSum($numbers, $target) 
    {
        $count = count($numbers);
        for ($i = 0; $i < $count - 1; $i++) {
            if (in_array($target - $numbers[$i], $numbers)) {
                return [array_search($numbers[$i], $numbers) + 1, $count - array_search($target - $numbers[$i], array_reverse($numbers))];
            }
        }
        
    }
}
```

效果:

> 执行用时 : 504 ms, 在所有 PHP 提交中击败了 19.23% 的用户
> 
> 内存消耗 : 16.5 MB, 在所有 PHP 提交中击败了 90.00% 的用户


自己懒得做的交给库函数就行了. “you may not use the same element twice”的意思是比如像 `numbers = [0, 0, 1, 1, 2, 2, 2, 3, 4, 5]`, `target = 4` 这种的, 你不能返回 `[5, 5]`, 而是起码该返回个 `[5, 6]` 或 `[5, 7]` 之类的.

## 168. Excel Sheet Column Title

题目描述:

Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:


<pre>
    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
    ...
</pre>


**Example 1:**


<pre>
<strong>Input:</strong> 1
<strong>Output:</strong> "A"
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> 28
<strong>Output:</strong> "AB"
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> 701
<strong>Output:</strong> "ZY"
</pre>



解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @return String
     */
    function convertToTitle($n) 
    {
        $columnTitle = '';
        $remainder = 0;
        $charArray = ['Z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y'];
        while ($n > 0) {
            $remainder = $n % 26;
            $columnTitle = $charArray[$remainder] . $columnTitle;
            $n = floor(($n - 1) / 26);
        }
        return $columnTitle;
    }
}
```

效果:

> 执行用时: 12 ms, 在所有 PHP 提交中击败了 73.68% 的用户
> 
> 内存消耗: 14.7 MB, 在所有 PHP 提交中击败了 83.33% 的用户

171 题的反问题.


## 169. Majority Element

题目描述:


Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.

You may assume that the array is non-empty and the majority element always exist in the array.

**Example 1:**

<pre>
<strong>Input:</strong> [3,2,3]
<strong>Output:</strong> 3
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> [2,2,1,1,1,2,2]
<strong>Output:</strong> 2 
</pre>

解答 1:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function majorityElement($nums) 
    {
        $baseline = floor(count($nums) / 2);
        $occurrenceArray = [];
        $occurrenceArray = array_count_values($nums);
        foreach ($occurrenceArray as $key => $value) {
            if ($value > $baseline) {
                return $key;
            }
        }
    }
}
```

效果 1:

> 执行用时: 64 ms, 在 Majority Element 的 PHP 提交中击败了 99.62% 的用户
> 
> 内存消耗: 20.3 MB, 在 Majority Element 的 PHP 提交中击败了 85.37% 的用户


解答 2:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function majorityElement($nums) 
    {
        $count_array = array_count_values($nums);
        return array_search(max($count_array), $count_array);
    }
}
```

效果 2:


> 执行用时: 48 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 20.7 MB, 在所有 PHP 提交中击败了 6.71% 的用户


解答 2 是在写完解答 1 的三个月之后写的, 貌似比之前的要优雅😂我看有的人找完信息之后排序一下取最大值, 这是什么鬼😂直接拿 `array_keys()` 找不就完事儿了么...

之所以写解答 2, 是因为题里说了数组中一定存在主元, 那就直接取最大呗, 反正你也不可能俩大于一半频率的元素加起来频率还是 1.

内存也就那么回事儿, 大家都差不多.

## 171. Excel Sheet Column Number

题目描述:

Given a column title as appear in an Excel sheet, return its corresponding column number.

For example:


<pre>
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
</pre>


    
**Example 1:**



<pre>
<strong>Input:</strong> "A"
<strong>Output:</strong> 1
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> "AB"
<strong>Output:</strong> 28
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> "ZY"
<strong>Output:</strong> 701
</pre>

解答:

```php
class Solution 
{

    /**
     * @param String $str
     * @return Integer
     */
    function titleToNumber($str) 
    {
        $len = strlen($str);
        $charArr = str_split($str);
        $number = 0;
        while ($len) {
            $len -= 1;
            $number += (ord(array_shift($charArr)) - ord('A') + 1) * (26 ** $len);
        }
        return $number;
        
    }
}
```


效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


二十六进制转十进制.

> “如果原先你们跟着我在现场的话，我应该能当着你们面骂一天”
> 
> “现在想不起来那么多事儿，不过骂一上午还是没问题的”

说到这个 Excel 表格列号转数值序数的事儿, 关于代码我想说的其实没多少, 主要还是让我想起以前弄畐国**云**运维平台的日子. 当时弄平台的时候和 Excel 表格打交道比较多, 真是美好回忆啊. “前端AI摄像机做人数统计，配合环境和历史数据+AI动态调节控制风阀，水阀开合角度大小，和灯光明亮度的AI BA系统即将上线。”申帝指点江山时言必 AI 大数据**云**计算, 说得畐国已经成功比肩花厂似的, 让我想起我后来看到的一篇文章: [网红送餐无人车被指用人冒充AI始末：没有人工，就没有智能](https://mp.weixin.qq.com/s/heZi9t4_burQiamao8fXzw). 每弄一个项目, 要做的表格就一堆. 先不说别的, 就每个项目光设备列表的表, 表头字段那一排能从 A 给你排到 AZ! 还有什么交换机端口的表, 数量和填表的复杂程度也能让人怀疑人生, 分不清到底是你在平台上管交换机呢, 还是交换机通过平台控制你. 当然这个段子的主题是在讨论平台, 所以就不讨论交换机配置那会儿还是好用的配完以后拿到现场插上电没反应或者是楼上楼下一片设备都掉线一查发现是汇聚层交换机死机之类的硬件问题了. 本来就得好几个人弄材料和找好几个人要材料, 还有些时候我自己也去弄材料, 我一个人又得同时管好几个项目的平台录入, 到我这个终端整理所有数据这块儿可想而知快不了, 何况有的人事儿多的时候数据得拖好几天才给而且也没给全, 甚至有的数据弄到后面发现就是错的. 不说在平台上建立信息框架上传到云平台之类的杂七杂八的事儿, 也不说在运维平台范围之外在单位要干的事儿, 别忘了这个 Excel 表里的数据只是应用层面的数据, 底层承担采集监测的脚本也是得我亲自写, 不知道各位旁友见过 5000 行的脚本没, 我是见过, 因为我写过啊! 现在 `vi` 然后 `set nu` 或是 `less -N` 看的不到 2000 行的什么 `.ini` 那都是小意思. 然后晚上七八点开会就被说这点儿活怎么还没干完高中生都能干, 通宵赶完脚本第二天下午三四点回来开会被告知别以为我不知道你在现场干什么. 顺便一提晚上七八点这个时间不管是干活还是开会都没有任何说法, 问就是大家的努力领导都看在眼里年底会有说法. 网络拓扑图从能偏将 AutoCAD 画转到我拿 Visio 画, 最后再到韦画师拿 PS + AI 画; 楼层平面图从能偏将 AutoCAD 清图转 SVG, 到申帝指定几个人给韦画师讲了好几遍图纸上机房强电井弱电井布局我最后又坐在画师旁边儿亲自讲了一遍再让韦画师画. 至于为什么我要亲自讲这最后一遍, 是因为我发现前几次画师听完讲解出的图内容总是有问题, 不是漏画就是画错, 而每个机房电井我全都是要用往上面落设备的啊! 每次出问题我前面都白干了然后我就得让画师调整啊! 折腾了一遍又一遍, 厉害, 精雕细琢的高大上品质. 非要拿什么话来表达对这种行为的肯定那就是:“这种否定之否定的过程, 从内容上看, 是自己动态调整自己、自己长期完善自己的过程; 从形式上看, 是螺旋式上升或波浪式前进, 方向是前进上升的, 道路是迂回曲折的, 是前进性与曲折性的统一.”关于这个平台, 我在畐国的最后几天有一天晚上和日尚书去大道这个模板项目处理问题(服务器开不开机擦擦内存条能解决的那种), 弄好以后请日尚书吃了顿饭感谢他对我的教导的时候, 日尚书跟我讲了一下他对软件工程的理解和经验, 大概是谈到原型开发的时候, 很蛋疼地问我你觉得这个平台外包他们写得怎么样; 再早之前有天晚上公司代表大会上申帝说等以后弄好了每天早上晚上昊偏将还有我得盯着这套系统, 也是一语点出了运维二十四小时随时待命的本质, 申帝果然具有丰富的项目经验. 不才以为这么高端的平台日后肯定能在畐国的上市布局中发挥出非比寻常的作用, 可惜敝人三尺高中生一介废物才疏学浅能力有限是看不到了. FUCK Scdiler as well as 申帝 and 串相 THREE THOUSAND.


## 172. Factorial Trailing Zeroes


题目描述:

Given an integer *n*, return the number of trailing zeroes in *n*!.

**Example 1:**


<pre>
<strong>Input:</strong> 3
<strong>Output:</strong> 0
<strong>Explanation:</strong> 3! = 6, no trailing zero.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> 5
<strong>Output:</strong> 1
<strong>Explanation:</strong> 5! = 120, one trailing zero.
</pre>


**Note:** Your solution should be in logarithmic time complexity.


解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @return Integer
     */
    function trailingZeroes($n) 
    {
        $zero_count = 0;
        while (floor($n / 5) > 0) {
            $zero_count += floor($n / 5);
            $n = floor($n / 5);
        }
        return $zero_count;
    }
}
```


效果:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 80.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


算是个比较基本的题目了.


## 179. Largest Number


题目描述:

Given a list of non negative integers, arrange them such that they form the largest number.

**Example 1:**


<pre>
<strong>Input:</strong> [10,2]
<strong>Output:</strong> "210"
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> [3,30,34,5,9]
<strong>Output:</strong> "9534330"
</pre>


**Note:** The result may be very large, so you need to return a string instead of an integer.


解答:

```php
class Solution 
{
    /**
     * @param Integer[] $nums
     * @return String
     */
    function largestNumber($nums) 
    {
        if (max($nums) === 0) {
            return '0';
        }
        array_map($toString = function ($num) {
            return strval($num);
        }, $nums);
        usort($nums, $comparator = function ($str1, $str2) {
            return -strcmp($str1 . $str2, $str2 . $str1); 
        });
        return implode('', $nums);
    }
}
```


效果:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.5 MB, 在所有 PHP 提交中击败了 100.00% 的用户


用一下闭包. 这里需要实现自己的比较两个字符串元素不同顺序拼接后的大小的排序器 (Objective-C 里的说法, 拿来引用一下). 如果用 `rsort` 函数再配个 `SORT_STRING` 的 flag 是不行的. 比如 `30` 和 `3` 俩比是 `30` 排在前面, 但是实际上我们需要的是`3`排在前面.

注意题目里开头就说了给的数都是非负的, 所以需要考虑如果这堆整数都是 `0` 的情形, 如果拼出一串零那就不对了...

## 186. Reverse Words in a String II  (上锁题目, 需要氪会员)


题目描述:

Given an input string , reverse the string word by word. 

**Example:**

<pre>
<strong>Input:</strong>  ["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]
<strong>Output:</strong> ["b","l","u","e"," ","i","s"," ","s","k","y"," ","t","h","e"]
</pre>


**Note:** 

* A word is defined as a sequence of non-space characters.
* The input string does not contain leading or trailing spaces.
> * The words are always separated by a single space.


**Follow up:** Could you do it in-place without allocating extra space?


## 189. Rotate Array

题目描述:


Given an array, rotate the array to the right by *k* steps, where *k* is non-negative.

**Example 1:**


<pre>
<strong>Input:</strong> [1,2,3,4,5,6,7] and <em>k</em> = 3
<strong>Output:</strong> [5,6,7,1,2,3,4]
<strong>Explanation:</strong>
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> [-1,-100,3,99] and <em>k</em> = 2
<strong>Output:</strong> [3,99,-1,-100]
<strong>Explanation:</strong> 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
</pre>



Note:

* Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
* Could you do it in-place with O(1) extra space?



解答1:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return NULL
     */
    function rotate(&$nums, $k) 
    {
        while ($k > 0) {
            // PHP是最好的语言!
            array_unshift($nums, array_pop($nums));
            $k--;
        }
    }
}
```


效果1:

> 执行用时 : 2072 ms, 在所有 PHP 提交中击败了 16.15% 的用户
> 
> 内存消耗 : 15.7 MB, 在所有 PHP 提交中击败了 100.00% 的用户


解答2：

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return NULL
     */
    function rotate(&$nums, $k) 
    {
        $temp = [];
        $count = count($nums);
        for ($i = 0; $i < $count; $i++) {
            $temp[($i + $k) % $count] = $nums[$i];
        }
        for ($i = 0; $i < $count; $i++) {
            $nums[$i] = $temp[$i];
        }
    }
}
```

效果2:

> 执行用时 : 20 ms, 在所有 PHP 提交中击败了 95.38% 的用户
> 
> 内存消耗 : 17.1 MB, 在所有 PHP 提交中击败了 6.75% 的用户


## 190. Reverse Bits (无 PHP 提交 OJ)


题目描述:


Reverse bits of a given 32 bits unsigned integer.

 

**Example 1:**


<pre>
<strong>Input:</strong> 00000010100101000001111010011100
<strong>Output:</strong> 00111001011110000010100101000000
<strong>Explanation:</strong> The input binary string <strong>00000010100101000001111010011100</strong> represents the unsigned integer 43261596, so return 964176192 which its binary representation is <strong>00111001011110000010100101000000</strong>.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> 11111111111111111111111111111101
<strong>Output:</strong> 10111111111111111111111111111111
<strong>Explanation:</strong> The input binary string <strong>11111111111111111111111111111101</strong> represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is <strong>10101111110010110010011101101001</strong>.
</pre>
 

**Note:**

* Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
* In Java, the compiler represents the signed integers using [2's complement](https://en.wikipedia.org/wiki/Two%27s_complement) notation. Therefore, in **Example 2** above the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.
 

Follow up:

If this function is called many times, how would you optimize it?



解答 (Java 8 版):


```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        return Integer.reverse(n);
    }
}
```


效果: 


> 执行用时 : 2 ms, 在所有 Java 提交中击败了 98.62% 的用户
> 
> 内存消耗 : 30.1 MB, 在所有 Java 提交中击败了 5.27% 的用户


翻翻文档工具, 搜搜 `reverse`, 看哪个语言的 `reverse` 版本你会用就完事儿了...


## 191. Number of 1 Bits (无 PHP 提交 OJ)


题目描述:

Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the [Hamming weight](https://en.wikipedia.org/wiki/Hamming_weight)).

 

**Example 1:**

<pre>
Input: 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
</pre>


**Example 2:**


<pre>
Input: 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
</pre>


**Example 3:**


<pre>
Input: 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
</pre> 

**Note:**



* Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
* In Java, the compiler represents the signed integers using [2's complement](https://en.wikipedia.org/wiki/Two%27s_complement) notation. Therefore, in **Example 3** above the input represents the signed integer -3.
 

**Follow up:**

If this function is called many times, how would you optimize it?


解答(Python 2版):

```python
class Solution(object):
    def hammingWeight(self, n):
        """
        :type n: int
        :rtype: int
        """
        return bin(n).count('1')
```

效果:

> 执行用时 : 12 ms, 在所有 Python 提交中击败了 99.52% 的用户
> 
> 内存消耗 : 11.7 MB, 在所有 Python 提交中击败了 32.54% 的用户



像这种统计数数的方法名一般是 `count`...

## 192. Word Frequency(无PHP提交OJ, 专门Bash提交的)


题目描述:


Write a bash script to calculate the frequency of each word in a text file `words.txt`.

For simplicity sake, you may assume:

* `words.txt` contains only lowercase characters and space `' '` characters.
* Each word must consist of lowercase characters only.
* Words are separated by one or more whitespace characters.


**Example:**

Assume that **words.txt** has the following content:


<pre>
the day is sunny the the
the sunny is is
</pre>

Your script should output the following, sorted by descending frequency:


<pre>
the 4
is 3
sunny 2
day 1
</pre>


**Note:**

* Don't worry about handling ties, it is guaranteed that each word's frequency count is unique.
* Could you write it in one-line using [Unix pipes](http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-4.html)?


Bash编程在线文档教程参考: [BASH Programming - Introduction HOW-TOby Mike G mikkey at dynamo.com.ar](http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html#toc4)




## 195. Tenth Line(无PHP提交OJ, 专门Bash提交的)


题目描述:

Given a text file `file.txt`, print just the 10th line of the file.

**Example:**

Assume that `file.txt` has the following content:

<pre>
Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
</pre>


Your script should output the tenth line, which is:


<pre>
Line 10
</pre>


**Note:**


1. If the file contains less than 10 lines, what should you output?
2. There's at least three different solutions. Try to explore all possibilities.


## 201. Bitwise AND of Numbers Range


题目描述:


Given a range `[$left, $right]` where `0 <= $left <= $right <= 2147483647`, return the bitwise AND of all numbers in this range, inclusive.

**Example 1:**


<pre>
Input: [5,7]
Output: 4
</pre>


**Example 2:**


<pre>
Input: [0,1]
Output: 0
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer $left
     * @param Integer $right
     * @return Integer
     */
    function rangeBitwiseAnd($left, $right) 
    {
        $result = 0;
        $offset = 0;
        // 说白了就是看范围内数的二进制表示同样位数下, 左起相同的部分.
        while ($left != $right) {
            // 左边界和右边界不相等的时候, 肯定会包含奇数(二进制末位为1)和偶数(二进制末位为0).
            // 这时候末位按位与的结果一定会是0, 于是右移一位, 看接下来的部分. 同时计算偏移量.
            $left >>= 1;
            $right >>= 1;
            $offset++;
        }
        return $left << $offset;
    }
}
```


效果:

> 执行用时 : 24 ms, 在所有PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有PHP提交中击败了 75.00% 的用户


## 204. Count Primes

题目描述:


Count the number of prime numbers less than a non-negative number, ***limit***.

**Example:**


<pre>
<strong>Input:</strong> 10
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
</pre>


解答1:


```php
class Solution 
{

    /**
     * @param Integer $limit
     * @return Integer
     */
    function countPrimes($limit)
    {
        if ($limit <= 2) {
            return 0;
        }
        $isPrimeArray = array_fill(2, $limit - 2, true);
        for ($i = 2; $i < $limit; $i++) {
            if ($isPrimeArray[$i]) {
                for ($j = $i; $i * $j < $limit; $j++) {
                    $isPrimeArray[$i * $j] = false;
                }
            }
        }
        // boolean 类型可以直接求和, 用吧.
        return array_sum($isPrimeArray);
    }
}
```


效果1:

> 执行用时 : 516 ms, 在所有 PHP 提交中击败了 71.79% 的用户
> 
> 内存消耗 : 61.5 MB, 在所有 PHP 提交中击败了 73.33% 的用户

埃拉托色尼筛法, 这个应该是一般数学的人关于筛法最初的印象. 相传筛法是陈景润做哥德巴赫猜想的 1 + 2 的情形的时候的主要工具. 这个做法用的是 Robert Sedgewick 爷爷在 Algorithms in C, PARTS 1–4 Fundamentals, data structures, sorting, searching, THIRD EDITION 这本书里的代码.

大学没开数论所以不了解相关数论工具也没啥丢人的. 晚上回家翻翻二潘的数论书看有没有写这个的.

筛法好像不止埃拉托色尼这种, 貌似还有欧拉版的、和"My brain is open."的Paul Erdös合作过的Selberg版的...

埃拉托色尼筛法的时间复杂度据说是 O(*n*loglog*n*), 不过也是得查查为什么...对于我而言确实不是那么显然的, 对素数的双log那部分结论没印象.


改进版本:


```php
class Solution 
{

    /**
     * @param Integer $limit
     * @return Integer
     */
    function countPrimes($limit)
    {
        if ($limit <= 2) {
            return 0;
        }
        $isPrimeArray = array_fill(2, $limit - 2, true);
        for ($i = 2; $i < $limit; $i++) {
            if ($isPrimeArray[$i]) {
                for ($j = $i * $i; $j < $limit; $j += $i) {
                    $isPrimeArray[$j] = false;
                }
            }
        }
        return array_sum($isPrimeArray);
    }
}
```


效果:

> 执行用时 : 444 ms, 在所有 PHP 提交中击败了 89.74% 的用户
> 
> 内存消耗 : 61.5 MB, 在所有 PHP 提交中击败了 73.33% 的用户


解答2(欧拉筛):


```php
class Solution 
{

    /**
     * @param Integer $limit
     * @return Integer
     */
    function countPrimes($limit)
    {
        if ($limit <= 2) {
            return 0;
        }
        $isPrimeArray = array_fill(2, $limit - 2, true); // 记录某个位置是否为素数.
        $primes = []; // 保存已找到的素数.
        $primeCount = 0;
        for ($i = 2; $i < $limit; $i++) {
            if ($isPrimeArray[$i]) {
                $primeCount++;
                $primes[$primeCount] = $i;
            }
            for ($j = 1; $j <= $primeCount && $i * $primes[$j] < $limit; $j++) {
                $isPrimeArray[$primes[$j] * $i] = false;
                if ($i % $primes[$j] == 0) {
                    break;
                }
            }
        }
        return count($primes);
    }
}
```


效果:

> 执行用时 : 436 ms, 在所有 PHP 提交中击败了 89.74% 的用户
> 
> 内存消耗 : 66.9 MB, 在所有 PHP 提交中击败了 46.67% 的用户


关于埃拉托色尼筛法的介绍, 可见:

![埃拉托色尼筛过程.png](https://i.loli.net/2019/07/30/5d4000f16422816455.png)


关于欧拉筛的介绍, 可见:

![欧拉筛.png](https://i.loli.net/2019/07/31/5d40e68376f9853070.png)

此外, 在潘承洞 + 潘承彪的《初等数论》第三版第一章的习题中讲了另外一个方法, 有兴趣的旁友可以试试.

## 205. Isomorphic Strings

Given two strings <strong><em>s</em></strong> and <strong><em>t</em></strong>, determine if they are isomorphic.

Two strings are isomorphic if the characters in <strong><em>s</em></strong> can be replaced to get <strong><em>t</em></strong>.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

**Example 1:**



<pre>
<strong>Input:</strong> <strong><em>s</em></strong> = "egg", <strong><em>t</em></strong> = "add"
<strong>Output:</strong> true
</pre>



**Example 2:**


<pre>
<strong>Input:</strong> <strong><em>s</em></strong> = "foo", <strong><em>t</em></strong> = "bar"
<strong>Output:</strong> false
</pre>



**Example 3:**

<pre>
<strong>Input:</strong> <strong><em>s</em></strong> = "paper", <strong><em>t</em></strong> = "title"
<strong>Output:</strong> true
</pre>

**Note:**<br/>
You may assume both <strong><em>s</em></strong> and <strong><em>t</em></strong> have the same length.


解答:

```php
class Solution 
{

    /**
     * @param String $s
     * @param String $t
     * @return Boolean
     */
    function isIsomorphic($s, $t) 
    {
        $strlen = strlen($s);
        $s_char_array = str_split($s);
        $t_char_array = str_split($t);
        $dictionary = array_unique(array_combine($s_char_array, $t_char_array));
        for ($i = 0; $i < $strlen; $i++) {
            if ($dictionary[$s[$i]] !== $t[$i]) {
                return false;
            }
        }
        return true;
    }
}
```


效果:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 19.6 MB, 在所有 PHP 提交中击败了 6.25% 的用户


用`array_combine()`函数建立一个映射关系, 然后根据这个映射关系来检查即可.


## 215. Kth Largest Element in an Array

题目描述:

Find the **k**th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

**Example 1:**

<pre>
Input: [3,2,1,5,6,4] and k = 2
Output: 5
</pre>

**Example 2:**

<pre>
Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
</pre>

**Note:** 

You may assume k is always valid, 1 ≤ k ≤ array's length.

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer
     */
    function findKthLargest($nums, $k) 
    {
        rsort($nums, SORT_NUMERIC);
        return $nums[$k - 1];
    }
}
```

效果:

> 执行用时 : 24 ms, 在Kth Largest Element in an Array的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 15.8 MB, 在Kth Largest Element in an Array的PHP提交中击败了 55.17% 的用户


该调库函数就调, 不要重复造轮子.

## 217. Contains Duplicate


题目描述:


Given an array of integers, find if the array contains any duplicates.

Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.

**Example 1:**

<pre>
Input: [1,2,3,1]
Output: true
</pre>


**Example 2:**


<pre>
Input: [1,2,3,4]
Output: false
</pre>


**Example 3:**


<pre>
Input: [1,1,1,3,3,4,3,2,4,2]
Output: true
</pre>


解答1:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Boolean
     */
    function containsDuplicate($nums) 
    {
        $frequency_array = array_count_values($nums);
        foreach ($frequency_array as $key => $value) {
            if ($value > 1) {
                return true;
            }
        }
        return false;
    }
}
```

效果1:

> 执行用时 : 80 ms, 在所有PHP提交中击败了 60.00% 的用户
> 
> 内存消耗 : 21 MB, 在所有PHP提交中击败了 68.63% 的用户


解答2:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Boolean
     */
    function containsDuplicate($nums) 
    {
        $input_count = count($nums);
        // PHP是最好的语言!
        $unique_count = count(array_unique($nums));
        return ($input_count > $unique_count);
    }
}
```


效果2:

> 执行用时 : 52 ms, 在所有PHP提交中击败了 96.00% 的用户
> 
> 内存消耗 : 22.6 MB, 在所有PHP提交中击败了 16.67% 的用户

## 229. Majority Element II

题目描述:

Given an integer array of size *n*, find all elements that appear more than `⌊ n/3 ⌋` times.

**Note:** The algorithm should run in linear time and in O(1) space.

**Example 1:**


<pre>
<strong>Input:</strong> [3,2,3]
<strong>Output:</strong> [3]
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> [1,1,1,3,3,2,2,2]
<strong>Output:</strong> [1,2]
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function majorityElement($nums) 
    {
        $baseline = floor(count($nums) / 3);
        $result = [];
        // PHP是最好的语言!
        $occurrenceArray = array_count_values($nums);
        foreach ($occurrenceArray as $key => $value) {
            if ($value > $baseline) {
                $result[] = $key;
            }
        }
        return $result;
    }
}
```

效果:

> 执行用时 : 32 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 18.9 MB, 在所有 PHP 提交中击败了 18.18% 的用户




## 231. Power of Two

题目描述:

Given an integer, write a function to determine if it is a power of two.

**Example 1:**

```
Input: 1
Output: true 
Explanation: 2 ** 0 = 1
```

**Example 2:**

```
Input: 16
Output: true
Explanation: 2 ** 4 = 16
```

**Example 3:**

```
Input: 218
Output: false
```

解答1:

```php 
class Solution 
{

    /**
     * @param Integer $n
     * @return Boolean
     */
    function isPowerOfTwo($n) 
    {
        return ($n > 0) && (!($n & ($n - 1)));
    }
}
```


效果1:

> 执行用时 : 4 ms, 在Power of Two的PHP提交中击败了100.00% 的用户
内存消耗 : 14.9 MB, 在Power of Two的PHP提交中击败了21.21% 的用户

注意观察2的非负整数幂的特性.


解答2:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Boolean
     */
    function isPowerOfTwo($num) 
    {
        return ($num > 0) && preg_match("/^10*$/", decbin($num));
    }
}
```

效果:

> 执行用时 : 4 ms, 在Power of Two的PHP提交中击败了100.00% 的用户
> 
> 内存消耗 : 14.8 MB, 在Power of Two的PHP提交中击败了30.30% 的用户

也是基于性质的一个想法. 参考326题、342题. 正则表达式就不多说了, 这个用到的匹配模式很好理解. 这个基本上对于任何一个不小于2不大于36的整数进制都可以做.


## 238. Product of Array Except Self


题目描述:


Given an array `nums` of *n* integers where *n* > 1,  return an array output such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.

**Example:**


```
Input:  [1,2,3,4]
Output: [24,12,8,6]
```


Note: Please solve it **without division** and in O(*n*).

**Follow up:**


Could you solve it with constant space complexity? (The output array **does not** count as extra space for the purpose of space complexity analysis.)


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function productExceptSelf($nums) 
    {
        $count = count($nums);
        $left_products = array_fill(0, $count, 1);
        for ($i = 1; $i < $count; $i++) {
            $left_products[$i] = $left_products[$i - 1] * $nums[$i - 1];
        }
        $right_products = array_fill(0, $count, 1);
        for ($j = $count - 2; $j >= 0; $j--) {
            $right_products[$j] = $right_products[$j + 1] * $nums[$j + 1];
        }
        $result = array_fill(0, $count, 1);
        for ($k = 0; $k < $count; $k++) {
            $result[$k] *= ($left_products[$k] * $right_products[$k]);
        }
        return $result;
    }
}
```


效果:

> 执行用时 : 40 ms, 在所有PHP提交中击败了 94.74% 的用户
> 
> 内存消耗 : 22.8 MB, 在所有PHP提交中击败了 72.73% 的用户


注意到一个数组中除某个元素以外的乘积等于这个元素左侧所有元素的乘积与这个元素右侧所有元素的乘积的乘积即可. 合适的情况下可以充分节约次数, 比如数组容量较大的时候速度是比`array_product`函数快的.

再就是拿同一数值往数组里填一定数量的时候, `range`函数似乎办不到, 但是`array_fill`函数则可以做到.


## 240. Search a 2D Matrix II



题目描述:

Write an efficient algorithm that searches for a value in an *m* x *n* matrix. This matrix has the following properties:

* Integers in each row are sorted in ascending from left to right.
* Integers in each column are sorted in ascending from top to bottom.


**Example:**

Consider the following matrix:


<pre>
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
</pre>


Given target = `5`, return `true`.

Given target = `20`, return `false`.


解答:

```php
class Solution 
{

    /**
     * @param Integer[][] $matrix
     * @param Integer $target
     * @return Boolean
     */
    function searchMatrix($matrix, $target) 
    {
        $hasFound = false;
        foreach ($matrix as $row) {
            if ($target >= $row[0] && $target <= end($row)) {
                $hasFound = in_array($target, $row);
                if ($hasFound) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

效果:

> 执行用时 : 80 ms, 在所有 PHP 提交中击败了 50.00% 的用户
> 
> 内存消耗 : 21 MB, 在所有 PHP 提交中击败了 100.00% 的用户


暂时没想到什么更artisan and elegant的做法. 也是和74. Search a 2D Matrix的想法差不多, 直接上.


试了一下直接上的做法:

```php
class Solution 
{

    /**
     * @param Integer[][] $matrix
     * @param Integer $target
     * @return Boolean
     */
    function searchMatrix($matrix, $target) 
    {
        foreach ($matrix as $row) {
            if (in_array($target, $row)) {
                return true;
            }
        }
        return false;
    }
}
```


效果:

> 执行用时 : 92 ms, 在所有 PHP 提交中击败了 50.00% 的用户
> 
> 内存消耗 : 20.9 MB, 在所有 PHP 提交中击败了 100.00% 的用户


可见PHP语言开发组水平还是可以滴...看了下[php-src/ext/standard/array.c](https://github.com/php/php-src/blob/PHP-7.2.20/ext/standard/array.c)想找一下`in_array()`的实现, 然后就翻到了`php_search_array()`, 然后就感觉暂时不想看...


## 242. Valid Anagram


题目描述: 

Given two strings *s* and *t* , write a function to determine if *t* is an anagram of *s*.

**Example 1:**


<pre>
<strong>Input:</strong> <em>s</em> = "anagram", <em>t</em> = "nagaram"
<strong>Output:</strong> true
</pre>



**Example 2:**


<pre>
<strong>Input:</strong> <em>s</em> = "rat", <em>t</em> = "car"
<strong>Output:</strong> false
</pre>



**Note:**


You may assume the string contains only lowercase alphabets.

**Follow up:**


What if the inputs contain unicode characters? How would you adapt your solution to such case?


解答:

```php
class Solution 
{

    /**
     * @param String $s
     * @param String $t
     * @return Boolean
     */
    function isAnagram($s, $t) 
    {
        return (count_chars($s, 1) === count_chars($t, 1));
    }
}
```

效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 98.78% 的用户
> 
> 内存消耗 : 14.9 MB, 在所有 PHP 提交中击败了 91.38% 的用户



不要重复造轮子.


## 243. Shortest Word Distance (上锁题目, 需要氪会员)


题目描述:


Given a list of words and two words *word1* and *word2*, return the shortest distance between these two words in the list.

**Example:**


Assume that words = `["practice", "makes", "perfect", "coding", "makes"]`.

<pre>
<strong>Input:</strong> <em>word1</em> = “coding”, <em>word2</em> = “practice”
<strong>Output:</strong> 3
</pre>


<pre>
<strong>Input:</strong> <em>word1</em> = "makes", <em>word2</em> = "coding"
<strong>Output:</strong> 1
</pre>


**Note:**


You may assume that *word1* **does not equal to** *word2*, and *word1* and *word2* are both in the list.


## 246. Strobogrammatic Number (上锁题目, 需要氪会员)

题目描述:

A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).

Write a function to determine if a number is strobogrammatic. The number is represented as a string.

**Example 1:**


```
Input:  "69"
Output: true
```


**Example 2:**


```
Input:  "88"
Output: true
```


**Example 3:**


```
Input:  "962"
Output: false
```


## 247. Strobogrammatic Number II (上锁题目, 需要氪会员)

题目描述:


A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).

Find all strobogrammatic numbers that are of length = n.

**Example:**

```
Input:  n = 2
Output: ["11","69","88","96"]
```


## 248. Strobogrammatic Number III (上锁题目, 需要氪会员)


题目描述:


A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).

Write a function to count the total strobogrammatic numbers that exist in the range of low <= num <= high.

**Example:**


```
Input: low = "50", high = "100"
Output: 3 
Explanation: 69, 88, and 96 are three strobogrammatic numbers.
```


**Note:**


Because the range might be a large number, the low and high numbers are represented as string.


## 249. Group Shifted Strings (上锁题目, 需要氪会员)

题目描述:

Given a string, we can "shift" each of its letter to its successive letter, for example: `"abc" -> "bcd"`. We can keep "shifting" which forms the sequence:


<pre>
"abc" -> "bcd" -> ... -> "xyz"
</pre>



Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.

**Example:**


<pre>
<strong>Input:</strong> ["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"],
<strong>Output:</strong>
[
  ["abc","bcd","xyz"],
  ["az","ba"],
  ["acef"],
  ["a","z"]
]
</pre>


## 256. Paint House (上锁题目, 需要氪会员)

题目描述: 

There are a row of *n* houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by a <code><em>n</em> × <em>3</em></code> cost matrix. For example, `costs[0][0]` is the cost of painting house 0 with color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.

**Note:**


All costs are positive integers.

**Example:**


<pre>
Input: [[17,2,17],[16,16,5],[14,3,19]]
Output: 10
Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue. 
             Minimum cost: 2 + 5 + 3 = 10.
</pre>



## 258. Add Digits

题目描述:

Given a non-negative integer `num`, repeatedly add all its digits until the result has only one digit.

**Example:**

<pre>
Input: 38
Output: 2 
Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. 
             Since 2 has only one digit, return it.
</pre>
             
**Follow up:**
Could you do it without any loop/recursion in O(1) runtime?

解答:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Integer
     */
    function addDigits($num) 
    {
        // 可以避免分支讨论.
        return 1 + ($num - 1) % 9;
    }
}
```

效果:

> 执行用时 : 12 ms, 在Add Digits的PHP提交中击败了100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在Add Digits的PHP提交中击败了95.00% 的用户



小学奥数题既视感.


## 259. 3Sum Smaller (上锁题目, 需要氪会员)


题目描述:

Given an array of *n* integers *nums* and a *target*, find the number of index triplets `i, j, k` with `0 <= i < j < k < n` that satisfy the condition `nums[i] + nums[j] + nums[k] < target`.

**Example:**



<pre>
<strong>Input:</strong> <em>nums</em> = [-2,0,1,3], and <em>target</em> = 2
<strong>Output:</strong> 2 
<strong>Explanation:</strong> Because there are two triplets which sums are less than 2:
             [-2,0,1]
             [-2,0,3]
</pre>             
             
**Follow up:** Could you solve it in *O*(*n*<sup>2</sup>) runtime?


## 260. Single Number III

题目描述:


Given an array of numbers `nums`, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.

**Example:**


<pre>
Input:  [1,2,1,3,2,5]
Output: [3,5]
</pre>


**Note:**

1. The order of the result is not important. So in the above example, `[5, 3]` is also correct.
2. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function singleNumber($nums) 
    {
        // PHP是最好的语言！
        $value_count = array_count_values($nums);
        $result = [];
        foreach ($value_count as $value => $occurrence) {
            if ($occurrence == 1) {
                $result[] = $value;
            }
        }
        return $result;
    }
}
```

效果:

> 执行用时 : 32 ms, 在Single Number III的PHP提交中击败了 92.31% 的用户
> 
> 内存消耗 : 17.1 MB, 在Single Number III的PHP提交中击败了 16.67% 的用户


参考第442题. 也是随便出.

## 263. Ugly Number

题目描述:

Write a program to check whether a given number is an ugly number.

Ugly numbers are **positive numbers** whose prime factors only include `2`, `3`, `5`.

**Example 1:**

<pre>
Input: 6
Output: true
Explanation: 6 = 2 × 3
</pre>

**Example 2:**

<pre>
Input: 8
Output: true
Explanation: 8 = 2 × 2 × 2
</pre>

**Example 3:**

<pre>
Input: 14
Output: false 
Explanation: 14 is not ugly since it includes another prime factor 7.
</pre>

**Note:**

1. `1` is typically treated as an ugly number.
2. Input is within the 32-bit signed integer range: [−2<sup>31</sup> ,  2<sup>31</sup> − 1].


解答:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Boolean
     */
    function isUgly($num) 
    {
        if ($num <= 0) {
            return false;
        }
        while ($num % 5 == 0) {
            $num /= 5;
        }
        while ($num % 3 == 0) {
            $num /= 3;
        }
        while ($num % 2 == 0) {
            $num /= 2;
        }
        return ($num == 1 ? true : false);
    }
}
```

效果:

> 执行用时 : 16 ms, 在Ugly Number的PHP提交中击败了 84.62% 的用户
> 
> 内存消耗 : 14.6 MB, 在Ugly Number的PHP提交中击败了 71.43% 的用户


## 264. Ugly Number II

题目描述:

Write a program to find the `n`-th ugly number.

Ugly numbers are **positive numbers** whose prime factors only include `2`, `3`, `5`. 

**Example:**


<pre>
Input: n = 10
Output: 12
Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
</pre>


**Note:**  


1. `1` is typically treated as an ugly number.
2. `n` **does not exceed 1690**.


解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @return Integer
     */
    function nthUglyNumber($n) 
    {
        $ugly_numbers = array_fill(0, $n, 0); 
        $index_2 = 0; 
        $index_3 = 0; 
        $index_5 = 0; 
        $next_multiple_of_2 = 2; 
        $next_multiple_of_3 = 3; 
        $next_multiple_of_5 = 5; 
        $next_ugly_number = 1; 

        $ugly_numbers[0] = 1; 
        for ($i = 1; $i < $n; $i++) { 
            $next_ugly_number = min($next_multiple_of_2, $next_multiple_of_3, $next_multiple_of_5); 
            $ugly_numbers[$i] = $next_ugly_number; 
            if ($next_ugly_number == $next_multiple_of_2) { 
                $index_2++; 
                $next_multiple_of_2 = $ugly_numbers[$index_2] * 2; 
            } 
            if ($next_ugly_number == $next_multiple_of_3) { 
                $index_3++; 
                $next_multiple_of_3 = $ugly_numbers[$index_3] * 3; 
            } 
            if ($next_ugly_number == $next_multiple_of_5) { 
                $index_5++; 
                $next_multiple_of_5 = $ugly_numbers[$index_5] * 5; 
            } 
        }
        return $next_ugly_number;
    }
}
```

效果:

> 执行用时 : 36 ms, 在Ugly Number II的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在Ugly Number II的PHP提交中击败了 100.00% 的用户


## 266. Palindrome Permutation (上锁题目, 需要氪会员)

Given a string, determine if a permutation of the string could form a palindrome.

**Example 1:**


<pre>
<strong>Input:</strong> "code"
<strong>Output:</strong> false
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> "aab"
<strong>Output:</strong> true
</pre>



**Example 3:**


<pre>
<strong>Input:</strong> "carerac"
<strong>Output:</strong> true
</pre>

## 268. Missing Number


题目描述:


Given an array containing *n* distinct numbers taken from 0, `1, 2, ..., n`, find the one that is missing from the array.

**Example 1:**


<pre>
Input: [3,0,1]
Output: 2
</pre>


**Example 2:**


<pre>
Input: [9,6,4,2,3,5,7,0,1]
Output: 8
</pre>


**Note:**


Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?



解答1:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function missingNumber($nums) 
    {
        $count = count($nums) + 1;
        // PHP是最好的语言!
        return ($count - 1) * $count / 2 - array_sum($nums);
    }
}
```

效果1:

> 执行用时 : 104 ms, 在Missing Number的PHP提交中击败了 53.49% 的用户
> 
> 内存消耗 : 15.9 MB, 在Missing Number的PHP提交中击败了 62.50% 的用户


PHP是不怕`array_sums`结果溢粗的.


解答2:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function missingNumber($nums) 
    {
        $count = count($nums);
        $range = range(0, $count);
        return current(array_diff($range, $nums));
    }
}
```

效果2:


> 执行用时 : 68 ms, 在所有 PHP 提交中击败了 64.00% 的用户
> 
> 内存消耗 : 16.6 MB, 在所有 PHP 提交中击败了 7.81% 的用户


新建数组比较烧内存, 不过这种事儿只要氪金基本上都可以解决.


## 271. Encode and Decode Strings (上锁题目, 需要氪会员)

题目描述:



Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.

Machine 1 (sender) has the function:

```
string encode(vector<string> strs) {
    // ... your code
    return encoded_string;
}
```


Machine 2 (receiver) has the function:

```
vector<string> decode(string s) {
    //... your code
    return strs;
}
```


So Machine 1 does:


```
string encoded_string = encode(strs);
```


and Machine 2 does:


```
vector<string> strs2 = decode(encoded_string);
```


`strs2` in Machine 2 should be the same as `strs` in Machine 1.

Implement the `encode` and `decode` methods.


**Note:**


* The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.
* Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.
* Do not rely on any library method such as `eval` or serialize methods. You should implement your own encode/decode algorithm.


## 274. H-Index

题目描述:

Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.

According to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): "A scientist has index *h* if *h* of his/her *N* papers have **at least** *h* citations each, and the other *N* − *h* papers have **no more than** *h* citations each."


**Example:**


<pre>
<strong>Input</strong>: citations = [3,0,6,1,5]
<strong>Output</strong>: 3 
<strong>Explanation</strong>: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had 
             received 3, 0, 6, 1, 5 citations respectively. 
             Since the researcher has 3 papers with <strong>at least</strong> 3 citations each and the remaining 
             two with <strong>no more than</strong> 3 citations each, her h-index is 3.
</pre>

             
**Note:** If there are several possible values for *h*, the maximum one is taken as the h-index.


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $citations
     * @return Integer
     */
    function hIndex($citations) 
    {
        if (empty($citations)) {
            return 0;
        }
        if (max($citations) === 0) {
            return 0;
        }
        $count = count($citations);
        sort($citations, SORT_NUMERIC);
        for ($i = 0; $i < $count; $i++) {
            if ($citations[$i] >= $count - $i) {
                return $count - $i;
            }
        }
    }
}
```

效果:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 50.00% 的用户
> 
> 内存消耗 : 15 MB, 在所有 PHP 提交中击败了 100.00% 的用户


按照升序排, 这样下一道题也能用.

## 275. H-Index II

题目描述:

Given an array of citations **sorted in ascending order** (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.

According to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): "A scientist has index *h* if *h* of his/her *N* papers have **at least** *h* citations each, and the other *N* − *h* papers have **no more than** *h* citations each."

**Example:**


<pre>
<strong>Input:</strong> citations = [0,1,3,5,6]
<strong>Output:</strong> 3 
<strong>Explanation:</strong> [0,1,3,5,6] means the researcher has 5 papers in total and each of them had 
             received 0, 1, 3, 5, 6 citations respectively. 
             Since the researcher has 3 papers with <strong>at least</strong> 3 citations each and the remaining 
             two with <strong>no more than</strong> 3 citations each, her h-index is 3.
</pre>             


**Note:**

If there are several possible values for *h*, the maximum one is taken as the h-index.

Follow up:

> * This is a follow up problem to 274. H-Index, where `citations` is now guaranteed to be sorted in ascending order.
> * Could you solve it in logarithmic time complexity?



解答:

```php
class Solution 
{

    /**
     * @param Integer[] $citations
     * @return Integer
     */
    function hIndex($citations) 
    {
        if (empty($citations)) {
            return 0;
        }
        if (max($citations) === 0) {
            return 0;
        }
        $count = count($citations);
        for ($i = 0; $i < $count; $i++) {
            if ($citations[$i] >= $count - $i) {
                return $count - $i;
            }
        }
    }
}
```


效果:

> 执行用时 : 64 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 24.2 MB, 在所有 PHP 提交中击败了 100.00% 的用户


同274. 

## 277. Find the Celebrity (上锁题目, 需要氪会员)

题目描述:

Suppose you are at a party with `n` people (labeled from `0` to `n - 1`) and among them, there may exist one celebrity. The definition of a celebrity is that all the other `n - 1` people know him/her but he/she does not know any of them.

Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).

You are given a helper function `bool knows(a, b)` which tells you whether A knows B. Implement a function `int findCelebrity(n)`, your function should minimize the number of calls to `knows`.

**Note:** There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return `-1`.




## 278. First Bad Version


题目描述:

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API `bool isBadVersion(version)` which will return whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

**Example:**


<pre>
Given n = 5, and version = 4 is the first bad version.

call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true

Then 4 is the first bad version. 
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @param Integer $bad
     * @return Integer
     */
    function firstBadVersion($n, $bad) 
    {
        return $bad;
    }
}
```


效果:

> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 85.71% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


题目模板就这么给的, 我有什么办法.


![278-template.png](https://i.loli.net/2019/07/24/5d381d193fb7f66299.png)


## 279. Perfect Squares

题目描述:

Given a positive integer *num*, find the least number of perfect square numbers (for example, `1`, `4`, `9`, `16`, ...) which sum to *num*.

**Example 1:**

<pre>
<strong>Input:</strong> <em>num</em> = 12
<strong>Output:</strong> 3 
<strong>Explanation:</strong> 12 = 4 + 4 + 4.
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> <em>num</em> = 13
<strong>Output:</strong> 2
<strong>Explanation:</strong> 13 = 4 + 9.
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Integer
     */
    function numSquares($num)
    {
        $dp = range(0, $num);
        $dp[0] = 0;
        $dp[1] = 1;
        for ($i = 1; $i <= $num; $i++) {
            for ($j = 1; $j * $j <= $i; $j++) {
                $dp[$i] = min($dp[$i], $dp[$i - $j * $j] + 1);
            }
        }
        return $dp[$num];
    }
}
```

效果:

> 执行用时: 1020 ms, 在所有 PHP 提交中击败了 47.62% 的用户
> 
> 内存消耗: 15.3 MB, 在所有 PHP 提交中击败了 72.73% 的用户

动态规划, 但是比较烧时间, 可能我这个 O(n ** (3/2)) 的时间复杂度有问题...


## 280. Wiggle Sort (上锁题目, 需要氪会员)


题目描述:

Given an unsorted array `nums`, reorder it **in-place** such that `nums[0] <= nums[1] >= nums[2] <= nums[3]...`.

**Example:**


<pre>
<strong>Input:</strong> nums = [3,5,2,1,6,4]
<strong>Output:</strong> One possible answer is [3,5,1,6,2,4]
</pre>


## 283. Move Zeroes

题目描述:

Given an array `nums`, write a function to move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

**Example:**


<pre>
Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
</pre>


**Note:**

1. You must do this **in-place** without making a copy of the array.
2. Minimize the total number of operations.


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return NULL
     */
    function moveZeroes(&$nums) 
    {
        $count = count($nums);
        for ($i = 0; $i < $count; $i++) {
            for ($j = 0; $j < $i; $j++) {
                if ($nums[$j] === 0) {
                    $nums[$j] = $nums[$i];
                    $nums[$i] = 0;
                }
            }
        }
        return $nums;
    }
}
```

效果:

> 执行用时 : 1240 ms, 在所有 PHP 提交中击败了 5.88% 的用户
> 
> 内存消耗 : 16 MB, 在所有 PHP 提交中击败了 37.93% 的用户


注意: 用`usort()`函数是不行的, 因为:

> If two members compare as equal, their relative order in the sorted array is **undefined**.

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return NULL
     */
    function moveZeroes(&$nums) 
    {
        usort($nums, $comparator = function ($num1, $num2) {
            return $num1 == 0 ? 1 : 0;
        });
        return $nums;
    }
}
```

可以用这个用例跑一下:

```php
[-959151711,623836953,209446690,-1950418142,1339915067,-733626417,481171539,-2125997010,-1225423476,1462109565,147434687,-1800073781,-1431212205,-450443973,50097298,753533734,-747189404,-2070885638,0,-1484353894,-340296594,-2133744570,619639811,-1626162038,669689561,0,112220218,502447212,-787793179,0,-726846372,-1611013491,204107194,1605165582,-566891128,2082852116,0,532995238,-1502590712,0,2136989777,-2031153343,371398938,-1907397429,342796391,609166045,-2007448660,-1096076344,-323570318,0,-2082980371,2129956379,-243553361,-1549960929,1502383415,0,-1394618779,694799815,78595689,-1439173023,-1416578800,685225786,-333502212,-1181308536,-380569313,772035354,0,-915266376,663709718,1443496021,-777017729,-883300731,-387828385,1907473488,-725483724,-972961871,-1255712537,383120918,1383877998,1722751914,0,-1156050682,1952527902,-560244497,1304305692,1173974542,-1313227247,-201476579,-298899493,-1828496581,-1724396350,1933643204,1531804925,1728655262,-955565449,0,-69843702,-461760848,268336768,1446130876]
```

会得到你意料之外的结果. 目前暂时没有好的解决办法.


## 287. Find the Duplicate Number

题目描述:

Given an array `nums` containing *n* + 1 integers where each integer is between 1 and *n* (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.

**Example 1:**


<pre>
Input: [1,3,4,2,2]
Output: 2
</pre>


**Example 2:**


<pre>
Input: [3,1,3,4,2]
Output: 3
</pre>


**Note:**

1. You **must not** modify the array (assume the array is read only).
2. You must use only constant, O(1) extra space.
3. Your runtime complexity should be less than O(*n*<sup>2</sup>).
4. There is only one duplicate number in the array, but it could be repeated more than once.

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findDuplicate($nums) 
    {
        // PHP是最好的语言！
        $value_count = array_count_values($nums);
        foreach ($value_count as $value => $occurrence) {
            if ($occurrence >= 2) {
                return $value;
            }
        }
    }
}
```

效果:

> 执行用时 : 28 ms, 在Find the Duplicate Number的PHP提交中击败了 84.62% 的用户
> 
> 内存消耗 : 17.9 MB, 在Find the Duplicate Number的PHP提交中击败了 12.50% 的用户



## 288. Unique Word Abbreviation (上锁题目, 需要氪会员)


An abbreviation of a word follows the form \<first letter\>\<number\>\<last letter\>. Below are some examples of word abbreviations:


<pre>
a) it                      --> it    (no abbreviation)

     1
     ↓
b) d|o|g                   --> d1g

              1    1  1
     1---5----0----5--8
     ↓   ↓    ↓    ↓  ↓    
c) i|nternationalizatio|n  --> i18n

              1
     1---5----0
     ↓   ↓    ↓
d) l|ocalizatio|n          --> l10n
</pre>


Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no *other* word from the dictionary has the same abbreviation.

**Example:**


<pre>
Given dictionary = [ "deer", "door", "cake", "card" ]

isUnique("dear") -> false
isUnique("cart") -> true
isUnique("cane") -> false
isUnique("make") -> true
</pre>


## 290. Word Pattern


题目描述:

Given a `pattern` and a string `str`, find if `str` follows the same pattern.

Here **follow** means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** word in `str`.

**Example 1:**


<pre>
<strong>Input:</strong> pattern = "abba", str = "dog cat cat dog"
<strong>Output:</strong> true
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> pattern = "abba", str = "dog cat cat fish"
<strong>Output:</strong> false
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> pattern = "aaaa", str = "dog cat cat dog"
<strong>Output:</strong> false
</pre>


**Example 4:**


<pre>
<strong>Input:</strong> pattern = "abba", str = "dog dog dog dog"
<strong>Output:</strong> false
</pre>


**Notes:**<br/>
You may assume `pattern` contains only lowercase letters, and `str` contains lowercase letters that may be separated by a single space.

解答:


```php
class Solution 
{

    /**
     * @param String $pattern
     * @param String $str
     * @return Boolean
     */
    function wordPattern($pattern, $str) 
    {
        $strlen = strlen($pattern);
        $pattern_char_array = str_split($pattern);
        $str_word_array = array_filter(explode(' ', $str));
        $dictionary = array_unique(array_combine($pattern_char_array, $str_word_array));
        if ($pattern === "") {
            return false;
        }
        for ($i = 0; $i < $strlen; $i++) {
            if ($dictionary[$pattern_char_array[$i]] !== $str_word_array[$i]) {
                return false;
            }
        }
        return true;
    }
}
```

效果:

> 执行用时 :4 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.7 MB, 在所有 PHP 提交中击败了 83.33% 的用户


这个抄205. Isomorphic Strings就行了, 本质上都是建立映射关系. 注意空模式不能匹配非空单词串.

## 291. Word Pattern II (上锁题目, 需要氪会员)

Given a `pattern` and a string `str`, find if `str` follows the same pattern.

Here **follow** means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** substring in `str`.

**Example 1:**


<pre>
<strong>Input:</strong> pattern = "abab", str = "redblueredblue"
<strong>Output:</strong> true
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> pattern = pattern = "aaaa", str = "asdasdasdasd"
<strong>Output:</strong> true
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> pattern = "aabb", str = "xyzabcxzyabc"
<strong>Output:</strong> false
</pre>


**Notes:**<br/>
You may assume both `pattern` and `str` contains only lowercase letters.

## 299. Bulls and Cows

You are playing the following [Bulls and Cows](https://en.wikipedia.org/wiki/Bulls_and_Cows) game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number.

Write a function to return a hint according to the secret number and friend's guess, use `A` to indicate the bulls and `B` to indicate the cows. 

Please note that both secret number and friend's guess may contain duplicate digits.

**Example 1:**


<pre>
<strong>Input:</strong> secret = "1807", guess = "7810"

<strong>Output:</strong> "1A3B"

<strong>Explanation:</strong> 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> secret = "1123", guess = "0111"

<strong>Output:</strong> "1A1B"

<strong>Explanation:</strong> The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.
</pre>


**Note:** You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.



解答1:

```php
class Solution 
{

    /**
     * @param String $secret
     * @param String $guess
     * @return String
     */
    function getHint($secret, $guess) 
    {
        $secretArray = str_split($secret);
        $guessArray = str_split($guess);
        $bullArray = array_intersect_assoc($secretArray, $guessArray);
        $countOfBulls = count($bullArray);
        $secretRemnant = array_diff_assoc($secretArray, $bullArray);
        $guessRemnant = array_diff_assoc($guessArray, $bullArray);
        $secretRemnantInfo = array_count_values($secretRemnant);
        $guessRemnantInfo = array_count_values($guessRemnant);
        $commonValueArray = array_values(array_intersect(array_unique($secretRemnant), array_unique($guessRemnant)));
        $countOfCows = 0;
        foreach ($commonValueArray as $value) {
            $countOfCows += min($secretRemnantInfo[$value], $guessRemnantInfo[$value]);
        }
        return $countOfBulls . 'A' . $countOfCows . 'B';
    }
}
```


效果1:


> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.8 MB, 在所有 PHP 提交中击败了 100.00% 的用户


解答2:

```php
class Solution 
{

    /**
     * @param String $secret
     * @param String $guess
     * @return String
     */
    function getHint($secret, $guess) 
    {
        $secretArray = str_split($secret);
        $guessArray = str_split($guess);
        $bullArray = array_intersect_assoc($secretArray, $guessArray);
        $countOfBulls = count($bullArray);
        $secretRemnant = array_diff_assoc($secretArray, $bullArray);
        $guessRemnant = array_diff_assoc($guessArray, $bullArray);
        foreach ($secretRemnant as $index => $value) {
            if (!in_array($value,$guessRemnant)) {
                unset($secretRemnant[$index]);
            } else {
                unset($guessRemnant[array_search($value, $guessRemnant)]);
            }
        }
        $countOfCows = count($secretRemnant);
        return $countOfBulls . 'A' . $countOfCows . 'B';
    }
}
```

效果2:


> 执行用时 : 104 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在所有 PHP 提交中击败了 100.00% 的用户


统计相同位置相同值的情况用 `array_intersect_assoc()`. 

注意: 你算 `cow` 元素的个数的时候不能简单地取两个数组的前交和后交的元素个数的 `min`, 因为你用这个 `array_intersect()` 函数的时候, 可能前交的时候第一个数组参数中某一个值的个数比较多, 而后交的时候第一个数组参数(指的是两个数组不改变顺序中的第二个)中另外一个值的个数比较多, 这么比并没有什么卵用. 

还是得 `array_count_values()`, 一个个值去比.


解答1虽然感觉啰嗦了一些, 但是可读性确实还可以. 而且效率比较好.

解答2参考了[官方手册的array_intersect()函数的这篇用户笔记](https://www.php.net/manual/zh/function.array-intersect.php#81000), 此外这篇笔记也是有重数组交的一个讨论: [官方手册的array_intersect()函数的另一篇用户笔记](https://www.php.net/manual/zh/function.array-intersect.php#104063). 以为能有性能提升, 但还是比解答1慢, 估计是 `unset()` 比较烧性能.



## 319. Bulb Switcher


题目描述:


There are *n* bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the *i*-th round, you toggle every *i* bulb. For the *n*-th round, you only toggle the last bulb. Find how many bulbs are on after *n* rounds.

**Example:**


<pre>
Input: 3
Output: 1 
Explanation: 
At first, the three bulbs are [off, off, off].
After first round, the three bulbs are [on, on, on].
After second round, the three bulbs are [on, off, on].
After third round, the three bulbs are [on, off, off]. 

So you should return 1, because there is only one bulb is on.
</pre>

解答:


```php
class Solution 
{

    /**
     * @param Integer $n
     * @return Integer
     */
    function bulbSwitch($n) 
    {
        return floor(sqrt($n));
    }
}
```


效果:

> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 80.00% 的用户
> 
> 内存消耗 : 14.5 MB, 在所有 PHP 提交中击败了 100.00% 的用户


撸题带来的经验, 是永远夺不走的.


## 320. Generalized Abbreviation (上锁题目, 需要氪会员)

题目描述:

Write a function to generate the generalized abbreviations of a word. 

**Note:** The order of the output does not matter.

**Example:**


<pre>
Input: "word"
Output:
["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
</pre>



## 325. Maximum Size Subarray Sum Equals k (上锁题目, 需要氪会员)

题目描述:


Given an array `nums` and a target value *k*, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.

**Note:**



The sum of the entire `nums` array is guaranteed to fit within the 32-bit signed integer range.

**Example 1:**


<pre>
Input: nums = [1, -1, 5, -2, 3], k = 3
Output: 4 
Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.
</pre>



**Example 2:**


<pre>
Input: nums = [-2, -1, 2, 1], k = 1
Output: 2 
Explanation: The subarray [-1, 2] sums to 1 and is the longest.
</pre>



**Follow Up:**


Can you do it in O(*n*) time?


## 326. Power of Three

题目描述:

Given an integer, write a function to determine if it is a power of three.

**Example 1:**

<pre>
Input: 27
Output: true
</pre>

**Example 2:**

<pre>
Input: 0
Output: false
</pre>

**Example 3:**

<pre>
Input: 9
Output: true
</pre>

**Example 4:**

<pre>
Input: 45
Output: false
</pre>

**Follow up:**

Could you do it without using any loop / recursion?


解答:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Boolean
     */
    function isPowerOfThree($num) 
    {
        return ($num > 0) && preg_match("/^10*$/", base_convert(strval($num), 10, 3)); 
    }
}
```

效果:

> 执行用时 : 56 ms, 在Power of Three的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在Power of Three的PHP提交中击败了 22.22% 的用户


## 330. Patching Array

题目描述:

Given a sorted positive integer array *nums* and an integer *n*, add/patch elements to the array such that any number in range `[1, n]` inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.

**Example 1:**


<pre>
Input: <em>nums</em> = [1,3], <em>n</em> = 6
Output: 1 
Explanation:
Combinations of <em>nums</em> are [1], [3], [1,3], which form possible sums of: 1, 3, 4.
Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].
Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].
So we only need 1 patch.
</pre>


**Example 2:**


<pre>
Input: <em>nums</em> = [1,5,10], <em>n</em> = 20
Output: 2
Explanation: The two patches can be [2, 4].
</pre>


**Example 3:**


<pre>
Input: <em>nums</em> = [1,2,2], <em>n</em> = 5
Output: 0
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $n
     * @return Integer
     */
    function minPatches($nums, $n) 
    {
        $miss = 1; // 补充过程中缺失的最小数字.
        $result = 0; 
        $count = count($nums);
        $i = 0;
        while ($miss <= $n) {
            if ($i < $count && $nums[$i] <= $miss) {
                $miss += $nums[$i++];
            } else {
                $miss += $miss;
                $result++;
            }
        }
        return $result;
        
    }
}
```

效果:

> 执行用时 : 20 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.5 MB, 在所有 PHP 提交中击败了 100.00% 的用户


贪心法.


## 338. Counting Bits

题目描述:

Given a non negative integer number num. For every numbers i in the range **0 ≤ i ≤ num** calculate the number of 1's in their binary representation and return them as an array.

**Example 1:**


<pre>
Input: 2
Output: [0,1,1]
</pre>


**Example 2:**


<pre>
Input: 5
Output: [0,1,1,2,1,2]
</pre>


**Follow up:**


* It is very easy to come up with a solution with run time **O(n*sizeof(integer))**. But can you do it in linear time O(n) /possibly in a single pass?
* Space complexity should be **O(n)**.
* Can you do it like a boss? Do it without using any builtin function like **__builtin_popcount** in c++ or in any other language.



解答:

```php
class Solution 
{
    static function get1count($i) 
    {
        if ($i == 0) {
            return 0;
        }
        return ($i % 2 == 0) ? self::get1count($i / 2) : (self::get1count(($i - 1) / 2) + 1);
    }
    /**
     * @param Integer $num
     * @return Integer[]
     */
    function countBits($num) 
    {
        
        $result = [];
        for ($i = 0; $i <= $num; $i++) {
            $result[] = self::get1count($i);
        }
        return $result;
    }
}
```

效果:

> 执行用时 : 144 ms, 在Counting Bits的PHP提交中击败了 44.44% 的用户
> 
> 内存消耗 : 23.3 MB, 在Counting Bits的PHP提交中击败了 100.00% 的用户


把通项公式:

> a<sub>0</sub> = 0, a<sub>2n</sub> = a<sub>n</sub>, a<sub>2n+1</sub> = a<sub>n</sub> + 1. 

实现即可. 注意别把`%`和`/`弄混了.

这个序列有“nonn, easy, core, nice, hear, look, base”的评价, 是个很不错的结果.


## 340. Longest Substring with At Most K Distinct Characters (上锁题目, 需要氪会员)


题目描述:


Given a string, find the length of the longest substring T that contains at most *k* distinct characters.

**Example 1:**


<pre>
Input: s = "eceba", k = 2
Output: 3
Explanation: T is "ece" which its length is 3.
</pre>


**Example 2:**


<pre>
Input: s = "aa", k = 1
Output: 2
Explanation: T is "aa" which its length is 2.
</pre>




## 342. Power of Four

题目描述:

Given an integer (signed 32 bits), write a function to check whether it is a power of 4.

**Example 1:**

<pre>
Input: 16
Output: true
</pre>

**Example 2:**

<pre>
Input: 5
Output: false
</pre>

**Follow up:** Could you solve it without loops/recursion?

解答:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Boolean
     */
    function isPowerOfFour($num) 
    {
        return ($num > 0) && preg_match("/^10*$/", base_convert(strval($num), 10, 4)); 
    }
}
```

效果:

> 执行用时 : 4 ms, 在Power of Four的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在Power of Four的PHP提交中击败了 16.67% 的用户


## 343. Integer Break

题目描述:

Given a positive integer *n*, break it into the sum of **at least** two positive integers and maximize the product of those integers. Return the maximum product you can get.

**Example 1:**


<pre>
Input: 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
</pre>


**Example 2:**


<pre>
Input: 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
</pre>

**Note:** You may assume that *n* is not less than 2 and not larger than 58.

解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @return Integer
     */
    function integerBreak($n) 
    {
        if ($n == 2 || $n == 3) {
            return $n - 1;
        }
        $remainder = $n % 3;
        $quotient = ($n - $remainder) / 3;
        switch ($remainder) {
            case 0: return 3 ** $quotient;
            case 1: return 2 * 2 * 3 ** ($quotient - 1);
            case 2: return 2 * 3 ** $quotient;
        }
    }
}
```


效果:

> 执行用时 : 4 ms, 在Integer Break的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在Integer Break的PHP提交中击败了 27.78% 的用户

也是小学奥数题, 但是没在以前奥数书上找到证明. 另外衷心希望在PHP8里能将Python里的`//`运算加入运算符豪华套餐.

## 344. Reverse String

题目描述:

Write a function that reverses a string. The input string is given as an array of characters `char[]`.

Do not allocate extra space for another array, you must do this by **modifying the input array** in-place with O(1) extra memory.

You may assume all the characters consist of printable ascii characters.

 

**Example 1:**


<pre>
Input: ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]
</pre>

**Example 2:**

<pre>
Input: ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]
</pre>

解答:

```php
class Solution 
{

    /**
     * @param String[] $s
     * @return NULL
     */
    function reverseString(&$s) 
    {
        // PHP是最好的语言!
        // 反转Array就用array_reverse
        // 反转String就用strrev
        return $s = array_reverse($s);
    }
}
```

效果:

> 执行用时 : 76 ms, 在Reverse String的PHP提交中击败了 96.41% 的用户
> 
> 内存消耗 : 35.1 MB, 在Reverse String的PHP提交中击败了 93.62% 的用户

## 345. Reverse Vowels of a String

题目描述:

Write a function that takes a string as input and reverse only the vowels of a string.

**Example 1:**


<pre>
<strong>Input:</strong> "hello"
<strong>Output:</strong> "holle"
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> "leetcode"
<strong>Output:</strong> "leotcede"
</pre>

**Note:**


The vowels does not include the letter "y".


解答: 

```php
class Solution 
{

    /**
     * @param String $str
     * @return String
     */
    function reverseVowels($str) 
    {
        $vowelCollection = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];
        $vowelArray = [];
        $strArray = str_split($str);
        $count = count($strArray);
        for ($i = 0; $i < $count; $i++) {
            if (in_array($strArray[$i], $vowelCollection)) {
                $vowelArray[] = $strArray[$i];
                $strArray[$i] = "";
            }
        }

        for ($i = 0; $i < $count; $i++) {
            if ($strArray[$i] === "") {
                $strArray[$i] = array_pop($vowelArray);
            }
        }
        return implode($strArray);
    }
}
```

效果:

> 执行用时 : 48 ms, 在所有 PHP 提交中击败了 44.44% 的用户
> 
> 内存消耗 : 23.7 MB, 在所有 PHP 提交中击败了 14.29% 的用户


注意`empty()`这个函数是没法把值清空的...而你`unset()`的时候, 会把这个数组的位置也给彻底destroy掉...在第二个for循环的if条件里之前拿`empty()`判断的, 不知为何有问题.

再一个注意元音字母的大小写.

## 347. Top K Frequent Elements

题目描述:

Given a non-empty array of integers, return the ***k*** most frequent elements.

**Example 1:**

<pre>
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
</pre>

**Example 2:**

<pre>
Input: nums = [1], k = 1
Output: [1]
</pre>

**Note:**

* You may assume *k* is always valid, 1 ≤ *k* ≤ number of unique elements.
* Your algorithm's time complexity **must be** better than O(*n* log *n*), where *n* is the array's size.

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @return Integer[]
     */
    function topKFrequent($nums, $k) 
    {
        $occurrenceCounts = [];
        $occurrenceCounts = array_count_values($nums);
        arsort($occurrenceCounts, SORT_NUMERIC);
        return array_slice(array_keys($occurrenceCounts), 0, $k);
    }
}
```

效果:

> 执行用时 : 32 ms, 在Top K Frequent Elements的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 19.7 MB, 在Top K Frequent Elements的PHP提交中击败了 66.67% 的用户


## 349. Intersection of Two Arrays

题目描述:

Given two arrays, write a function to compute their intersection.

**Example 1:**

<pre>
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
</pre>

**Example 2:**

<pre>
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
</pre>

**Note:**

* Each element in the result must be unique.
* The result can be in any order.


解答 1:

```php
class Solution 
{

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Integer[]
     */
    function intersection($nums1, $nums2) 
    {
        // PHP是最好的语言!
        return array_unique(array_intersect($nums1, $nums2));
    }
}


```

效果 1:

> 执行用时: 20 ms, 在所有 PHP 提交中击败了 61.11% 的用户
> 
> 内存消耗: 15 MB, 在所有 PHP 提交中击败了 45.95% 的用户


解答 2:

```php
class Solution 
{

    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Integer[]
     */
    function intersection($nums1, $nums2) 
    {
        // PHP是最好的语言!
        return array_keys(array_flip(array_intersect($nums1, $nums2)));
    }
}
```

效果 2:

> 执行用时: 16 ms, 在所有 PHP 提交中击败了 80.56% 的用户
> 
> 内存消耗: 15.1 MB, 在所有 PHP 提交中击败了 18.92% 的用户
 
都可以吧. 直觉上肯定是第一个做法用的人多一些. 这个是数组取交集去重的问题. 

还有一类问题就是取所有集合中共同元素出现次数的最小值的可取最大值. 这个就比较麻烦了.

## 350. Intersection of Two Arrays II

题目描述:

Given two arrays, write a function to compute their intersection.

**Example 1:**

<pre>
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
</pre>

**Example 2:**

<pre>
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
</pre>

**Note:**

* Each element in the result should appear as many times as it shows in both arrays.
* The result can be in any order.


**Follow up:**

* What if the given array is already sorted? How would you optimize your algorithm?
* What if nums1's size is small compared to nums2's size? Which algorithm is better?
* What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?


解答:

```php
class Solution 
{
    
    /**
     * @param Integer[] $nums1
     * @param Integer[] $nums2
     * @return Integer[]
     */
    function intersect($nums1, $nums2) 
    {
        sort($nums1, SORT_NUMERIC);
        sort($nums2, SORT_NUMERIC);
        $count1 = count($nums1);
        $count2 = count($nums2);
        $i = 0;
        $j = 0;
        $intersection = [];
        while ($i < $count1 && $j < $count2) {
            if ($nums1[$i] < $nums2[$j]) {
                $i++; 
            } elseif ($nums2[$j] < $nums1[$i]) {
                $j++; 
            } else { 
                $intersection[] = $nums2[$j]; 
                $i++; 
                $j++;
            }
        }
        return $intersection;
    }
}
```

效果:

> 执行用时 : 24 ms, 在Intersection of Two Arrays II的PHP提交中击败了 92.08% 的用户
> 
> 内存消耗 : 15.1 MB, 在Intersection of Two Arrays II的PHP提交中击败了 7.14% 的用户


注意仔细阅读一下函数 `array_intersect ( array $array1 , array $array2 [, array $... ] ) : array` 的说明:

**array_intersect()** returns an array containing all the values of **array1** that are present in all the arguments. Note that keys are preserved.


## 351. Android Unlock Patterns (上锁题目, 需要氪会员)

题目描述:

Given an Android **3x3** key lock screen and two integers **m** and **n**, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of **m** keys and maximum **n** keys.

**Rules for a valid pattern:**

1. Each pattern must connect at least **m** keys and at most **n** keys.
2. All the keys must be distinct.
3. If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed.
4. The order of keys used matters.


![android-unlock.png](https://i.loli.net/2019/05/26/5cea20921837949720.png)


**Explanation:**


<pre>
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |
</pre>


**Invalid move:** `4 - 1 - 3 - 6` 
Line 1 - 3 passes through key 2 which had not been selected in the pattern.

**Invalid move:** `4 - 1 - 9 - 2`
Line 1 - 9 passes through key 5 which had not been selected in the pattern.

**Valid move:** `2 - 4 - 1 - 3 - 6`
Line 1 - 3 is valid because it passes through key 2, which had been selected in the pattern

**Valid move:** `6 - 5 - 4 - 1 - 9 - 2`
Line 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.

**Example:**

<pre>
Input: m = 1, n = 1
Output: 9
</pre>


## 357. Count Numbers with Unique Digits

题目描述:

Given a **non-negative** integer n, count all numbers with unique digits, x, where 0 ≤ x < 10<sup>n</sup>.

**Example:**


<pre>
<strong>Input:</strong> 2
<strong>Output:</strong> 91 
<strong>Explanation:</strong> The answer should be the total numbers in the range of 0 ≤ x < 100, 
             excluding 11,22,33,44,55,66,77,88,99
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @return Integer
     */
    function countNumbersWithUniqueDigits($n) 
    {
        switch ($n) {
            case 0: 
                return 1; // 1
            case 1: 
                return 10; // 1 + C(9, 1)
            case 2: 
                return 91; // 10 + C(9, 1) * A(9, 1)
            case 3: 
                return 739; // 91 + C(9, 1) * A(9, 2)
            case 4: 
                return 5275; // 739 + C(9, 1) * A(9, 3)
            case 5: 
                return 32491; // 5275 + C(9, 1) * A(9, 4)
            case 6:
                return 168571; // 32491 + C(9, 1) * A(9, 5)
            case 7:
                return 712891; // 168571 + C(9, 1) * A(9, 6)
            case 8:
                return 2345851; // 712891 + C(9, 1) * A(9, 7)
            case 9:
                return 5611771; // 2345851 + C(9, 1) * A(9, 8)
            default:
                return 8877691; // 5611771 + C(9, 1) * A(9, 9)
        }
    }
}
```

效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


数学做法, 反正是十进制, 又不是十六进制. 就算是十六进制也无所谓, 上命令行里敲个`python3`之后任你敲.

我高中的时候就会这么做了, 不知道别人怎么样. 针对每一**种**位数的情形, 都是应用很正规的先选后排的思路. `default` 里包含了 `case 10` 的情形. 至于 `case 11` 以及往后就不用看了, 根据狄利克雷原理, 11位和以上的十进制数肯定会有重的位...

平时写 `switch` 比较少, 现在看一下PSR-2规范.

> 在PSR-2规范中, `case` 语句 **必须** 相对 `switch` 进行一次缩进，而 `break` 语句以及 `case` 内的其它语句都 **必须** 相对 `case` 进行一次缩进。
> 
> 如果存在非空的 `case` 直穿语句，主体里 **必须** 有类似 `// no break` 的注释。


像这种直接一条语句 `return` 或 `break` 之类的我就不加大括弧了, 否则照我一贯的习惯还是会加上大括弧的. 不过 `for`、`foreach`、`while` 和 `if`我是一定会加的. 

## 360. Sort Transformed Array (上锁题目, 需要氪会员)

题目描述:

Given a **sorted** array of integers *nums* and integer values *a*, *b* and *c*. Apply a quadratic function of the form f(x) = *ax*<sup>2</sup> + *bx* + *c* to each element *x* in the array.

The returned array must be in **sorted order**.

Expected time complexity: **O(n)**

**Example 1:**


<pre>
<strong>Input:</strong> nums = [-4,-2,2,4], a = 1, b = 3, c = 5
<strong>Output:</strong> [3,9,15,33]
</pre>



**Example 2:**

<pre>
<strong>Input:</strong> nums = [-4,-2,2,4], a = -1, b = 3, c = 5
<strong>Output:</strong> [-23,-5,1,7]
</pre>


应该也没什么难度, `array_map()` 再 `sort()` 一下. 时间复杂度就一边儿呆着去吧.

## 365. Water and Jug Problem


题目描述:

You are given two jugs with capacities *x* and *y* litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs.

If *z* liters of water is measurable, you must have z liters of water contained within **one or both buckets** by the end.

Operations allowed:

* Fill any of the jugs completely with water.
* Empty any of the jugs.
* Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.

**Example 1:** (From the famous "<em><a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg">Die Hard</a></em>" example)

<pre>
Input: x = 3, y = 5, z = 4
Output: True
</pre>


**Example 2:**


<pre>
Input: x = 2, y = 6, z = 5
Output: False
</pre>


解答:

```php
class Solution 
{
    public static function gcd($a, $b)
    {
        // 平凡情形
        if ($a == 0) {
            return $b;
        }
        if ($b == 0) {
            return $a;
        }
        // 递归情形
        return self::gcd($b, $a % $b);
    }
    
    /**
     * @param Integer $x
     * @param Integer $y
     * @param Integer $z
     * @return Boolean
     */
    function canMeasureWater($x, $y, $z) 
    {
        if ($x + $y < $z) {
            return false;
        }
        if ($x == $z || $y == $z || $x + $y == $z) {
            return true;
        }
        $greatest_common_divisor = self::gcd($x, $y);
        return ($z % $greatest_common_divisor) === 0;
    }
}
```


效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


注意砍掉两个工具壶容量之和达不到目标水量的情况. 题干隐含的就是这个意思.

虽说道理是`$z`能整除`gcd($x, $y)`即可, 但是还是应该先把不符合条件的情况砍掉, 以免报除以`0`之类的错误.

## 367. Valid Perfect Square

题目描述:


Given a positive integer *num*, write a function which returns True if *num* is a perfect square else False.

**Note:** **Do not** use any built-in library function such as `sqrt`.

**Example 1:**

<pre>
<strong>Input:</strong> 16
<strong>Output:</strong> true
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> 14
<strong>Output:</strong> false
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Boolean
     */
    function isPerfectSquare($num) 
    {
        $left = 1;
        $right = $num;
        while ($left <= $right) {
            $mid = floor($left + ($right - $left) / 2);
            if ($mid * $mid > $num) {
                $right = $mid - 1;
            } elseif ($mid * $mid < $num) {
                $left = $mid + 1;
            } else {
                return true;
            }
        }
        return false;
    }
}
```

效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 92.86% 的用户
> 
> 内存消耗 : 14.5 MB, 在所有 PHP 提交中击败了 100.00% 的用户


主要是想办法把这个范围缩小, 用的类似二分法之类的做法.

此外应当注意到基本不等式: 对于任意给定的 a > 0, b > 0, 有 (a + b) / 2 ≥ sqrt(a * b).



## 370. Range Addition (上锁题目, 需要氪会员)

题目描述:


Assume you have an array of length ***n*** initialized with all **0**'s and are given ***k*** update operations.

Each operation is represented as a triplet: **[startIndex, endIndex, inc]** which increments each element of subarray **A[startIndex ... endIndex]** (startIndex and endIndex inclusive) with **inc**.

Return the modified array after all ***k*** operations were executed.

**Example:**


<pre>
<strong>Input:</strong> length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
<strong>Output:</strong> [-2,0,3,5,3]
<strong>Explanation:</strong>

Initial state:
[0,0,0,0,0]

After applying operation [1,3,2]:
[0,2,2,2,0]

After applying operation [2,4,3]:
[0,2,5,5,3]

After applying operation [0,2,-2]:
[-2,0,3,5,3]
</pre>


## 371. Sum of Two Integers

题目描述:


Calculate the sum of two integers *a* and *b*, but you are **not allowed** to use the operator `+` and `-`.

**Example 1:**


<pre>
Input: a = 1, b = 2
Output: 3
</pre>


**Example 2:**


<pre>
Input: a = -2, b = 3
Output: 1
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer $a
     * @param Integer $b
     * @return Integer
     */
    function getSum($a, $b) 
    {
        return array_sum([$a, $b]);
    }
}
```


效果:

> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 93.33% 的用户
> 
> 内存消耗 : 14.7 MB, 在所有 PHP 提交中击败了 71.43% 的用户


PHP是最好的语言.


## 374. Guess Number Higher or Lower


题目描述:

We are playing the Guess Game. The game is as follows:

I pick a number from **1** to ***n***. You have to guess which number I picked.

Every time you guess wrong, I'll tell you whether the number is higher or lower.

You call a pre-defined API `guess(int num)` which returns 3 possible results (`-1`, `1`, or `0`):


<pre>
-1 : My number is lower
 1 : My number is higher
 0 : Congrats! You got it!
</pre> 
 

**Example :**


<pre>
<strong>Input:</strong> n = 10, pick = 6
<strong>Output:</strong> 6
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @param Integer $pick
     * @return Integer
     */
    function guessNumber($n, $pick) 
    {
        return $pick;
    }
}
```

效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 71.43% 的用户
> 
> 内存消耗 : 14.8 MB, 在所有 PHP 提交中击败了 100.00% 的用户

和278. First Bad Version 是一个人写的OJ吧...

![374-template.png](https://i.loli.net/2019/07/24/5d381ee05361982058.png)


## 378. Kth Smallest Element in a Sorted Matrix


题目描述:


Given a *n* × *n* matrix where each of the rows and columns are sorted in ascending order, find the *k*th smallest element in the matrix.

Note that it is the *k*th smallest element in the sorted order, not the *k*th distinct element.

**Example:**


<pre>
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.
</pre>

**Note:** 


You may assume *k* is always valid, 1 ≤ *k* ≤ *n*<sup>2</sup>.


解答:

```php
class Solution 
{

    /**
     * @param Integer[][] $matrix
     * @param Integer $k
     * @return Integer
     */
    function kthSmallest($matrix, $k) 
    {
        $total = [];
        foreach ($matrix as $row) {
            $total = array_merge($total, $row);
        }
        sort($total, $SORT_NUMERIC);
        return $total[$k - 1];
    }
}
```



效果:


> 执行用时 : 284 ms, 在所有PHP提交中击败了 50.00% 的用户
> 
> 内存消耗 : 25.7 MB, 在所有PHP提交中击败了 100.00% 的用户


## 383. Ransom Note

题目描述:


Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines; otherwise, it will return false.

Each letter in the magazine string can only be used once in your ransom note.

**Note:**


You may assume that both strings contain only lowercase letters.


<pre>
canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true
</pre>


解答:

```php
class Solution 
{

    /**
     * @param String $ransomNote
     * @param String $magazine
     * @return Boolean
     */
    function canConstruct($ransomNote, $magazine) 
    {
        $ransomNoteCharInfo = count_chars($ransomNote, 1);
        $magazineCharInfo = count_chars($magazine, 1);
        foreach ($ransomNoteCharInfo as $byteValue => $count) {
            if ($count > $magazineCharInfo[$byteValue]) {
                return false;
            }
        }
        return true;
    }
}
```



效果:


> 执行用时: 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 15.1 MB, 在所有 PHP 提交中击败了 33.33% 的用户


注意这个题的返回结果和每一个字符的数量相关, 不是光在杂志里有赎金字条的字符就行. 可以从示例中的第二行看出来. 


## 386. Lexicographical Numbers

题目描述:


Given an integer *n*, return 1 - *n* in lexicographical order.

For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].

Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.


解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @return Integer[]
     */
    function lexicalOrder($n) 
    {
        $arr = range(1, $n);
        sort($arr, SORT_STRING);
        return $arr;
    }
}
```


效果: 

> 执行用时 : 124 ms, 在所有 PHP 提交中击败了 66.67% 的用户
> 
> 内存消耗 : 20.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


## 387. First Unique Character in a String


题目描述:


Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.

**Examples:**


<pre>
s = "leetcode"
return 0.

s = "loveleetcode",
return 2.
</pre>



**Note:** 

You may assume the string contain only lowercase letters.


解答:

```php
class Solution 
{

    /**
     * @param String $str
     * @return Integer
     */
    function firstUniqChar($str) 
    {
        $occurrence_array = count_chars($str, 1);
        $uniques = [];
        foreach ($occurrence_array as $byteValue => $occurrence) {
            if ($occurrence == 1) {
                $uniques[] = chr($byteValue);
            }
        }
        if (count($uniques) === 0) {
            return -1;
        }
        $len = strlen($str);
        for ($i = 0; $i < $len; $i++) {
            if (in_array($str[$i], $uniques)) {
                return $i;
            }
        }
    }
}
```


效果:


> 执行用时 : 20 ms, 在所有PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有PHP提交中击败了 97.62% 的用户


以为这个做法很慢, 不过看了效果发现还可以...

## 389. Find the Difference

题目描述:

Given two strings ***s*** and ***t*** which consist of only lowercase letters.

String ***t*** is generated by random shuffling string ***s*** and then add one more letter at a random position.

Find the letter that was added in ***t***.

**Example:**


<pre>
Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.
</pre>


解答:

```php
class Solution 
{

    /**
     * @param String $s
     * @param String $t
     * @return String
     */
    function findTheDifference($s, $t) 
    {
        $chars_info_of_s = count_chars($s, 1);
        $chars_info_of_t = count_chars($t, 1);
        $less = 0;
        $more = 0;
        foreach ($chars_info_of_t as $ord => $count) {
            $more += $ord * $count;
        }
        foreach ($chars_info_of_s as $ord => $count) {
            $less += $ord * $count;
        }
        return chr($more - $less);
    }
}
```

效果:

> 执行用时 : 16 ms, 在所有 PHP 提交中击败了 65.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


## 405. Convert a Number to Hexadecimal


题目描述:

Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, [two’s complement](https://en.wikipedia.org/wiki/Two%27s_complement) method is used.

Note:

1. All letters in hexadecimal (`a-f`) must be in lowercase.
2. The hexadecimal string must not contain extra leading `0`s. If the number is zero, it is represented by a single zero character `'0'`; otherwise, the first character in the hexadecimal string will not be the zero character.
3. The given number is guaranteed to fit within the range of a 32-bit signed integer.
4. You <strong>must not use <em>any</em> method provided by the library</strong> which converts/formats the number to hex directly.



**Example 1:**



<pre>
Input:
26

Output:
"1a"
</pre>


**Example 2:**


<pre>
Input:
-1

Output:
"ffffffff"
</pre>


解答:


```php
class Solution 
{

    /**
     * @param Integer $num
     * @return String
     */
    function toHex($num) 
    {
        if ($num === 0) {
            return "0";
        }
        $result = "";
        $hexCharArr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        while ($num !== 0) {
            $result = $hexCharArr[$num & 0x0000000f] . $result;
            $num >>= 4;
            // 32位有符号整型, 对应的是8位数的16进制数.
            if (strlen($result) === 8) {
                break;
            }
        }
        return $result;
    }
}
```


效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 50.00% 的用户
> 
> 内存消耗 : 14.7 MB, 在所有 PHP 提交中击败了 100.00% 的用户


鉴于wiki被河蟹了, 这里直接放一下<a href="https://en.wikipedia.org/wiki/Two%27s_complement"><em>Two's complement</em>在wiki上的的定义</a>吧...

<strong>Two's complement</strong> is a mathematical operation on binary numbers, and is an example of a radix complement. It is used in computing as a method of signed number representation.

The two's complement of an *N*-bit number is defined as its complement with respect to 2<sup><em>N</em></sup>. For instance, for the three-bit number 010, the two's complement is 110, because 010 + 110 = 1000. The two's complement is calculated by inverting the digits and adding one.

Two's complement is the most common method of representing signed integers on computers, and more generally, fixed point binary values. In this scheme, if the binary number 010<sub>2</sub> encodes the signed integer 2<sub>10</sub>, then its two's complement, 110<sub>2</sub>, encodes the inverse: −2<sub>10</sub>. In other words, to reverse the sign of any integer in this scheme, you can take the two's complement of its binary representation. The tables at right illustrate this property.

<table>
  <caption><strong>Three-bit signed integers</strong></caption>
  <tr>
    <th>Decimal value</th>
    <th>Binary<small>(two's-complement representation)</small></th>
    <th>Two's complement<small>(2<sup>3</sup> - <em>n</em>)<sub>2</sub></small></th>
  </tr>
  <tr>
    <td>-4</td>
    <td>100</td>
    <td>100</td>
  </tr>
  <tr>
    <td>-3</td>
    <td>101</td>
    <td>011</td>
  </tr>
  <tr>
    <td>-2</td>
    <td>110</td>
    <td>010</td>
  </tr>
  <tr>
    <td>-1</td>
    <td>111</td>
    <td>001</td>
  </tr>
  <tr>
    <td>0</td>
    <td>000</td>
    <td>000</td>
  </tr>
  <tr>
    <td>1</td>
    <td>001</td>
    <td>111</td>
  </tr>
  <tr>
    <td>2</td>
    <td>010</td>
    <td>110</td>
  </tr>
  <tr>
    <td>3</td>
    <td>011</td>
    <td>101</td>
  </tr>
</table>

<br/>

<table>
  <caption><strong>Eight-bit signed integers</strong></caption>
  <tr>
    <th>Decimal value</th>
    <th>Binary<small>(two's-complement representation)</small></th>
    <th>Two's complement<small>(2<sup>8</sup> - <em>n</em>)<sub>2</sub></small></th>
  </tr>
  <tr>
    <td>-128</td>
    <td>1000 0000</td>
    <td>1000 0000</td>
  </tr>
  <tr>
    <td>-127</td>
    <td>1000 0001</td>
    <td>0111 1111</td>
  </tr>
  <tr>
    <td>-126</td>
    <td>1000 0010</td>
    <td>0111 1110</td>
  </tr>
  <tr>
    <td>-2</td>
    <td>1111 1110</td>
    <td>0000 0010</td>
  </tr>
  <tr>
    <td>-1</td>
    <td>1111 1111</td>
    <td>0000 0001</td>
  </tr>
  <tr>
    <td>0</td>
    <td>0000 0000</td>
    <td>0000 0000</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0000 0001</td>
    <td>1111 1111</td>
  </tr>
  <tr>
    <td>2</td>
    <td>0000 0010</td>
    <td>1111 1110</td>
  </tr>
  <tr>
    <td>126</td>
    <td>0111 1110</td>
    <td>1000 0010</td>
  </tr>
  <tr>
    <td>127</td>
    <td>0111 1111</td>
    <td>1000 0001</td>
  </tr>
</table>

Compared to other systems for representing signed numbers (*e.g.*, ones' complement), two's complement has the advantage that the fundamental arithmetic operations of addition, subtraction, and multiplication are identical to those for unsigned binary numbers (as long as the inputs are represented in the same number of bits - as the output, and any overflow beyond those bits is discarded from the result). This property makes the system simpler to implement, especially for higher-precision arithmetic. Unlike ones' complement systems, two's complement has no representation for negative zero, and thus does not suffer from its associated difficulties.

Conveniently, another way of finding the two's complement of a number is to take its ones' complement and add one: the sum of a number and its ones' complement is all '1' bits, or 2<sup><em>N</em></sup> − 1; and by definition, the sum of a number and its *two*'s complement is 2<sup><em>N</em></sup>.

### Converting from two's complement representation


A two's-complement number system encodes positive and negative numbers in a binary number representation. The weight of each bit is a power of two, except for the most significant bit, whose weight is the negative of the corresponding power of two.

The value w of an *N*-bit integer a<sub><em>N</em>−1</sub>a<sub><em>N</em>−2</sub>...a<sub>0</sub> is given by the following formula:

w = -a<sub><em>N</em>−1</sub>2<sup><em>N</em>−1</sup> + ∑<sup><em>N</em>−2</sup><sub>i=0</sub>a<sub>i</sub>2<sup>i</sup>

(GitHub Pages渲染不了LaTeX, 不然我就拿LaTeX写了, 凑合理解并互相理解下...)

The most significant bit determines the sign of the number and is sometimes called the sign bit. Unlike in sign-and-magnitude representation, the sign bit also has the weight −(2<sup><em>N</em> − 1</sup>) shown above. Using <em>N</em> bits, all integers from −(2<sup><em>N</em> − 1</sup>) to 2<sup><em>N</em> − 1</sup> − 1 can be represented.

The following Python code shows a simple function which will convert an unsigned input integer to a two's complement signed integer using the above logic with bitwise operators:


```python
def twos_complement(input_value, num_bits):
	'''Calculates a two's complement integer from the given input value's bits'''
	mask = 2**(num_bits - 1)
	return -(input_value & mask) + (input_value & ~mask)
```

### Converting to two's complement representation


In two's complement notation, a *non-negative* number is represented by its ordinary binary representation; in this case, the most significant bit is 0. Though, the range of numbers represented is not the same as with unsigned binary numbers. For example, an 8-bit unsigned number can represent the values 0 to 255 (11111111). However a two's complement 8-bit number can only represent positive integers from 0 to 127 (01111111), because the rest of the bit combinations with the most significant bit as '1' represent the negative integers −1 to −128.

The two's complement operation is the additive inverse operation, so negative numbers are represented by the two's complement of the absolute value.

#### From the ones' complement

To get the two's complement of a binary number, the bits are inverted, or "flipped", by using the bitwise NOT operation; the value of 1 is then added to the resulting value, ignoring the overflow which occurs when taking the two's complement of 0.

For example, using 1 byte (=8 bits), the decimal number 5 is represented by

0000 0101<sub>2</sub>


The most significant bit is 0, so the pattern represents a non-negative value. To convert to −5 in two's-complement notation, first, the bits are inverted, that is: 0 becomes 1 and 1 becomes 0:

1111 1010<sub>2</sub>
At this point, the representation is the ones' complement of the decimal value −5. To obtain the two's complement, 1 is added to the result, giving:

1111 1011<sub>2</sub>


The result is a signed binary number representing the decimal value −5 in two's-complement form. The most significant bit is 1, so the value represented is negative.

The two's complement of a negative number is the corresponding positive value. For example, inverting the bits of −5 (above) gives:

0000 0100<sub>2</sub>


And adding one gives the final value:

0000 0101<sub>2</sub>


The two's complement of zero is zero: inverting gives all ones, and adding one changes the ones back to zeros (since the overflow is ignored). Furthermore, the two's complement of the most negative number representable (e.g. a one as the most-significant bit and all other bits zero) is itself. Hence, there appears to be an 'extra' negative number.

#### Subtraction from 2<sup><em>N</em></sup>


The sum of a number and its ones' complement is an <em>N</em>-bit word with all 1 bits, which is (reading as an unsigned binary number) 2<sup><em>N</em></sup> − 1. Then adding a number to its two's complement results in the <em>N</em> lowest bits set to 0 and the carry bit 1, where the latter has the weight (reading it as an unsigned binary number) of 2<sup><em>N</em></sup>. Hence, in the unsigned binary arithmetic the value of two's-complement negative number x<sup>✡︎</sup> of a positive x satisfies the equality x<sup>✡︎</sup> = 2<sup><em>N</em></sup> − x.

For example, to find the 4-bit representation of −5 (subscripts denote the base of the representation):

x = 5<sub>10</sub> therefore x = 0101<sub>2</sub>


Hence, with <em>N</em> = 4:

x<sup>✡︎</sup> = 2<sup><em>N</em></sup> − x = 2<sup>4</sup> − 5<sub>10</sub> = 16<sub>10</sub> - 5<sub>10</sub> = 10000<sub>2</sub> − 0101<sub>2</sub> = 1011<sub>2</sub>



The calculation can be done entirely in base 10, converting to base 2 at the end:

x<sup>✡︎</sup> = 2<sup><em>N</em></sup> − x = 2<sup>4</sup> − 5<sub>10</sub> = 11<sub>10</sub> = 1011<sub>2</sub>


虽然看着有些迷, 但是我大概知道这讲的什么了...

## 408. Valid Word Abbreviation (上锁题目, 需要氪会员)

题目描述:

Given a **non-empty** string `s` and an abbreviation `abbr`, return whether the string matches with the given abbreviation.

A string such as `"word"` contains only the following valid abbreviations:


```
["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
```


Notice that only the above abbreviations are valid abbreviations of the string `"word"`. Any other string is not a valid abbreviation of `"word"`.

**Note:**


Assume `s` contains only lowercase letters and `abbr` contains only lowercase letters and digits.


**Example 1:**

```
Given s = "internationalization", abbr = "i12iz4n":

Return true.
```


**Example 2:**

```
Given s = "apple", abbr = "a2e":

Return false.
```


## 411. Minimum Unique Word Abbreviation (上锁题目, 需要氪会员)



A string such as `"word"` contains the following abbreviations:

<pre>
["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
</pre>

Given a target string and a set of strings in a dictionary, find an abbreviation of this target string with the <strong><em>smallest possible</em></strong> length such that it does not conflict with abbreviations of the strings in the dictionary.

Each **number** or letter in the abbreviation is considered length = 1. For example, the abbreviation "a32bc" has length = 4.

**Note:**

* In the case of multiple answers as shown in the second example below, you may return any one of them.
* Assume length of target string = **m**, and dictionary size = **n**. You may assume that **m ≤ 21**, **n ≤ 1000**, and <strong>log<sub>2</sub>(n) + m ≤ 20</strong>.



**Examples:**

<pre>
"apple", ["blade"] -> "a4" (because "5" or "4e" conflicts with "blade")

"apple", ["plain", "amber", "blade"] -> "1p3" (other valid answers include "ap3", "a3e", "2p2", "3le", "3l1").
</pre>


## 412. Fizz Buzz


题目描述:


Write a program that outputs the string representation of numbers from 1 to *upperBound*.

But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.

**Example:**


<pre>
upperBound = 15,

Return:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]
</pre>


解答1:

```php
class Solution 
{

    /**
     * @param Integer $upperBound
     * @return String[]
     */
    function fizzBuzz($upperBound)
    {
        $result = range(1, $upperBound);
        // `array_walk()` 的时候注意加上取地址符, 不然 walk 不上去.
        array_walk($result, $callback = function (&$num) {
            if ($num % 15 === 0) {
                $num = "FizzBuzz";
            }
        });
        array_walk($result, $callback = function (&$num) {
            // 加个判断, 要不总报 A non-numeric value encountered in ... 的 Warning. 烦人.
            if (is_int($num)) {
                if ($num % 3 === 0) {
                    $num = "Fizz";
                } elseif ($num % 5 === 0) {
                    $num = "Buzz";
                }
            }
        });
        array_walk($result, $callback = function (&$element) {
            $element = strval($element);
        });
        return $result;
    }
}
```

效果1:

> 执行用时 : 16 ms, 在所有 PHP 提交中击败了 59.52% 的用户
> 
> 内存消耗 : 18.1 MB, 在所有 PHP 提交中击败了 64.29% 的用户


解答2:


```php
class Solution 
{

    /**
     * @param Integer $upperBound
     * @return String[]
     */
    function fizzBuzz($upperBound)
    {
        $result = [];
        for ($i = 1; $i <= $upperBound; $i++) {
            if ($i % 15 === 0) {
                $result[$i - 1] = "FizzBuzz";
            } elseif ($i % 3 === 0) {
                $result[$i - 1] = "Fizz";
            } elseif ($i % 5 === 0) {
                $result[$i - 1] = "Buzz";
            } else {
                $result[$i - 1] = (string)($i);
            }
        }
        return $result;
    }
}
```

效果2:


> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 95.24% 的用户
> 
> 内存消耗 : 18 MB, 在所有 PHP 提交中击败了 92.86% 的用户


主要是复习一下 `array_walk()` 函数的用法. `$callback` 中用到的主变量是需要加取地址符的, 不能光指着那个用到地址的 `$array`.



## 414. Third Maximum Number

题目描述:

Given a **non-empty** array of integers, return the **third** maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).

**Example 1:**

```
Input: [3, 2, 1]

Output: 1

Explanation: The third maximum is 1.
```


**Example 2:**

```
Input: [1, 2]

Output: 2

Explanation: The third maximum does not exist, so the maximum (2) is returned instead.
```


**Example 3:**

```
Input: [2, 2, 3, 1]

Output: 1

Explanation: Note that the third maximum here means the third maximum distinct number.
Both numbers with value 2 are both considered as second maximum.
```


解答1:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function thirdMax($nums) 
    {
        $uniqueNums = array_unique($nums);
        $uniqueCount = count($uniqueNums);
        if ($uniqueCount < 3) {
            return max($uniqueNums);
        }
        rsort($uniqueNums);
        return ($uniqueNums[2]);
    }
}
```


效果1:


> 执行用时 : 16 ms, 在所有 PHP 提交中击败了 95.45% 的用户
> 
> 内存消耗 : 16.4 MB, 在所有 PHP 提交中击败了 16.67% 的用户


解答2:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function thirdMax($nums) 
    {
        $count = count($nums);
        $first = $nums[0];  
        $second = PHP_INT_MIN; 
        $third = PHP_INT_MIN; 
        // 遍历数组.
        for ($i = 1; $i < $count; $i++) { 
            if ($nums[$i] > $first) { 
                // 当前元素严格比预设最大大就把预设最大、预设第二大、预设第三大整体改一下.
                $third = $second; 
                $second = $first; 
                $first = $nums[$i]; 
            } elseif ($nums[$i] > $second && $nums[$i] < $first) { 
                // 当前元素严格大于预设第二大且严格小于预设最大, 就改预设第二大和预设第三大.
                $third = $second; 
                $second = $nums[$i]; 
            } elseif ($nums[$i] > $third && $nums[$i] < $second) {
                // 当前元素严格大于预设第三大且严格小于预设第二大, 就改预设第三大.
                $third = $nums[$i]; 
            }
        }
        if ($third == PHP_INT_MIN) {
            return $first;
        }
        return $third;
    }
}
```

效果2:

> 执行用时 : 16 ms, 在Third Maximum Number的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 16 MB, 在Third Maximum Number的PHP提交中击败了 100.00% 的用户


解答3: 

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function thirdMax($nums) 
    {
        $uniqueNums = array_unique($nums);
        $uniqueCount = count($uniqueNums);
        if ($uniqueCount < 3) {
            return max($uniqueNums);
        }
        // 分别去除两次数组中当前的最大值, 剩下的最大值就是最开始那个数组的第三大的值.
        unset($uniqueNums[array_search(max($uniqueNums), $uniqueNums)]);
        unset($uniqueNums[array_search(max($uniqueNums), $uniqueNums)]);
        return max($uniqueNums);
    }
}
```

效果3:

> 执行用时 : 16 ms, 在所有 PHP 提交中击败了 95.45% 的用户
> 
> 内存消耗 : 16.5 MB, 在所有 PHP 提交中击败了 16.67% 的用户


解答4: 


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function thirdMax($nums) 
    {
        $firstMax = max($nums);
        $firstFilteredNums = array_filter($nums, $filter = function ($element) use ($firstMax) {
            return $element != $firstMax;
        });
        if ($firstFilteredNums == []) {
            return $firstMax;
        }
        $secondMax = max($firstFilteredNums);
        $secondFilteredNums = array_filter($firstFilteredNums, $filter = function ($element) use ($secondMax) {
            return $element != $secondMax;
        });
        if ($secondFilteredNums == []) {
            return $firstMax;
        }
        return max($secondFilteredNums);
    }
}
```

效果4:

> 执行用时 : 20 ms, 在所有 PHP 提交中击败了 86.36% 的用户
> 
> 内存消耗 : 16 MB, 在所有 PHP 提交中击败了 100.00% 的用户


注意题目要求是找严格第三大的值.

第一个做法`rsort()`肯定会超时...但确实是快...


## 415. Add Strings

题目描述:

Given two non-negative integers `num1` and `num2` represented as string, return the sum of `num1` and `num2`.

**Note:**

1. The length of both `num1` and `num2` is < 5100.
2. Both `num1` and `num2` contains only digits `0-9`.
3. Both `num1` and `num2` does not contain any leading zero.
4. You **must not use any built-in BigInteger library** or **convert the inputs to integer** directly.


解答:

```php
class Solution 
{

    /**
     * @param String $num1
     * @param String $num2
     * @return String
     */
    function addStrings($num1, $num2) 
    {
        if ($num1 === '0' && $num2 === '0') {
            return '0';
        }
        $num1Len = strlen($num1);
        $num2Len = strlen($num2);
        $largerLen = max($num1Len, $num2Len);
        // 初始化一个容量为两个数长度较大的那个长度+1的数组用来存放结果, 因为结果最长不会超过这个容量. 
        $resultArr = array_fill(0, $largerLen + 1, 0);
        // 在加数前面补0直到位数一样(较大的位数). 
        $paddedNum1 = str_pad($num1, $largerLen, '0', STR_PAD_LEFT);
        $paddedNum2 = str_pad($num2, $largerLen, '0', STR_PAD_LEFT);
        for ($i = $largerLen - 1; $i >= 0; $i--) {
            // 同一位置的对应位相加再加上本来有的位(就是进位)再做处理的中间结果
            $temp = $paddedNum1[$i] + $paddedNum2[$i] + $resultArr[$i + 1];
            $resultArr[$i + 1] = $temp % 10;
            $resultArr[$i] += floor($temp / 10); // 高位就是乘完加进位取整除以10  
        }
        // 去掉前面的0. PHP是最好的语言!
        return ltrim(implode('', $resultArr), '0');
    }
}
```


效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 15.2 MB, 在所有 PHP 提交中击败了 71.43% 的用户



和67. Add Binary一样. 改下进制就完事儿了.


## 434. Number of Segments in a String


Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.

Please note that the string does not contain any **non-printable** characters.

**Example:**


<pre>
Input: "Hello, my name is John"
Output: 5
</pre>


解答:

```php
class Solution 
{

    /**
     * @param String $s
     * @return Integer
     */
    function countSegments($s) 
    {
        // 需要加上这一条, 不然过不了OJ.
        $s = trim($s);
        if ($s == "") {
            return 0;
        }
        // PHP是最好的语言!
        return count(preg_split("/[\s]+/", $s));
    }
}
```


效果:

> 执行用时 : 12 ms, 在Number of Segments in a String的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.8 MB, 在Number of Segments in a String的PHP提交中击败了 25.00% 的用户


## 441. Arranging Coins

题目描述:

You have a total of *total* coins that you want to form in a staircase shape, where every *k*-th row must have exactly *k* coins.

Given *n*, find the total number of **full** staircase rows that can be formed.

*total* is a non-negative integer and fits within the range of a 32-bit signed integer.

**Example 1:**


<pre>
total = 5

The coins can form the following rows:
¤
¤ ¤
¤ ¤

Because the 3rd row is incomplete, we return 2.
</pre>


**Example 2:**

<pre>
total = 8

The coins can form the following rows:
¤
¤ ¤
¤ ¤ ¤
¤ ¤

Because the 4th row is incomplete, we return 3.
</pre>


解答:

```php
class Solution {

    /**
     * @param Integer $total
     * @return Integer
     */
    function arrangeCoins($total) 
    {
        return floor(-1 / 2 + sqrt(1 / 4 + 2 * $total));
    }
}
```

效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.4 MB, 在所有 PHP 提交中击败了 100.00% 的用户


解一元二次不等式会吧? 那解 maxRow × (maxRow + 1) / 2 ≤ total 就完事儿了.

注意返回结果的时候先化一下式子. 把太大的稍微约一约.



## 442. Find All Duplicates in an Array

题目描述:

Given an array of integers, 1 ≤ a[i] ≤ *n* (*n* = size of array), some elements appear **twice** and others appear **once**.

Find all the elements that appear **twice** in this array.

Could you do it without extra space and in O(*n*) runtime?

**Example:**

<pre>
<strong>Input:</strong>
[4,3,2,7,8,2,3,1]

<strong>Output:</strong>
[2,3]
</pre>


解答 1:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function findDuplicates($nums) 
    {
        // PHP是最好的语言！
        $nums_info = array_count_values($nums);
        $result = [];
        foreach ($nums_info as $num => $frequency) {
            if ($frequency == 2) {
                $result[] = $num;
            }
        }
        return $result;
    }
}
```


效果 1:

> 执行用时: 144 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 23.7 MB, 在所有 PHP 提交中击败了 36.36% 的用户


解答 2:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function findDuplicates($nums) 
    {
        // PHP是最好的语言！
        $nums_info = array_count_values($nums);
        return array_keys($nums_info, 2);
    }
}
```

> 执行用时: 152 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 23.7 MB, 在所有 PHP 提交中击败了 27.27% 的用户


136 题、137 题的精神续作.

这两种做法也是适合无数种情形, 比如出现两次、三次、四次...总之你爱出现几次就出现几次...



## 443. String Compression


题目描述:


Given an array of characters, compress it [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm).

The length after compression must always be smaller than or equal to the original array.

Every element of the array should be a **character** (not int) of length 1.

After you are done **modifying the input array** [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), return the new length of the array.

 
**Follow up:**


Could you solve it using only O(1) extra space?

 
**Example 1:**


<pre>
<strong>Input:</strong>
["a","a","b","b","c","c","c"]

<strong>Output:</strong>
Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]

<strong>Explanation:</strong>
"aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".
</pre>

**Example 2:**


<pre>
<strong>Input:</strong>
["a"]

<strong>Output:</strong>
Return 1, and the first 1 characters of the input array should be: ["a"]

<strong>Explanation:</strong>
Nothing is replaced.
</pre>

**Example 3:**


<pre>
<strong>Input:</strong>
["a","b","b","b","b","b","b","b","b","b","b","b","b"]

<strong>Output:</strong>
Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].

<strong>Explanation:</strong>
Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12".
Notice each digit has it's own entry in the array.
</pre>

**Note:**

1. All characters have an ASCII value in `[35, 126]`.
2. `1 <= len(chars) <= 1000`.


解答:

```php
class Solution 
{

    /**
     * @param String[] $chars
     * @return Integer
     */
    function compress(&$chars) 
    {
        // 先用正则表达式把 $chars 对应的字符串分割成由相同字母重复而成的子串.
        $repeated_character_pieces = preg_split('/(.)(?!\1|$)\K/', implode($chars));
        $capacity = count($chars);
        $temp = [];
        foreach ($repeated_character_pieces as $piece) {
            $temp[] = $piece[0];
            $strlen = strlen($piece);
            if ($strlen > 1) {
                foreach (str_split(strval($strlen)) as $digit) {
                    $temp[] = $digit;
                }
            }
        }
        $compression_capacity = count($temp);
        for ($i = 0; $i < $compression_capacity; $i++) {
            $chars[$i] = $temp[$i];
        }
        for ($i = $compression_capacity; $i < $capacity; $i++) {
            unset($chars[$i]);
        }
        return count($chars);
    }
}
```


效果:

> 执行用时: 12 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 15.4 MB, 在所有 PHP 提交中击败了 100.00% 的用户



这个题虽然是 easy 难度, 但是做的时候简直不知道有多麻烦...


有一个坑点是: 比如我传入的 `$chars` 是 `["a","a","a","b","b","a","a"]`, 题目要求传出 `["a","3","b","2","a","2"]`, 而不是 `["a","5","b","2"]`, 所以不能拿 `array_count_values()` 做.



这个正则表达式使用的是 [How to split a string by repeated characters in PHP?](https://stackoverflow.com/a/33197074/11457285) 里的想法. 

看一下答主 [user3942918](https://stackoverflow.com/users/3942918/user3942918) 关于这个正则表达式的讲解:

> The regex:
> 
> * (.) - match a single character and capture it
> * (?!\1|$) - look at the next position and match if it's not the same as the one we just found nor the end of the string.
> * \K - keeps the text matched so far out of the overall regex match, making this match zero-width.


有时间还是要多多认真学习正则表达式. 

## 448. Find All Numbers Disappeared in an Array

题目描述:

Given an array of integers where 1 ≤ a[i] ≤ *n* (*n* = size of array), some elements appear twice and others appear once.

Find all the elements of [1, *n*] inclusive that do not appear in this array.

Could you do it without extra space and in O(*n*) runtime? You may assume the returned list does not count as extra space.

**Example:**


<pre>
Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function findDisappearedNumbers($nums) 
    {
        if ($nums == []) {
            return [];
        }
        $range = range(1, count($nums));
        // PHP是最好的语言!
        return array_diff($range, $nums);
    }
}
```


效果:

> 执行用时 : 192 ms, 在Find All Numbers Disappeared in an Array的PHP提交中击败了 85.71% 的用户
> 
> 内存消耗 : 25.2 MB, 在Find All Numbers Disappeared in an Array的PHP提交中击败了 33.33% 的用户



## 451. Sort Characters By Frequency

题目描述:

Given a string, sort it in decreasing order based on the frequency of characters.

**Example 1:**

<pre>
Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
</pre>


**Example 2:**

<pre>
Input:
"cccaaa"

Output:
"cccaaa"

Explanation:
Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer.
Note that "cacaca" is incorrect, as the same characters must be together.
</pre>

**Example 3:**

<pre>
Input:
"Aabb"

Output:
"bbAa"

Explanation:
"bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
</pre>

解答:

```php
class Solution 
{

    /**
     * @param String $s
     * @return String
     */
    function frequencySort($s) 
    {
        $occurrenceCounts = [];
        // PHP是最好的语言!
        $occurrenceCounts = count_chars($s, 1);
        arsort($occurrenceCounts, SORT_NUMERIC);
        $result = "";
        foreach ($occurrenceCounts as $char => $occurrence) {
            $result .= str_repeat(chr($char), $occurrence);
        }
        return $result;
    }
}
```

效果:

> 执行用时 : 12 ms, 在Sort Characters By Frequency的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 15.5 MB, 在Sort Characters By Frequency的PHP提交中击败了 100.00% 的用户


## 459. Repeated Substring Pattern



题目描述:

Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.

 

**Example 1:**


<pre>
Input: "abab"
Output: True
Explanation: It's the substring "ab" twice.
</pre>


**Example 2:**


<pre>
Input: "aba"
Output: False
</pre>


**Example 3:**


<pre>
Input: "abcabcabcabc"
Output: True
Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)
</pre>

解答:


```php
class Solution 
{

    /**
     * @param String $str
     * @return Boolean
     */
    function repeatedSubstringPattern($str) 
    {
        $len = strlen($str);
        return (strpos(substr(str_repeat($str, 2), 1, 2 * $len - 2), $str) !== false);
    }
}
```


效果:


> 执行用时 : 24 ms, 在所有PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.7 MB, 在所有PHP提交中击败了 100.00% 的用户


如果重复的话, 次数至少是两次起. 那么在重复的时候, 两个原字符串拼一起, 重复次数至少是四次起; 现在掐头字母去尾字母, 中间的部分重复次数至少是两次起, 也就相当于是一个原字符串.3

注意`strpos`函数的比较技巧. 是否出现要用`!==`这类类型+值同时判断的运算符和`false`比较.



## 461. Hamming Distance

题目描述:


The [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance) between two integers is the number of positions at which the corresponding bits are different.

Given two integers `x` and `y`, calculate the Hamming distance.

Note:
0 ≤ `x`, `y` < 2<sup>31</sup>.

**Example:**


<pre>
Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

The above arrows point to positions where the corresponding bits are different.
</pre>

解答:

```php
class Solution 
{

    /**
     * @param Integer $x
     * @param Integer $y
     * @return Integer
     */
    function hammingDistance($x, $y) 
    {
        return substr_count(decbin($x ^ $y), '1');
    }
}
```

效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 92.59% 的用户
> 
> 内存消耗 : 14.5 MB, 在所有 PHP 提交中击败了 91.67% 的用户

想法还是比较直接的...


看一下Wiki科普一下: In information theory, the Hamming distance between two strings of equal length is the number of positions at which the corresponding symbols are different. In other words, it measures the minimum number of substitutions required to change one string into the other, or the minimum number of errors that could have transformed one string into the other. In a more general context, the Hamming distance is one of several string metrics for measuring the edit distance between two sequences. It is named after the American mathematician Richard Hamming.

A major application is in coding theory, more specifically to block codes, in which the equal-length strings are vectors over a finite field.

## 470. Implement Rand10() Using Rand7() (无 PHP 提交 OJ)



题目描述:



Given a function `rand7` which generates a uniform random integer in the range 1 to 7, write a function `rand10` which generates a uniform random integer in the range 1 to 10.

Do NOT use system's `Math.random()`.

 

**Example 1:**


<pre>
Input: 1
Output: [7]
</pre>


**Example 2:**


<pre>
Input: 2
Output: [8,4]
</pre>



**Example 3:**


<pre>
Input: 3
Output: [8,1,10]
</pre>

 

**Note:**


1. `rand7` is predefined.
2. Each testcase has one argument: `n`, the number of times that `rand10` is called.
 

**Follow up:**


1. What is the [expected value](https://en.wikipedia.org/wiki/Expected_value) for the number of calls to `rand7()` function?
2. Could you minimize the number of calls to `rand7()`?




## 476. Number Complement

题目描述:

Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.

**Note:**


1. The given integer is guaranteed to fit within the range of a 32-bit signed integer.
2. You could assume no leading zero bit in the integer’s binary representation.


**Example 1:**


<pre>
Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
</pre>


**Example 2:**


<pre>
Input: 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Integer
     */
    function findComplement($num) 
    {
        $bin = base_convert($num, 10, 2);
        $bin_len = strlen($bin);
        for ($i = 0; $i < $bin_len; $i++) {
            switch ($bin[$i]) {
                case '0' :
                    $bin[$i] = '1';
                    continue;
                case '1' :
                    $bin[$i] = '0';
                    continue;
            }
        }
        return bindec(ltrim($bin, '0'));
    }
}
```


效果:

> 执行用时 : 4 ms, 在Number Complement的PHP提交中击败了 87.50% 的用户
> 
> 内存消耗 : 14.9 MB, 在Number Complement的PHP提交中击败了 100.00% 的用户


## 482. License Key Formatting

题目描述:

You are given a license key represented as a string `str` which consists only alphanumeric character and dashes. The string is separated into *n*+1 groups by *n* dashes.

Given a number *k*, we would want to reformat the strings such that each group contains exactly *k* characters, except for the first group which could be shorter than *k*, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.

Given a non-empty string `str` and a number *k*, format the string according to the rules described above.

**Example 1:**

<pre>
Input: str = "5F3Z-2e-9-w", k = 4

Output: "5F3Z-2E9W"

Explanation: The string str has been split into two parts, each part has 4 characters.
Note that the two extra dashes are not needed and can be removed.
</pre>

**Example 2:**

<pre>
Input: str = "2-5g-3-J", k = 2

Output: "2-5G-3J"

Explanation: The string str has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.
</pre>

**Note:**


1. The length of string `str` will not exceed 12,000, and *k* is a positive integer.
2. String `str` consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).
3. String `str` is non-empty.

解答:

```php
class Solution 
{

    /**
     * @param String $str
     * @param Integer $k
     * @return String
     */
    function licenseKeyFormatting($str, $k) 
    {
        // 见注意事项第二条, 直接匹配掉'-'即可.
        $str = preg_replace('/-/', '', $str);
        $upperStr = strtoupper($str);
        $str_len = strlen($upperStr);
        // 字符串总长度不够指定长度的话直接返回字符串.
        if ($str_len < $k) {
            return $upperStr;
        }
        $remainder = $str_len % $k;
        // 字符串总长度是指定长度的整数倍的话就直接str_split()分然后内爆.
        if ($remainder == 0) {
            return implode('-', str_split($upperStr, $k));
        }
        // 不是整数倍的话就把前面的剩余部分和后面的内爆结果拼一起.
        return substr($upperStr, 0, $remainder) . '-' . implode('-', str_split(substr($upperStr, $remainder), $k));
    }
}
```

效果:

> 执行用时 : 8 ms, 在License Key Formatting的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 17.8 MB, 在License Key Formatting的PHP提交中击败了 20.00% 的用户



## 485. Max Consecutive Ones

题目描述:

Given a binary array, find the maximum number of consecutive 1s in this array.

**Example 1:**


<pre>
Input: [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s.
    The maximum number of consecutive 1s is 3.
</pre>

    
**Note:**

* The input array will only contain `0` and `1`.
* The length of input array is a positive integer and will not exceed 10,000


解答1:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findMaxConsecutiveOnes($nums) 
    {
        $str = implode("", $nums);
        $array_1 = explode('0', $str);
        return strlen(max($array_1));
    }
}
```


效果1:

> 执行用时 : 136 ms, 在Max Consecutive Ones的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 15.8 MB, 在Max Consecutive Ones的PHP提交中击败了 72.73% 的用户


解答2:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findMaxConsecutiveOnes($nums) 
    {
        $str = implode("", $nums);
        $array_1 = explode('0', $str);
        $count_of_1 = array_map('strlen', $array_1);
        return max($count_of_1);
    }
}
```


效果2: 

> 执行用时 : 140 ms, 在Max Consecutive Ones的PHP提交中击败了 96.00% 的用户
> 
> 内存消耗 : 15.8 MB, 在Max Consecutive Ones的PHP提交中击败了 81.82% 的用户


## 487. Max Consecutive Ones II (上锁题目, 需要氪会员)


题目描述:

Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.

**Example 1:**

<pre>
Input: [1,0,1,1,0]
Output: 4
Explanation: Flip the first zero will get the the maximum number of consecutive 1s.
    After flipping, the maximum number of consecutive 1s is 4.
</pre>

**Note:**



* The input array will only contain `0` and `1`.
* The length of input array is a positive integer and will not exceed 10,000


**Follow up:**


What if the input numbers come in one by one as an **infinite stream**? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?


## 492. Construct the Rectangle

题目描述:


For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:

1. The area of the rectangular web page you designed must equal to the given target area.

2. The width W should not be larger than the length L, which means L >= W.

3. The difference between length L and width W should be as small as possible.


You need to output the length L and the width W of the web page you designed in sequence.


**Example:**


<pre>
<strong>Input:</strong> 4
<strong>Output:</strong> [2, 2]
<strong>Explanation:</strong> The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. 
But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.
</pre>

**Note:**

1. The given area won't exceed 10,000,000 and is a positive integer
2. The web page's width and length you designed must be positive integers.



解答:

```php
class Solution 
{

    /**
     * @param Integer $area
     * @return Integer[]
     */
    function constructRectangle($area)
    {
        $sqrt = floor(sqrt($area));
        for ($width = $sqrt; $width > 1; $width--) {
            if ($area % $width === 0) {
                $length = $area / $width;
                return [$length, $width];
            }
        }
        return [$area, 1];
    }
}
```

效果:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在所有 PHP 提交中击败了 100.00% 的用户


## 500. Keyboard Row


题目描述:

Given a List of words, return the words that can be typed using letters of **alphabet** on only one row's of American keyboard like the image below.


![keyboard.png](https://i.loli.net/2019/08/16/mZ4KYQEzJP1iGAo.png)


**Example:**


<pre>
<strong>Input:</strong> ["Hello", "Alaska", "Dad", "Peace"]
<strong>Output:</strong> ["Alaska", "Dad"]
</pre>


**Note:**

1. You may use one character in the keyboard more than once.
2. You may assume the input string will only contain letters of alphabet.



解答:


```php
class Solution 
{

    /**
     * @param String[] $words
     * @return String[]
     */
    function findWords($words) 
    {
        $first_row = ["q", "w", "e", "r", "t", "y", "u", "i", "o", "p"];
        $second_row = ["a", "s", "d", "f", "g", "h", "j", "k", "l"];
        $third_row = ["z", "x", "c", "v", "b", "n", "m"];
        $collection = [$first_row, $second_row, $third_row];
        $result = [];
        foreach ($words as $word) {
            $char_array = str_split(strtolower($word));
            foreach ($collection as $row) {
                if (in_array($char_array[0], $row)) {
                    if (empty(array_diff($char_array, $row))) {
                        $result[] = $word;
                    }
                    break;
                } else {
                    continue;
                }
            }
        }
        return $result;
    }
}
```


效果:



> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 92.31% 的用户
> 
> 内存消耗 : 14.9 MB, 在所有 PHP 提交中击败了 100.00% 的用户




## 504. Base 7

题目描述:

Given an integer, return its base 7 string representation.

**Example 1:**


<pre>
<strong>Input:</strong> 100
<strong>Output:</strong> "202"
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> -7
<strong>Output:</strong> "-10"
</pre>


**Note:** The input will be in range of [-1e7, 1e7].


解答:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return String
     */
    function convertToBase7($num) 
    {
        // PHP是最好的语言!
        if ($num < 0) {
            return '-' . base_convert($num, 10, 7);
        }
        return base_convert($num, 10, 7);
    }
}
```

效果:

> 执行用时: 8 ms, 在 Base 7 的 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 14.7 MB, 在 Base 7 的 PHP 提交中击败了 100.00% 的用户


注意数字转字符串的时候只转 e, 不转符号.


## 506. Relative Ranks

题目描述:

Given scores of **N** athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: "Gold Medal", "Silver Medal" and "Bronze Medal".

**Example 1:**


<pre>
<strong>Input:</strong> [5, 4, 3, 2, 1]
<strong>Output:</strong> ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]
<strong>Explanation:</strong> The first three athletes got the top three highest scores, so they got "Gold Medal", "Silver Medal" and "Bronze Medal". 
For the left two athletes, you just need to output their relative ranks according to their scores.
</pre>


**Note:**

1. **N** is a positive integer and won't exceed 10,000.
2. All the scores of athletes are guaranteed to be unique.



解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return String[]
     */
    function findRelativeRanks($nums) 
    {
        arsort($nums);
        $count = count($nums);
        $keys = array_keys($nums);
        $values = array_values($nums);
        for ($i = 0; $i < $count; $i++) {
            switch ($i) {
                case 0: {
                    $values[0] = "Gold Medal";
                    continue;
                }
                case 1: {
                    $values[1] = "Silver Medal";
                    continue;
                }
                case 2: {
                    $values[2] = "Bronze Medal";
                    continue;
                }
                default: {
                    $values[$i] = strval($i + 1);
                }
            }
        }
        $relative_ranks = array_combine($keys, $values);
        ksort($relative_ranks);
        return $relative_ranks;
    }
}
```


效果:


> 执行用时 : 20 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 17.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户

这个题是要求键值关联的. 不是从大到小一排就完事儿. 但是从题目给的示例说实话看不出来这一点...


## 507. Perfect Number


题目描述:


We define the Perfect Number is a **positive** integer that is equal to the sum of all its **positive** divisors except itself.

Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.


**Example:**


<pre>
Input: 28
Output: True
Explanation: 28 = 1 + 2 + 4 + 7 + 14
</pre>


**Note:** The input number **n** will not exceed 100,000,000. (1e8)



解答:

```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Boolean
     */
    function checkPerfectNumber($num) 
    {
        return in_array($num, [6, 28, 496, 8128, 33550336]);
    }
}
```


效果:

> 执行用时 : 16 ms, 在Perfect Number的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在Perfect Number的PHP提交中击败了 100.00% 的用户


善于利用底蕴和经验也是一种能力.



## 509. Fibonacci Number



题目描述:


The **Fibonacci numbers**, commonly denoted `F(n)` form a sequence, called the **Fibonacci sequence**, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is,

<pre>
F(0) = 0,   F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
</pre>


Given `n`, calculate `F(n)`.

 

**Example 1:**


<pre>
<strong>Input:</strong> 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> F(2) = F(1) + F(0) = 1 + 0 = 1.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> F(3) = F(2) + F(1) = 1 + 1 = 2.
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> 4
<strong>Output:</strong> 3
<strong>Explanation:</strong> F(4) = F(3) + F(2) = 2 + 1 = 3.
</pre>

**Note:**

`0 ≤ n ≤ 30`.


解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @return Integer
     */
    function fib($n) 
    {
        $fib_array = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040];
        return $fib_array[$n];
    }
}
```


效果:

> 执行用时 : 4 ms, 在 Fibonacci Number 的 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在 Fibonacci Number 的 PHP 提交中击败了 9.52% 的用户



也是查查资料就能出来的东西, 没必要去写.


## 520. Detect Capital

题目描述:

Given a word, you need to judge whether the usage of capitals in it is right or not.

We define the usage of capitals in a word to be right when one of the following cases holds:

1. All letters in this word are capitals, like "USA".
2. All letters in this word are not capitals, like "leetcode".
3. Only the first letter in this word is capital, like "Google".


Otherwise, we define that this word doesn't use capitals in a right way.


**Example 1:**


<pre>
Input: "USA"
Output: True
</pre>


**Example 2:**


<pre>
Input: "FlaG"
Output: False
</pre>

**Note:** The input will be a non-empty word consisting of uppercase and lowercase latin letters.


解答:

```php
class Solution 
{

    /**
     * @param String $word
     * @return Boolean
     */
    function detectCapitalUse($word) 
    {
        // PHP是最好的语言!
        return ($word == strtoupper($word)) || ($word == strtolower($word)) || ($word == ucfirst(strtolower($word)));
    }
}
```


效果:

> 执行用时 : 12 ms, 在 Detect Capital 的 PHP 提交中击败了 90.91% 的用户
> 
> 内存消耗 : 14.7 MB, 在 Detect Capital 的 PHP 提交中击败了 100.00% 的用户


## 533. Lonely Pixel II (上锁题目, 需要氪会员)


题目描述:

Given a picture consisting of black and white pixels, and a positive integer N, find the number of black pixels located at some specific row **R** and column **C** that align with all the following rules:

1. Row R and column C both contain exactly N black pixels.
2. For all rows that have a black pixel at column C, they should be exactly the same as row R.


The picture is represented by a 2D char array consisting of 'B' and 'W', which means black and white pixels respectively.


**Example:**

<pre>
Input:                                            
[['W', 'B', 'W', 'B', 'B', 'W'],    
 ['W', 'B', 'W', 'B', 'B', 'W'],    
 ['W', 'B', 'W', 'B', 'B', 'W'],    
 ['W', 'W', 'B', 'W', 'B', 'W']] 

N = 3
Output: 6
Explanation: All the bold 'B' are the black pixels we need (all 'B's at column 1 and 3).
        0    1    2    3    4    5         column index                                            
0    [['W', 'B', 'W', 'B', 'B', 'W'],    
1     ['W', 'B', 'W', 'B', 'B', 'W'],    
2     ['W', 'B', 'W', 'B', 'B', 'W'],    
3     ['W', 'W', 'B', 'W', 'B', 'W']]    
row index

Take 'B' at row R = 0 and column C = 1 as an example:
Rule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels. 
Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0.
</pre>


**Note:**

1. The range of width and height of the input 2D array is [1,200].


## 535. Encode and Decode TinyURL (无 PHP 提交 OJ)

题目描述:

> Note: This is a companion problem to the [System Design](https://leetcode.com/discuss/interview-question/system-design/) problem: [Design TinyURL](https://leetcode.com/discuss/interview-question/124658/Design-a-URL-Shortener-(-TinyURL-)-System/).

TinyURL is a URL shortening service where you enter a URL such as `https://leetcode.com/problems/design-tinyurl` and it returns a short URL such as `http://tinyurl.com/4e9iAk`.

Design the `encode` and `decode` methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.

解答:

```javascript
/**
 * Encodes a URL to a shortened URL.
 *
 * @param {string} longUrl
 * @return {string}
 */
var encode = function(longUrl) {
    return longUrl
}

/**
 * Decodes a shortened URL to its original URL.
 *
 * @param {string} shortUrl
 * @return {string}
 */
var decode = function(shortUrl) {
    return shortUrl
}

/**
 * Your functions will be called as such:
 * decode(encode(url));
 */
```

效果:

> 执行用时: 64 ms, 在所有 JavaScript 提交中击败了 100.00% 的用户
> 
> 内存消耗: 34.8 MB, 在所有 JavaScript 提交中击败了 45.90% 的用户


## 537. Complex Number Multiplication

题目描述:

Given two strings representing two complex numbers.

You need to return a string representing their multiplication. Note i<sup>2</sup> = -1 according to the definition.

**Example 1:**

<pre>
<strong>Input:</strong> "1+1i", "1+1i"
<strong>Output:</strong> "0+2i"
<strong>Explanation:</strong> (1 + i) * (1 + i) = 1 + i<sup>2</sup> + 2 * i = 2i, and you need convert it to the form of 0+2i.
</pre>



**Example 2:**

<pre>
<strong>Input:</strong> "1+-1i", "1+-1i"
<strong>Output:</strong> "0+-2i"
<strong>Explanation:</strong> (1 - i) * (1 - i) = 1 + i<sup>2</sup> - 2 * i = -2i, and you need convert it to the form of 0+-2i.
</pre>


**Note:**

> 1. The input strings will not have extra blank.
> 
> 2. The input strings will be given in the form of **a+bi**, where the integer **a** and **b** will both belong to the range of [-100, 100]. And **the output should be also in this form**.


解答:

```php
class Solution 
{

    /**
     * @param String $a
     * @param String $b
     * @return String
     */
    function complexNumberMultiply($a, $b) 
    {
        $parts_a = explode('+', $a);
        $parts_b = explode('+', $b);
        $re_a = intval($parts_a[0]);
        $im_a = intval($parts_a[1]);
        $re_b = intval($parts_b[0]);
        $im_b = intval($parts_b[1]);
        $re_result = strval($re_a * $re_b - $im_a * $im_b);
        $im_result = strval($re_a * $im_b + $re_b * $im_a);
        return $re_result . '+' . $im_result . 'i';
    }
}
```

效果:

> 执行用时 : 8 ms, 在Complex Number Multiplication的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.8 MB, 在Complex Number Multiplication的PHP提交中击败了 100.00% 的用户


有难度吗?


## 540. Single Element in a Sorted Array


题目描述:


Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.

**Example 1:**

<pre>
<strong>Input:</strong> [1,1,2,3,3,4,4,8,8]
<strong>Output:</strong> 2
</pre>


**Example 2:**

<pre>
<strong>Input:</strong> [3,3,7,7,10,11,11]
<strong>Output:</strong> 10
</pre>


**Note:** Your solution should run in O(log n) time and O(1) space.



解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function singleNonDuplicate($nums) 
    {
        $occurrence_count = array_count_values($nums);
        foreach ($occurrence_count as $num => $occurrence) {
            if ($occurrence == 1) {
                return $num;
            }
        }
    }
}
```


效果:

> 执行用时 : 32 ms, 在所有PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 17.2 MB, 在所有PHP提交中击败了 25.00% 的用户


反正是过了.


## 541. Reverse String II

题目描述:

Given a string and an integer *k*, you need to reverse the first *k* characters for every *2k* characters counting from the start of the string. If there are less than *k* characters left, reverse all of them. If there are less than *2k* but greater than or equal to *k* characters, then reverse the first *k* characters and left the other as original.


**Example:**

<pre>
Input: s = "abcdefg", k = 2
Output: "bacdfeg"
</pre>


**Restrictions:**

1. The string consists of lower English letters only.
2. Length of the given string and k will in the range [1, 10000]


解答:

```php
class Solution 
{

    /**
     * @param String $s
     * @param Integer $k
     * @return String
     */
    function reverseStr($s, $k) 
    {
        $result = "";
        $str_len = strlen($s);
        $split_len = 2 * $k;
        $src_arr = str_split($s, $split_len);
        $arr_count = count($src_arr);
        for ($i = 0; $i < $arr_count - 1; $i++) {
            $result = $result . strrev(substr($src_arr[$i], 0, $k)) . substr($src_arr[$i], $k);
        }
        if (strlen($src_arr[$arr_count - 1]) > $k) {
            $result = $result . strrev(substr($src_arr[$arr_count - 1], 0, $k)) . substr($src_arr[$arr_count - 1], $k);
            return $result;
        }
        $result .= strrev($src_arr[$arr_count - 1]);
        return $result;
    }
}
```

效果:

> 执行用时 : 4 ms, 在Reverse String II的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在Reverse String II的PHP提交中击败了 50.00% 的用户



## 555. Split Concatenated Strings (上锁题目, 需要氪会员)


题目描述:


Given a list of strings, you could concatenate these strings together into a loop, where for each string you could choose to reverse it or not. Among all the possible loops, you need to find the lexicographically biggest string after cutting the loop, which will make the looped string into a regular one.

Specifically, to find the lexicographically biggest string, you need to experience two phases:

1. Concatenate all the strings into a loop, where you can reverse some strings or not and connect them in the same order as given.
2. Cut and make one breakpoint in any place of the loop, which will make the looped string into a regular one starting from the character at the cutpoint.


And your job is to find the lexicographically biggest one among all the possible regular strings.


**Example:**

<pre>
Input: "abc", "xyz"
Output: "zyxcba"
Explanation: You can get the looped string "-abcxyz-", "-abczyx-", "-cbaxyz-", "-cbazyx-", 
where '-' represents the looped status. 
The answer string came from the fourth looped one, 
where you could cut from the middle character 'a' and get "zyxcba".
</pre>


**Note:**


1. The input strings will only contain lowercase letters.
2. The total length of all the strings will not over 1,000.


## 557. Reverse Words in a String III


题目描述:

Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

**Example 1:**

<pre>
Input: "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
</pre>

**Note:** In the string, each word is separated by single space and there will not be any extra space in the string.

解答:

```php
class Solution 
{

    /**
     * @param String $s
     * @return String
     */
    function reverseWords($s) 
    {
        $parts = explode(' ', $s);
        $result = [];
        foreach ($parts as $piece) {
            $result[] = strrev($piece);
        }
        return implode(' ', $result);
    }
}
```

效果:

> 执行用时 : 8 ms, 在Reverse Words in a String III的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 15.3 MB, 在Reverse Words in a String III的PHP提交中击败了 11.11% 的用户

这个可读性还是比较好的.

## 566. Reshape the Matrix

题目描述:

In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.

You're given a matrix represented by a two-dimensional array, and two **positive** integers **row** and **column** representing the row number and column number of the wanted reshaped matrix, respectively.

The reshaped matrix need to be filled with all the elements of the original matrix in the same **row-traversing** order as they were.

If the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.

**Example 1:**

<pre>
<strong>Input:</strong>
nums =
[[1,2],
 [3,4]]
row = 1, column = 4
<strong>Output:</strong>
[[1,2,3,4]]
<strong>Explanation:</strong>
The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.
</pre>

**Example 2:**

<pre>
<strong>Input:</strong>
nums =
[[1,2],
 [3,4]]
row = 2, column = 4
<strong>Output:</strong>
[[1,2],
 [3,4]]
<strong>Explanation:</strong>
There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.
</pre>

**Note:**

1. The height and width of the given matrix is in range [1, 100].
2. The given row and column are all positive.

解答:

```php
class Solution 
{

    /**
     * @param Integer[][] $nums
     * @param Integer $row
     * @param Integer $column
     * @return Integer[][]
     */
    function matrixReshape($nums, $row, $column)
    {
        $flattened_array = array_merge(...$nums);
        if (count($flattened_array) !== $row * $column) {
            return $nums;
        }
        if ($row === 1) {
            return [$flattened_array];
        }
        
        return array_chunk($flattened_array, $column);
    }
}
```

效果:

> 执行用时: 44 ms, 在所有 PHP 提交中击败了 73.33% 的用户
> 
> 内存消耗: 19.5 MB, 在所有 PHP 提交中击败了 100.00% 的用户

注意: 无论如何, 结果都是一个二维数组. 当时没仔细看第一个用例, 结果他妈悲剧了, 在本地还能跑, `var_dump()` 把 `$nums`、`$flattened_array` 都 dump 了一遍还都能 dump 出来数, 所以就没想到返回的东西有问题. 然后我还老在那儿想, 为啥老提示我:

> ...Line 7: PHP Fatal error:  Uncaught TypeError: Argument 1 passed to Serializer::serializeArray() must be of the type array, integer given...

...

再一个是, `$nums = [[1,2],[3,4]], $row = 4, $column = 1` 的时候, 理论上应该返回 `[[1],[2],[3],[4]]`. 当然如果能注意到第一点, 以及第一个示例返回 `[[1,2,3,4]]` 的话, 你会觉着这种外层套内层的结果是很自然的, 体现了二维的特点, 不需要考虑 `$column === 1` 的情形.



## 568. Maximum Vacation Days (上锁题目, 需要氪会员)

题目描述:

LeetCode wants to give one of its best employees the option to travel among **N** cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow.

**Rules and restrictions:**

1. You can only travel among **N** cities, represented by indexes from 0 to N-1. Initially, you are in the city indexed 0 on Monday.
2. The cities are connected by flights. The flights are represented as a **N×N** matrix (not necessary symmetrical), called **flights** representing the airline status from the city i to the city j. If there is no flight from the city i to the city j, **flights[i][j] = 0**; Otherwise, **flights[i][j] = 1**. Also, **flights[i][i] = 0** for all i.
3. You totally have **K** weeks (**each week has 7 days**) to travel. You can only take flights at most once **per day** and can only take flights on each week's **Monday** morning. Since flight time is so short, we don't consider the impact of flight time.
4. For each city, you can only have restricted vacation days in different weeks, given an **N×K** matrix called **days** representing this relationship. For the value of **days[i][j]**, it represents the maximum days you could take vacation in the city **i** in the week **j**.


You're given the **flights** matrix and **days** matrix, and you need to output the maximum vacation days you could take during **K** weeks.

**Example 1:**

<pre>
<strong>Input:</strong> flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]]
<strong>Output:</strong> 12
<strong>Explanation:</strong> 
Ans = 6 + 3 + 3 = 12. 

One of the best strategies is:
1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day. 
(Although you start at city 0, we could also fly to and start at other cities since it is Monday.) 
2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.
3rd week : stay at city 2, and play 3 days and work 4 days.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
Ans = 1 + 1 + 1 = 3. 

Since there is no flights enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. 
For each week, you only have one day to play and six days to work. 
So the maximum number of vacation days is 3.
</pre>



**Example 3:**


<pre>
<strong>Input:</strong> flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]]
<strong>Output:</strong> 21
<strong>Explanation:</strong>
Ans = 7 + 7 + 7 = 21

One of the best strategies is:
1st week : stay at city 0, and play 7 days. 
2nd week : fly from city 0 to city 1 on Monday, and play 7 days.
3rd week : fly from city 1 to city 2 on Monday, and play 7 days.
</pre>


**Note:**

1. **N and K** are positive integers, which are in the range of [1, 100].
2. In the matrix **flights**, all the values are integers in the range of [0, 1].
3. In the matrix **days**, all the values are integers in the range [0, 7].
4. You could stay at a city beyond the number of vacation days, but you should **work** on the extra days, which won't be counted as vacation days.
5. If you fly from the city A to the city B and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city B in that week.
6. We don't consider the impact of flight hours towards the calculation of vacation days.


## 581. Shortest Unsorted Continuous Subarray

题目描述:

Given an integer array, you need to find one **continuous subarray** that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.

You need to find the **shortest** such subarray and output its length.

**Example 1:**

<pre>
<strong>Input:</strong> [2, 6, 4, 8, 10, 9, 15]
<strong>Output:</strong> 5
<strong>Explanation:</strong> You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
</pre>

**Note:**

1. Then length of the input array is in range [1, 10,000].
2. The input array may contain duplicates, so ascending order here means **<=**.


解答:

```php
class Solution
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findUnsortedSubarray($nums)
    {
        $copy = $nums;
        $count = count($nums);
        sort($nums, SORT_NUMERIC);
        // 注意砍掉原来数组本身就有序的情形.
        if ($copy === $nums) {
            return 0;
        }
        for ($start = 0; $start < $count; $start++) {
            if ($nums[$start] !== $copy[$start]) {
                break;
            }
        }
        for ($end = $count - 1; $end >= 0; $end--) {
            if ($nums[$end] !== $copy[$end]) {
                break;
            }
        }
        return $end - $start + 1;
    }
}
```


效果:

> 执行用时: 108 ms, 在所有 PHP 提交中击败了 61.54% 的用户
>
> 内存消耗: 16.2 MB, 在所有 PHP 提交中击败了 100.00% 的用户


直接糙快猛地上去干就可以了. 可读性和资源消耗都还不错.

## 594. Longest Harmonious Subsequence

题目描述:

We define a harmounious array as an array where the difference between its maximum value and its minimum value is **exactly** 1.

Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible [subsequences](https://en.wikipedia.org/wiki/Subsequence).

**Example 1:**

<pre>
<strong>Input:</strong> [1,3,2,2,5,2,3,7]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The longest harmonious subsequence is [3,2,2,2,3].
</pre>

**Note:** The length of the input array will not exceed 20,000.


解答: 

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findLHS($nums) 
    {
        $nums_info = array_count_values($nums);
        $keys = array_keys($nums_info);
        $lhs_length_array = [0];
        foreach ($keys as $num) {
            if (in_array($num + 1, $keys)) {
                $lhs_length_array[] = ($nums_info[$num] + $nums_info[$num + 1]);
            }
        }
        return max($lhs_length_array);
    }
}
```

效果:

> 执行用时: 1156 ms, 在所有 PHP 提交中击败了 25.00% 的用户
> 
> 内存消耗: 16.3 MB, 在所有 PHP 提交中击败了 100.00% 的用户

在咖啡店里写的, 可能那边儿网不好, 提交的时候一直比较卡, 不知道对他们服务器端程序响应请求有没有什么影响😂总之虽然慢了点儿, 但是确实慢不到哪儿去, 大家写得都大同小异. 

这个 subsequence 按照数列方面的那个子列理解就行. 数列学过吧. 别告诉我居然没学过数列😂


## 598. Range Addition II

题目描述:

Given an m * n matrix **M** initialized with all **0**'s and several update operations.

Operations are represented by a 2D array, and each operation is represented by an array with two **positive** integers **a** and **b**, which means **M[i][j]** should be **added by one** for all **0 <= i < a** and **0 <= j < b**.

You need to count and return the number of maximum integers in the matrix after performing all the operations.

**Example 1:**

<pre>
<strong>Input:</strong> 
m = 3, n = 3
operations = [[2,2],[3,3]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
Initially, M = 
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]

After performing [2,2], M = 
[[1, 1, 0],
 [1, 1, 0],
 [0, 0, 0]]

After performing [3,3], M = 
[[2, 2, 1],
 [2, 2, 1],
 [1, 1, 1]]

So the maximum integer in M is 2, and there are four of it in M. So return 4.
</pre>


**Note:**

1. The range of m and n is [1,40000].
2. The range of a is [1,m], and the range of b is [1,n].
3. The range of operations size won't exceed 10,000.



解答:

```php
class Solution 
{

    /**
     * @param Integer $m
     * @param Integer $n
     * @param Integer[][] $ops
     * @return Integer
     */
    function maxCount($m, $n, $ops) 
    {
        if (empty($ops)) {
            return $m * $n;
        }
        $min_width = min(array_column($ops, 0));
        $min_height = min(array_column($ops, 1));
        return $min_width * $min_height;
    }
}
```


效果:

> 执行用时: 28 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 23.3 MB, 在所有 PHP 提交中击败了 100.00% 的用户


这个题目的要点一个是一顿操作猛如虎之后值最大的那些元素所在区域只可能是在矩阵的左上角. 所以你很自然就要去找最小长和最小宽.

再一个要点是如果传进来的操作数组为空的话, 那么也就意味着不进行任何操作. 这时候应当返回原矩阵数组的容量.


## 599. Minimum Index Sum of Two Lists

题目描述:


Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.

You need to help them find out their **common interest** with the **least list index sum**. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.

**Example 1:**


<pre>
<strong>Input:</strong>
["Shogun", "Tapioca Express", "Burger King", "KFC"]
["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]
<strong>Output:</strong> ["Shogun"]
<strong>Explanation:</strong> The only restaurant they both like is "Shogun".
</pre>


**Example 2:**


<pre>
<strong>Input:</strong>
["Shogun", "Tapioca Express", "Burger King", "KFC"]
["KFC", "Shogun", "Burger King"]
<strong>Output:</strong> ["Shogun"]
<strong>Explanation:</strong> The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).
</pre>


**Note:**

1. The length of both lists will be in the range of [1, 1000].
2. The length of strings in both lists will be in the range of [1, 30].
3. The index is starting from 0 to the list length minus 1.
4. No duplicates in both lists.


解答:

```php
class Solution 
{

    /**
     * @param String[] $list1
     * @param String[] $list2
     * @return String[]
     */
    function findRestaurant($list1, $list2) 
    {
        $intersection = array_intersect($list1, $list2);
        $index_sum_array = array_map($callable = function ($restaurant) use ($list1, $list2) {
            return array_search($restaurant, $list1) + array_search($restaurant, $list2);
        }, $intersection);
        $least_index_sum = min($index_sum_array);
        $least_index_sum_positions = array_keys($index_sum_array, $least_index_sum);
        $common_favorites_with_least_index_sum = [];
        foreach ($least_index_sum_positions as $position) {
            $common_favorites_with_least_index_sum[] = $intersection[$position];
        }
        return $common_favorites_with_least_index_sum;
    }
}
```

效果:

> 执行用时 : 88 ms, 在所有 PHP 提交中击败了 50.00% 的用户
> 
> 内存消耗 : 15.3 MB, 在所有 PHP 提交中击败了 33.33% 的用户


直接按照题目意思糙快猛地往上写就可以了...好像也没法写出什么花来...

另外烧死所有异性恋!!!


## 604. Design Compressed String Iterator (上锁题目, 需要氪会员)


题目描述:


Design and implement a data structure for a compressed string iterator. It should support the following operations: `next` and `hasNext`.

The given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string.

`next()` - if the original string still has uncompressed characters, return the next letter; Otherwise return a white space.
`hasNext()` - Judge whether there is any letter needs to be uncompressed.

**Note:**

Please remember to **RESET** your class variables declared in StringIterator, as static/class variables are **persisted across multiple test cases**. Please see [here](https://support.leetcode.com/hc/en-us/sections/360002895993-Technical-Questions) for more details.

**Example:**

<pre>
StringIterator iterator = new StringIterator("L1e2t1C1o1d1e1");

iterator.next(); // return 'L'
iterator.next(); // return 'e'
iterator.next(); // return 'e'
iterator.next(); // return 't'
iterator.next(); // return 'C'
iterator.next(); // return 'o'
iterator.next(); // return 'd'
iterator.hasNext(); // return true
iterator.next(); // return 'e'
iterator.hasNext(); // return false
iterator.next(); // return ' '
</pre>


## 610. Triangle Judgement


A pupil Tim gets homework to identify whether three line segments could possibly form a triangle.


However, this assignment is very heavy because there are hundreds of records to calculate.


Could you help Tim by writing a query to judge whether these three sides can form a triangle, assuming table **triangle** holds the length of the three sides x, y and z.


<pre>
| x  | y  | z  |
|----|----|----|
| 13 | 15 | 30 |
| 10 | 20 | 15 |
</pre>


For the sample data above, your query should return the follow result:

<pre>
| x  | y  | z  | triangle |
|----|----|----|----------|
| 13 | 15 | 30 | No       |
| 10 | 20 | 15 | Yes      |
</pre>



## 620. Not Boring Movies

题目描述:

SQL 架构:

```sql
Create table If Not Exists cinema (id int, movie varchar(255), description varchar(255), rating float(2, 1))
Truncate table cinema
insert into cinema (id, movie, description, rating) values ('1', 'War', 'great 3D', '8.9')
insert into cinema (id, movie, description, rating) values ('2', 'Science', 'fiction', '8.5')
insert into cinema (id, movie, description, rating) values ('3', 'irish', 'boring', '6.2')
insert into cinema (id, movie, description, rating) values ('4', 'Ice song', 'Fantacy', '8.6')
insert into cinema (id, movie, description, rating) values ('5', 'House card', 'Interesting', '9.1')
```

X city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies’ ratings and descriptions.
Please write a SQL query to output movies with an odd numbered ID and a description that is not 'boring'. Order the result by rating.

 

For example, table `cinema`:


<pre>
+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+
</pre>


For the example above, the output should be:

<pre>
+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+
</pre>

解答1:

```sql
# Write your MySQL query statement below
SELECT * FROM `cinema` WHERE `description` != 'boring' AND mod(`id`, 2) = 1 ORDER BY `rating` DESC;
```


效果1:

> 执行用时 : 214 ms, 在所有 MySQL 提交中击败了 83.35% 的用户
> 
> 内存消耗 : N/A

解答2:

```sql
# Write your MySQL query statement below
SELECT * FROM `cinema` WHERE `description` != 'boring' AND `id` % 2 = 1 ORDER BY `rating` DESC;
```

效果2:

> 执行用时 : 215 ms, 在所有 MySQL 提交中击败了 82.49% 的用户
> 
> 内存消耗 : N/A


平时主要是依赖框架 CRUD, 查询技巧还得多练习练习...

你这字段全用, 所以直接 SELECT * 就可以.

## 624. Maximum Distance in Arrays (上锁题目, 需要氪会员)

题目描述:

Given `m` arrays, and each array is sorted in ascending order. Now you can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers `a` and `b` to be their absolute difference `|a-b|`. Your task is to find the maximum distance.

**Example 1:**


<pre>
<strong>Input:</strong> 
[[1,2,3],
 [4,5],
 [1,2,3]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> 
One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.
</pre>

**Note:**

1. Each given array will have at least 1 number. There will be at least two non-empty arrays.
2. The total number of the integers in **all** the `m` arrays will be in the range of [2, 10000].
3. The integers in the `m` arrays will be in the range of [-10000, 10000].

## 628. Maximum Product of Three Numbers

题目描述:

Given an integer array, find three numbers whose product is maximum and output the maximum product.

**Example 1:**

<pre>
Input: [1,2,3]
Output: 6
</pre>


**Example 2:**

<pre>
Input: [1,2,3,4]
Output: 24
</pre>


**Note:**


1. The length of the given array will be in range [3,10<sup>4</sup>] and all elements are in the range [-1000, 1000].
2. Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.


解答:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function maximumProduct($nums) 
    {
        sort($nums, SORT_NUMERIC);
        $count = count($nums);
        // 升序排列后, 三个数的最大乘积只能是以下两种情况之一:
        // 1. 两个最小的和一个最大的相乘(比如两个挺大的负的带一个正的)
        // 2. 三个最大的相乘(比如全是正数、全是非正数)
        return max($nums[0] * $nums[1] * $nums[$count - 1], $nums[$count - 3] * $nums[$count - 2] * $nums[$count - 1]);
    }
}
```


效果:

> 执行用时 : 148 ms, 在所有PHP提交中击败了 75.00% 的用户
> 
> 内存消耗 : 15.9 MB, 在所有PHP提交中击败了 16.67% 的用户


## 633. Sum of Square Numbers

Given a non-negative integer `c`, your task is to decide whether there're two integers `a` and `b` such that a<sup>2</sup> + b<sup>2</sup> = `c`.

**Example 1:**


<pre>
<strong>Input:</strong> 5
<strong>Output:</strong> True
<strong>Explanation:</strong> 1 * 1 + 2 * 2 = 5
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> 3
<strong>Output:</strong> False
</pre>


解答:

```php
class Solution 
{

    /**
     * @param Integer $c
     * @return Boolean
     */
    function judgeSquareSum($c) 
    {
        $sqrt_of_c = floor(sqrt($c));
        for ($i = 0; $i <= $sqrt_of_c; $i++) {
            if (floor(sqrt($c - $i * $i)) == sqrt($c - $i * $i)) {
                return true;
            }
        }
        return false;
    }
}
```

效果:

> 执行用时 : 40 ms, 在所有 PHP 提交中击败了 58.33% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


## 634. Find the Derangement of An Array (上锁题目, 需要氪会员)


题目描述: 


In combinatorial mathematics, a derangement is a permutation of the elements of a set, such that no element appears in its original position.

There's originally an array consisting of `n` integers from `1` to `n` in ascending order, you need to find the number of derangement it can generate.

Also, since the answer may be very large, you should return the output mod 10<sup>9</sup> + 7.

**Example 1:**

<pre>
Input: 3
Output: 2
Explanation: The original array is [1,2,3]. The two derangements are [2,3,1] and [3,1,2].
</pre>


**Note:**


`n` is in the range of [1, 10<sup>6</sup>].



## 645. Set Mismatch


题目描述:

The set `S` originally contains numbers from 1 to `n`. But unfortunately, due to the data error, one of the numbers in the set got duplicated to `another` number in the set, which results in repetition of one number and loss of another number.

Given an array `nums` representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.

**Example 1:**


<pre>
<strong>Input:</strong> nums = [1,2,2,4]
<strong>Output:</strong> [2,3]
</pre>



**Note:**

1. The given array size will in the range [2, 10000].
2. The given array's numbers won't have any order.



解答1:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function findErrorNums($nums) 
    {
        $count = count($nums);
        $range = range(1, $count);
        $unique = array_unique($nums);
        $range_sum = array_sum($range);
        $nums_sum = array_sum($nums);
        $unique_sum = array_sum($unique);
        return [$nums_sum - $unique_sum, $range_sum - $unique_sum];
    }
}
```

效果1:

> 执行用时 : 76 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 16.8 MB, 在所有 PHP 提交中击败了 50.00% 的用户



解答2:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function findErrorNums($nums) 
    {
        $count = count($nums);
        $range = range(1, $count);
        $unique = array_unique($nums);
        return array_merge(array_diff_assoc($nums, $unique), array_diff($range, $unique));
    }
}
```


效果2:

> 执行用时 : 100 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 17.4 MB, 在所有 PHP 提交中击败了 50.00% 的用户


解法1还可以优化的点就是用等差数列求和公式把`$range_sum = array_sum($range);`改写成`$range_sum = $count * ($count + 1) / 2;`

主要是了解一维数组获取重复值时`array_unique()`函数与`array_diff_assoc()`函数的联动.



看一下手册:

array_unique()函数说明:

```php
array_unique ( array $array [, int $sort_flags = SORT_STRING ] ) : array
```


**array_unique()** 接受 **array** 作为输入并返回没有重复值的新数组。

注意键名保留不变。**array_unique()** 先将值作为字符串排序，然后对每个值只保留第一个遇到的键名，接着忽略所有后面的键名。这并不意味着在未排序的 **array** 中同一个值的第一个出现的键名会被保留。

<pre>
<strong>Note:</strong> 当且仅当 <em>(string) $elem1 === (string) $elem2</em> 时两个单元被认为相同。 例如，字符串表达一样时，会使用首个元素。
</pre>

array_unique()参数解释:

**array** - 输入的数组。

**sort_flags** - 第二个可选参数**sort_flags** 可用于修改排序行为：

  排序类型标记：

  * **SORT_REGULAR** - 按照通常方法比较（不修改类型）
  * **SORT_NUMERIC** - 按照数字形式比较
  * **SORT_STRING** - 按照字符串形式比较
  * **SORT_LOCALE_STRING** - 根据当前的本地化设置，按照字符串比较。

array_unique()返回值:

返回过滤后的数组。

---


array_diff_assoc()函数说明:


```php
array_diff_assoc ( array $array1 , array $array2 [, array $... ] ) : array
```


**array_diff_assoc()** 返回一个数组，该数组包括了所有在 **array1** 中但是不在任何其它参数数组中的值。注意和 [array_diff()](https://www.php.net/manual/zh/function.array-diff.php) 不同的是键名也用于比较。


array_diff_assoc()参数解释:

**array1** - 从这个数组进行比较

**array2** - 被比较的数组

**...** - 更多被比较的数组

array_diff_assoc()返回值:

返回一个[数组](https://www.php.net/manual/zh/language.types.array.php), 该数组包括了所有在 **array1** 中但是不在任何其它参数数组中的值.


## 660. Remove 9 (上锁题目, 需要氪会员)


题目描述:

Start from integer 1, remove any integer that contains 9 such as 9, 19, 29...


So now, you will have a new integer sequence: 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...


Given a positive integer `n`, you need to return the `n`-th integer after removing. Note that `1` will be the first integer.

**Example 1:**

<pre>
Input: 9
Output: 10
</pre>


**Hint:** `n` will not exceed `9 x 10^8`.




## 672. Bulb Switcher II


题目描述:



There is a room with `n` lights which are turned on initially and 4 buttons on the wall. After performing exactly `m` unknown operations towards buttons, you need to return how many different kinds of status of the `n` lights could be.

Suppose `n` lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:

1. Flip all the lights.
2. Flip lights with even numbers.
3. Flip lights with odd numbers.
4. Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...


**Example 1:**

<pre>
Input: n = 1, m = 1.
Output: 2
Explanation: Status can be: [on], [off]
</pre>


**Example 2:**

<pre>
Input: n = 2, m = 1.
Output: 3
Explanation: Status can be: [on, off], [off, on], [off, off]
</pre>


**Example 3:**

<pre>
Input: n = 3, m = 1.
Output: 4
Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].
</pre>


**Note:** `n` and `m` both fit in range [0, 1000].


解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @param Integer $m
     * @return Integer
     */
    function flipLights($n, $m) 
    {
        $n = min($n, 3);
        if ($m == 0) {
            return 1;
        }
        if ($m == 1) {
            return $n == 1 ? 2 : ($n == 2 ? 3 : 4);
        }
        if ($m == 2) {
            return $n == 1 ? 2 : ($n == 2 ? 4 : 7);
        }
        return $n == 1 ? 2 : ($n == 2 ? 4 : 8);
    }
}
```


效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.7 MB, 在所有 PHP 提交中击败了 100.00% 的用户



<!--
前六盏灯唯一确定了剩下的灯的状态. 这是因为每个对第*x*盏灯进行的操作, 也必然会对第(*x* + 6)盏灯进行调整, 从而第*x*盏灯总是和第(*x* + 6)盏灯等价.

然而实际上呢, 你光前三盏灯就可以唯一确定灯开关状态序列的剩下部分. 如果将题目里1、2、3、4这四种操作分别对应到a、b、c、d这四种操作, 那么四个操作都来一轮的话则有:

* 灯1 = 1 + a + c + d;
* 灯2 = 1 + a + b;
* 灯3 = 1 + a + c;
* 灯4 = 1 + a + b + d;
* 灯5 = 1 + a + c;
* 灯6 = 1 + a + b;-->




## 680. Valid Palindrome II

题目描述:

Given a non-empty string `s`, you may delete **at most** one character. Judge whether you can make it a palindrome.

**Example 1:**

<pre>
Input: "aba"
Output: True
</pre>

**Example 2:**

<pre>
Input: "abca"
Output: True
Explanation: You could delete the character 'c'.
</pre>

**Note:**

1. The string will only contain lowercase characters a-z. The maximum length of the string is 50000.

解答:

```php
class Solution 
{
    
    /**
     * @param String $s
     * @param Integer $left
     * @param Integer $right
     * @return Boolean
     */
    static private function isPalindrome($s, $left, $right) 
    {
        while ($left < $right) {
            if ($s[$left] == $s[$right]) {
                $left++;
                $right--;
            } else {
                return false;
            }
        }
        return true;
    }

    /**
     * @param String $s
     * @return Boolean
     */
    function validPalindrome($s) 
    {
        $left = 0;
        $right = strlen($s) - 1;
        while ($left < $right) {
            if ($s[$left] == $s[$right]) {
                $left++;
                $right--;
            } else {
                break;
            }
        }
        if ($left >= $right) {
            return true;
        }
        return self::isPalindrome($s, $left + 1, $right) || self::isPalindrome($s, $left, $right - 1);
    }
    
}
```

效果:

> 执行用时 : 60 ms, 在Valid Palindrome II的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 15 MB, 在Valid Palindrome II的PHP提交中击败了 100.00% 的用户



## 686. Repeated String Match



题目描述:


Given two strings str1 and str2, find the minimum number of times str1 has to be repeated such that str2 is a substring of it. If no such solution, return -1.

For example, with str1 = "abcd" and str2 = "cdabcdab".

Return 3, because by repeating str1 three times (“abcdabcdabcd”), str2 is a substring of it; and str2 is not a substring of str1 repeated two times ("abcdabcd").

Note:
The length of `str1` and `str2` will be between 1 and 10000.


解答:

```php
class Solution 
{

    /**
     * @param String $str1
     * @param String $str2
     * @return Integer
     */
    function repeatedStringMatch($str1, $str2) 
    {
        $str1len = strlen($str1);
        $str2len = strlen($str2);
        $multiplier = floor($str2len / $str1len);
        // 几个小的刚好能拼成大的的情形.
        if (strpos(str_repeat($str1, $multiplier), $str2) !== false) {
            return $multiplier;
        }
        // 需要在基准乘数的基础上从头部或从尾部再追加一个小的才能拼成大的的情形.
        if (strpos(str_repeat($str1, $multiplier + 1), $str2) !== false) {
            return $multiplier + 1;
        }
        // 需要在基准乘数的基础上从头部和尾部各追加一个小的才能拼成大的的情形.
        if (strpos(str_repeat($str1, $multiplier + 2), $str2) !== false) {
            return $multiplier + 2;
        }
        return -1;
    }
}
```


效果:

> 执行用时 : 152 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


## 692. Top K Frequent Words


题目描述:

Given a non-empty list of words, return the *k* most frequent elements.

Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.

**Example 1:**


<pre>
<strong>Input:</strong> ["i", "love", "leetcode", "i", "love", "coding"], k = 2
<strong>Output:</strong> ["i", "love"]
<strong>Explanation:</strong> "i" and "love" are the two most frequent words.
    Note that "i" comes before "love" due to a lower alphabetical order.
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
<strong>Output:</strong> ["the", "is", "sunny", "day"]
<strong>Explanation:</strong> "the", "is", "sunny" and "day" are the four most frequent words,
    with the number of occurrence being 4, 3, 2 and 1 respectively.
</pre>


**Note:**

1. You may assume *k* is always valid, 1 ≤ *k* ≤ number of unique elements.
2. Input words contain only lowercase letters.


**Follow up:**

1. Try to solve it in *O*(*n* log *k*) time and *O*(*n*) extra space.


解答1:


```php
class Solution 
{

    /**
     * @param String[] $words
     * @param Integer $k
     * @return String[]
     */
    function topKFrequent($words, $k) 
    {
        // 词频统计. 获取单词数组中单词-出现频数键值关联数组.
        $wordFrequencyCount = array_count_values($words);
        // 根据频数大小从高到低降序排列.
        arsort($wordFrequencyCount, SORT_NUMERIC);
        // 获取出现频率的所有不同值.
        $uniqueOccurrence = array_unique(array_values($wordFrequencyCount));
        // 将出现频数相同的单词整理出来, 排序, 再合并到大的数组里.
        $sortedWordCollection = [];
        foreach ($uniqueOccurrence as $occurrence) {
            $wordWithSpecificFrequency = [];
            foreach ($wordFrequencyCount as $word => $frequency) {
                if ($frequency === $occurrence) {
                    $wordWithSpecificFrequency[] = $word;
                }
            }
            natsort($wordWithSpecificFrequency);
            $sortedWordCollection = array_merge($sortedWordCollection, $wordWithSpecificFrequency);
        }
        return array_slice($sortedWordCollection, 0, $k);
    }
}
```


效果1:

> 执行用时 : 20 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.8 MB, 在所有 PHP 提交中击败了 100.00% 的用户


解答2:

```php
class Solution 
{

    /**
     * @param String[] $words
     * @param Integer $k
     * @return String[]
     */
    function topKFrequent($words, $k) 
    {
        // 词频统计. 获取单词数组中单词-出现频数键值关联数组.
        $wordFrequencyCount = array_count_values($words);
        $sortedWords = array_keys($wordFrequencyCount);
        // PHP是最好的语言!!!
        usort($sortedWords, $comparator = function ($word1, $word2) use ($wordFrequencyCount) {
            if ($wordFrequencyCount[$word1] > $wordFrequencyCount[$word2]) {
                return -1;
            } elseif ($wordFrequencyCount[$word1] < $wordFrequencyCount[$word2]) {
                return 1;
            } else {
                return strcmp($word1, $word2);
            }
        });
        return array_slice($sortedWords, 0, $k);
    }
}
```


效果2:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.8 MB, 在所有 PHP 提交中击败了 100.00% 的用户


前面的347. Top K Frequent Elements的加难版. 想法看起来是比较直接, 就是实现比较费事儿...我记得Objective-C里好像有那种子排序的方法, 就比如你有个人员-部门-薪资的列表, 你先按照部门排序, 每个部门再按照薪资排序这种的. PHP目前还没找到, 应该是个比较常见的需求.

解法2用到了“<a href="https://www.php.net/manual/zh/functions.anonymous.php">闭包可以从父作用域中继承变量。 任何此类变量都应该用 <em>use</em> 语言结构传递进去</a>”的特性. 以前确实不怎么用...今天突然福至心灵想到了😂. 现在再回头看手册里的这个**Example #4 Closures 和作用域**能看懂了...

再就参考一下973. K Closest Points to Origin, 也是使用回调函数干出产值的那种题.

## 693. Binary Number with Alternating Bits

题目描述:

Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.

**Example 1:**

<pre>
Input: 5
Output: True
Explanation:
The binary representation of 5 is: 101
</pre>


**Example 2:**

<pre>
Input: 7
Output: False
Explanation:
The binary representation of 7 is: 111.
</pre>


**Example 3:**

<pre>
Input: 11
Output: False
Explanation:
The binary representation of 11 is: 1011.
</pre>


**Example 4:**

<pre>
Input: 10
Output: True
Explanation:
The binary representation of 10 is: 1010.
</pre>

解答:

```php
class Solution {

    /**
     * @param Integer $n
     * @return Boolean
     */
    function hasAlternatingBits($n) 
    {
        $binStr = decbin($n);
        return (strpos($binStr, '00') === false) && (strpos($binStr, '11') === false);
    }
}
```

效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 71.43% 的用户



## 697. Degree of an Array


题目描述:


Given a non-empty array of non-negative integers `nums`, the **degree** of this array is defined as the maximum frequency of any one of its elements.

Your task is to find the smallest possible length of a (contiguous) subarray of `nums`, that has the same degree as `nums`.

**Example 1:**


<pre>
<strong>Input:</strong> [1, 2, 2, 3, 1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> [1,2,2,3,1,4,2]
<strong>Output:</strong> 6
</pre>

**Note:**

* `nums.length` will be between 1 and 50,000.
* `nums[i]` will be an integer between 0 and 49,999.



解答:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function findShortestSubArray($nums) 
    {
        $valueInfo = array_count_values($nums);
        $maxOccurrence = max($valueInfo);
        if ($maxOccurrence == 1) {
            return 1;
        }
        // 考虑具有多个出现频率最高元素的情况.
        $candidates = [];
        foreach ($valueInfo as $num => $count) {
            if ($count == $maxOccurrence) {
                $candidates[] = $num;
            }
        }
        $minLengthArray = [];
        foreach ($candidates as $candidate) {
            $positions = array_keys($nums, $candidate);
            $minLengthArray[] = max($positions) - min($positions) + 1;
        }
        return min($minLengthArray);
    }
}
```


效果:

> 执行用时 : 80 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 19.1 MB, 在所有 PHP 提交中击败了 100.00% 的用户


看了一眼别人写的, 至少我这个代码风格还是可以的. 大多数人写的我完全都不想看...

这个需要注意考虑有多个元素出现了最大频数的情形, 这个第一个示例告诉你要注意这个. 不过可能写着写着就给忘了😂感觉好长时间之前我写了一半没写完, 然后就给扔那了, 但还是一遍过了😂

## 709. To Lower Case

题目描述:


Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.

 

**Example 1:**


<pre>
Input: "Hello"
Output: "hello"
</pre>


**Example 2:**


<pre>
Input: "here"
Output: "here"
</pre>


**Example 3:**


<pre>
Input: "LOVELY"
Output: "lovely"
</pre>


解答:

```php
class Solution 
{

    /**
     * @param String $str
     * @return String
     */
    function toLowerCase($str) 
    {
        // PHP是最好的语言!
        return strtolower($str);
    }
}
```

效果:

> 执行用时 : 0 ms, 在To Lower Case的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在To Lower Case的PHP提交中击败了 69.64% 的用户


## 724. Find Pivot Index

题目描述:


Given an array of integers `nums`, write a method that returns the "pivot" index of this array.

We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.

If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.

**Example 1:**


<pre>
<strong>Input:</strong>
nums = [1, 7, 3, 6, 5, 6]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.
Also, 3 is the first index where this occurs.
</pre>

**Example 2:**

<pre>
<strong>Input:</strong>
nums = [1, 2, 3]
<strong>Output:</strong> -1
<strong>Explanation:</strong> 
There is no index that satisfies the conditions in the problem statement.
</pre>

**Note:**

* The length of `nums` will be in the range `[0, 10000]`.
* Each element `nums[i]` will be an integer in the range `[-1000, 1000]`.



解答1:


```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function pivotIndex($nums) 
    {
        $nums_sum = array_sum($nums);
        if (empty($nums)) {
            return -1;
        }
        $nums_count = count($nums);
        for ($i = 0; $i < $nums_count; $i++) {
            $slice = array_slice($nums, 0, $i);
            if (array_sum($slice) * 2 == ($nums_sum - $nums[$i])) {
                return $i;
            }
        }
        return -1;
    }
}
```


效果1:

> 执行用时 : 2304 ms, 在所有 PHP 提交中击败了 5.13% 的用户
> 
> 内存消耗 : 16.2 MB, 在所有 PHP 提交中击败了 10.00% 的用户


解答2:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function pivotIndex($nums) 
    {
        $nums_sum = array_sum($nums);
        if (empty($nums)) {
            return -1;
        }
        $nums_count = count($nums);
        $left_sum = 0;
        for ($i = 0; $i < $nums_count; $i++) {
            if ($left_sum * 2 == ($nums_sum - $nums[$i])) {
                return $i;
            }
            $left_sum += $nums[$i];
        }
        return -1;
    }
}
```

效果2:

> 执行用时 : 60 ms, 在所有 PHP 提交中击败了 94.87% 的用户
> 
> 内存消耗 : 16 MB, 在所有 PHP 提交中击败了 10.00% 的用户

这个部分和其实可以设个变量一点点儿加...



## 728. Self Dividing Numbers

题目描述:


A *self-dividing* number is a number that is divisible by every digit it contains.

For example, 128 is a self-dividing number because `128 % 1 == 0`, `128 % 2 == 0`, and `128 % 8 == 0`.

Also, a self-dividing number is not allowed to contain the digit zero.

Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.

**Example 1:**


<pre>
Input: 
left = 1, right = 22
Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
</pre>


**Note:**


* The boundaries of each input argument are `1 <= left <= right <= 10000`.


解答1:

```php
class Solution 
{

    /**
     * @param Integer $left
     * @param Integer $right
     * @return Integer[]
     */
    function selfDividingNumbers($left, $right) 
    {
        $self_dividing_number_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22, 24, 33, 36, 44, 48, 55, 66, 77, 88, 99, 111, 112, 115, 122, 124, 126, 128, 132, 135, 144, 155, 162, 168, 175, 184, 212, 216, 222, 224, 244, 248, 264, 288, 312, 315, 324, 333, 336, 366, 384, 396, 412, 424, 432, 444, 448, 488, 515, 555, 612, 624, 636, 648, 666, 672, 728, 735, 777, 784, 816, 824, 848, 864, 888, 936, 999, 1111, 1112, 1113, 1115, 1116, 1122, 1124, 1128, 1131, 1144, 1155, 1164, 1176, 1184, 1197, 1212, 1222, 1224, 1236, 1244, 1248, 1266, 1288, 1296, 1311, 1326, 1332, 1335, 1344, 1362, 1368, 1395, 1412, 1416, 1424, 1444, 1448, 1464, 1488, 1515, 1555, 1575, 1626, 1632, 1644, 1662, 1692, 1715, 1722, 1764, 1771, 1824, 1848, 1888, 1926, 1935, 1944, 1962, 2112, 2122, 2124, 2128, 2136, 2144, 2166, 2184, 2196, 2212, 2222, 2224, 2226, 2232, 2244, 2248, 2262, 2288, 2316, 2322, 2328, 2364, 2412, 2424, 2436, 2444, 2448, 2488, 2616, 2622, 2664, 2688, 2744, 2772, 2824, 2832, 2848, 2888, 2916, 3111, 3126, 3132, 3135, 3144, 3162, 3168, 3171, 3195, 3216, 3222, 3264, 3276, 3288, 3312, 3315, 3324, 3333, 3336, 3339, 3366, 3384, 3393, 3432, 3444, 3492, 3555, 3612, 3624, 3636, 3648, 3666, 3717, 3816, 3864, 3888, 3915, 3924, 3933, 3996, 4112, 4116, 4124, 4128, 4144, 4164, 4172, 4184, 4212, 4224, 4236, 4244, 4248, 4288, 4332, 4344, 4368, 4392, 4412, 4416, 4424, 4444, 4448, 4464, 4488, 4632, 4644, 4824, 4848, 4872, 4888, 4896, 4932, 4968, 5115, 5155, 5355, 5515, 5535, 5555, 5775, 6126, 6132, 6144, 6162, 6168, 6192, 6216, 6222, 6264, 6288, 6312, 6324, 6336, 6366, 6384, 6432, 6444, 6612, 6624, 6636, 6648, 6666, 6696, 6762, 6816, 6864, 6888, 6912, 6966, 6984, 7112, 7119, 7175, 7224, 7266, 7371, 7448, 7476, 7644, 7728, 7777, 7784, 8112, 8128, 8136, 8144, 8184, 8224, 8232, 8248, 8288, 8328, 8424, 8448, 8488, 8496, 8616, 8664, 8688, 8736, 8824, 8832, 8848, 8888, 8928, 9126, 9135, 9144, 9162, 9216, 9288, 9315, 9324, 9333, 9396, 9432, 9612, 9648, 9666, 9864, 9936, 9999];
        // 开挂以后可以知道: 上面那个数组元素总数是339.
        $result = [];
        for ($i = 0; $i < 339; $i++) {
            if ($self_dividing_number_array[$i] >= $left && $self_dividing_number_array[$i] <= $right) {
                $result[] = $self_dividing_number_array[$i];
            }
        }
        return $result;
    }
}
```


效果1:

> 执行用时 : 12 ms, 在Self Dividing Numbers的PHP提交中击败了 92.86% 的用户
> 
> 内存消耗 : 14.7 MB, 在Self Dividing Numbers的PHP提交中击败了 100.00% 的用户




解答2:

```php
class Solution 
{

    /**
     * @param Integer $left
     * @param Integer $right
     * @return Integer[]
     */
    function selfDividingNumbers($left, $right) 
    {
        $self_dividing_number_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22, 24, 33, 36, 44, 48, 55, 66, 77, 88, 99, 111, 112, 115, 122, 124, 126, 128, 132, 135, 144, 155, 162, 168, 175, 184, 212, 216, 222, 224, 244, 248, 264, 288, 312, 315, 324, 333, 336, 366, 384, 396, 412, 424, 432, 444, 448, 488, 515, 555, 612, 624, 636, 648, 666, 672, 728, 735, 777, 784, 816, 824, 848, 864, 888, 936, 999, 1111, 1112, 1113, 1115, 1116, 1122, 1124, 1128, 1131, 1144, 1155, 1164, 1176, 1184, 1197, 1212, 1222, 1224, 1236, 1244, 1248, 1266, 1288, 1296, 1311, 1326, 1332, 1335, 1344, 1362, 1368, 1395, 1412, 1416, 1424, 1444, 1448, 1464, 1488, 1515, 1555, 1575, 1626, 1632, 1644, 1662, 1692, 1715, 1722, 1764, 1771, 1824, 1848, 1888, 1926, 1935, 1944, 1962, 2112, 2122, 2124, 2128, 2136, 2144, 2166, 2184, 2196, 2212, 2222, 2224, 2226, 2232, 2244, 2248, 2262, 2288, 2316, 2322, 2328, 2364, 2412, 2424, 2436, 2444, 2448, 2488, 2616, 2622, 2664, 2688, 2744, 2772, 2824, 2832, 2848, 2888, 2916, 3111, 3126, 3132, 3135, 3144, 3162, 3168, 3171, 3195, 3216, 3222, 3264, 3276, 3288, 3312, 3315, 3324, 3333, 3336, 3339, 3366, 3384, 3393, 3432, 3444, 3492, 3555, 3612, 3624, 3636, 3648, 3666, 3717, 3816, 3864, 3888, 3915, 3924, 3933, 3996, 4112, 4116, 4124, 4128, 4144, 4164, 4172, 4184, 4212, 4224, 4236, 4244, 4248, 4288, 4332, 4344, 4368, 4392, 4412, 4416, 4424, 4444, 4448, 4464, 4488, 4632, 4644, 4824, 4848, 4872, 4888, 4896, 4932, 4968, 5115, 5155, 5355, 5515, 5535, 5555, 5775, 6126, 6132, 6144, 6162, 6168, 6192, 6216, 6222, 6264, 6288, 6312, 6324, 6336, 6366, 6384, 6432, 6444, 6612, 6624, 6636, 6648, 6666, 6696, 6762, 6816, 6864, 6888, 6912, 6966, 6984, 7112, 7119, 7175, 7224, 7266, 7371, 7448, 7476, 7644, 7728, 7777, 7784, 8112, 8128, 8136, 8144, 8184, 8224, 8232, 8248, 8288, 8328, 8424, 8448, 8488, 8496, 8616, 8664, 8688, 8736, 8824, 8832, 8848, 8888, 8928, 9126, 9135, 9144, 9162, 9216, 9288, 9315, 9324, 9333, 9396, 9432, 9612, 9648, 9666, 9864, 9936, 9999];
        // 开挂以后可以知道: 上面那个数组元素总数是339.
        $left_index = 0;
        $right_index = 338;
        for ($i = 0; $i < 339; $i++) {
            if ($left <= $self_dividing_number_array[$i]) {
                $left_index = $i;
                break;
            }
        }
        for ($j = 338; $j >= 0; $j--) {
            if ($right >= $self_dividing_number_array[$j]) {
                $right_index = $j;
                break;
            }
        }
        return array_slice($self_dividing_number_array, $left_index, $right_index - $left_index + 1);
    }
}
```


效果2:

> 执行用时 : 8 ms, 在Self Dividing Numbers的PHP提交中击败了100.00% 的用户
> 
> 内存消耗 : 14.8 MB, 在Self Dividing Numbers的PHP提交中击败了100.00% 的用户


注意根据数组的两个下标划范围划子数组是用`array_slice`这个函数. 此外这个题对编辑器的使用水平也有一定要求.


## 747. Largest Number At Least Twice of Others


题目描述:


In a given integer array `nums`, there is always exactly one largest element.

Find whether the largest element in the array is at least twice as much as every other number in the array.

If it is, return the index of the largest element, otherwise return -1.

**Example 1:**


<pre>
Input: nums = [3, 6, 1, 0]
Output: 1
Explanation: 6 is the largest integer, and for every other number in the array x,
6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.
</pre>
 

**Example 2:**


<pre>
Input: nums = [1, 2, 3, 4]
Output: -1
Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.
</pre>

**Note:**

1. `nums` will have a length in the range `[1, 50]`.
2. Every `nums[i]` will be an integer in the range `[0, 99]`.


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function dominantIndex($nums) 
    {
        arsort($nums, SORT_NUMERIC);
        $values = array_values($nums);
        if ($values[0] >= 2 * $values[1]) {
            return array_search($values[0], $nums);
        }
        return -1;
    }
}
```

效果:

> 执行用时 : 16 ms, 在所有 PHP 提交中击败了 79.17% 的用户
> 
> 内存消耗 : 14.9 MB, 在所有 PHP 提交中击败了 7.69% 的用户


## 755. Pour Water (上锁题目, 需要氪会员)


We are given an elevation map, `heights[i]` representing the height of the terrain at that index. The width at each index is 1. After `V` units of water fall at index `K`, how much water is at each index?

Water first drops at index `K` and rests on top of the highest terrain or water at that index. Then, it flows according to the following rules:

* If the droplet would eventually fall by moving left, then move left.
* Otherwise, if the droplet would eventually fall by moving right, then move right.
* Otherwise, rise at it's current position.


Here, "eventually fall" means that the droplet will eventually be at a lower level if it moves in that direction. Also, "level" means the height of the terrain plus any water in that column.


We can assume there's infinitely high terrain on the two sides out of bounds of the array. Also, there could not be partial water being spread out evenly on more than 1 grid block - each unit of water has to be in exactly one block.


**Example 1:**

<pre>
Input: heights = [2,1,1,2,1,2,2], V = 4, K = 3
Output: [2,2,2,3,2,2,2]
Explanation:
#       #
#       #
##  # ###
#########
 0123456    <- index

The first drop of water lands at index K = 3:

#       #
#   w   #
##  # ###
#########
 0123456    

When moving left or right, the water can only move to the same level or a lower level.
(By level, we mean the total height of the terrain plus any water in that column.)
Since moving left will eventually make it fall, it moves left.
(A droplet "made to fall" means go to a lower height than it was at previously.)

#       #
#       #
## w# ###
#########
 0123456    

Since moving left will not make it fall, it stays in place.  The next droplet falls:

#       #
#   w   #
## w# ###
#########
 0123456  

Since the new droplet moving left will eventually make it fall, it moves left.
Notice that the droplet still preferred to move left,
even though it could move right (and moving right makes it fall quicker.)

#       #
#  w    #
## w# ###
#########
 0123456  

#       #
#       #
##ww# ###
#########
 0123456  

After those steps, the third droplet falls.
Since moving left would not eventually make it fall, it tries to move right.
Since moving right would eventually make it fall, it moves right.

#       #
#   w   #
##ww# ###
#########
 0123456  

#       #
#       #
##ww#w###
#########
 0123456  

Finally, the fourth droplet falls.
Since moving left would not eventually make it fall, it tries to move right.
Since moving right would not eventually make it fall, it stays in place:

#       #
#   w   #
##ww#w###
#########
 0123456  

The final answer is [2,2,2,3,2,2,2]:

    #    
 ####### 
 ####### 
 0123456 
</pre>



**Example 2:**

<pre>
Input: heights = [1,2,3,4], V = 2, K = 2
Output: [2,3,3,4]
Explanation:
The last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height.
</pre>


**Example 3:**

<pre>
Input: heights = [3,1,3], V = 5, K = 1
Output: [4,4,4]
</pre>


**Note:**

1. `heights` will have length in `[1, 100]` and contain integers in `[0, 99]`.
2. `V` will be in range `[0, 2000]`.
3. `K` will be in range `[0, heights.length - 1]`. 



## 760. Find Anagram Mappings (上锁题目, 需要氪会员)



Given two lists `A` and `B`, and `B` is an anagram of `A`. `B` is an anagram of `A` means `B` is made by randomizing the order of the elements in `A`.

We want to find an *index* mapping `P`, from `A` to `B`. `A` mapping `P[i] = j` means the `i`th element in `A` appears in `B` at index `j`.

These lists `A` and `B` may contain duplicates. If there are multiple answers, output any of them.

For example, given


<pre>
A = [12, 28, 46, 32, 50]
B = [50, 12, 32, 46, 28]
</pre>


We should return

<pre>
[1, 4, 3, 2, 0]
</pre>


as `P[0] = 1` because the `0`th element of `A` appears at `B[1]`, and `P[1] = 4` because the `1`st element of `A` appears at `B[4]`, and so on.


**Note:**

1. `A, B` have equal lengths in range `[1, 100]`.
2. `A[i], B[i]` are integers in range `[0, 10^5]`.


## 771. Jewels and Stones

题目描述:

You're given strings `jewels` representing the types of stones that are jewels, and `stones` representing the stones you have.  Each character in `stones` is a type of stone you have.  You want to know how many of the stones you have are also jewels.

The letters in `jewels` are guaranteed distinct, and all characters in `jewels` and `stones` are letters. Letters are case sensitive, so `"a"` is considered a different type of stone from `"A"`.

**Example 1:**


<pre>
<strong>Input:</strong> jewels = "aA", stones = "aAAbbbb"
<strong>Output:</strong> 3
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> jewels = "z", stones = "ZZ"
<strong>Output:</strong> 0
</pre>


**Note:**

* `stones` and `jewels` will consist of letters and have length at most 50.
* The characters in `jewels` are distinct.


解答1:

```php
class Solution 
{

    /**
     * @param String $jewels
     * @param String $stones
     * @return Integer
     */
    function numJewelsInStones($jewels, $stones) 
    {
        $count = 0;
        $stone_char_info = count_chars($stones, 1);
        $stone_key_array = array_keys($stone_char_info);
        $jewel_len = strlen($jewels);
        for ($i = 0; $i < $jewel_len; $i++) {
            if (in_array(ord($jewels[$i]), $stone_key_array)) {
                $count += $stone_char_info[ord($jewels[$i])];
            }
        }
        return $count;
    }
}
```


效果1:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 92.51% 的用户
> 
> 内存消耗 : 14.7 MB, 在所有 PHP 提交中击败了 31.19% 的用户


解答2:

```php
class Solution 
{

    /**
     * @param String $jewels
     * @param String $stones
     * @return Integer
     */
    function numJewelsInStones($jewels, $stones) 
    {
        $count = 0;
        $kindArray = str_split($jewels);
        foreach ($kindArray as $kind) {
            $count += substr_count($stones, $kind);
        }
        return $count;
    }
}
```

效果2:


> 执行用时 : 0 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.7 MB, 在所有 PHP 提交中击败了 61.47% 的用户


解答3:

```php
class Solution 
{

    /**
     * @param String $jewels
     * @param String $stones
     * @return Integer
     */
    function numJewelsInStones($jewels, $stones) 
    {
        // PHP是最好的语言!
        str_replace(str_split($jewels), '', $stones, $count);
        return $count;
    }
}
```

效果3:

> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 97.86% 的用户
> 
> 内存消耗 : 14.5 MB, 在所有 PHP 提交中击败了 92.66% 的用户


解答4:

```php
class Solution 
{

    /**
     * @param String $jewels
     * @param String $stones
     * @return Integer
     */
    function numJewelsInStones($jewels, $stones) 
    {
        // PHP是最好的语言!
        return preg_match_all('/[' . $jewels . ']/', $stones);
    }
}
```

效果4:

> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 97.86% 的用户
> 
> 内存消耗 : 14.9 MB, 在所有 PHP 提交中击败了 5.51% 的用户


这题不错, 解法4也是让我开创了正则表达式写模式的一种新玩法...如果我将来能兼技术面主管的话, 我肯定会拿这个题来考萌新茴的四种写法. 

其实当时我很看好用`strspn()`函数写, 不过这个函数不能像`preg_match_all()`那样有all的功能...正则表达式是个比较有用的工具, 值得花时间去系统看.


要时刻记住, 你来公司不是炫技的(想炫技可以上高中回炉参加信息学竞赛), 也不是来搞学术研究的(想搞学术研究可以找个高校回炉), 而是干出产值的. 能实现需求(工程需要)而且可读性好(“Artisans.” “Elegant.”)的才是好的做法. 


## 796. Rotate String

We are given two strings, `str1` and `str2`.

A *shift* *on* *`str1`* consists of taking string `str1` and moving the leftmost character to the rightmost position. For example, if `str1 = 'abcde'`, then it will be `'bcdea'` after one shift on `str1`. Return True if and only if `str1` can become `str2` after some number of shifts on `str1`.

**Example 1:**


<pre>
<strong>Input:</strong> str1 = 'abcde', str2 = 'cdeab'
<strong>Output:</strong> true
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> str1 = 'abcde', str2 = 'abced'
<strong>Output:</strong> false
</pre>



**Note:**

* str1 and str2 will have length at most `100`.


解答1:

```php
class Solution 
{

    /**
     * @param String $str1
     * @param String $str2
     * @return Boolean
     */
    function rotateString($str1, $str2) 
    {
        if (strcmp($str1, $str2) === 0) {
            return true;
        }
        $length1 = strlen($str1);
        $length2 = strlen($str2);
        if ($length1 !== $length2) {
            return false;
        }
        for ($i = 0; $i < $length1; $i++) {
            if ($str2 === (substr($str1, $i) . substr($str1, 0, $i))) {
                return true;
            }
        }
        return false;
    }
}
```

效果1:

> 执行用时: 4 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 14.8 MB, 在所有 PHP 提交中击败了 100.00% 的用户


解答2:


```php
class Solution 
{

    /**
     * @param String $str1
     * @param String $str2
     * @return Boolean
     */
    function rotateString($str1, $str2) 
    {
        // 涵盖了两字符串均为空及两非空字符串完全相等的情形.
        if (strcmp($str1, $str2) === 0) {
            return true;
        }
        // 涵盖旋转后能够相等的情形.
        return (strlen($str1) === strlen($str2)) && (strpos($str1 . $str1, $str2) > 0);
    }
}
```


效果2:

> 执行用时: 4 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 14.8 MB, 在所有 PHP 提交中击败了 100.00% 的用户



这个主要是要注意两个都是空字符串的情形. 这个特殊情形如果不拿 `strcmp()` 比较的话会漏掉, 总之会 `return` 一个 `false`.


解答 2 比较类似于 459. Repeated Substring Pattern、686. Repeated String Match 这两个题.


## 800. Similar RGB Color (上锁题目, 需要氪会员)


题目描述:

In the following, every capital letter represents some hexadecimal digit from `0` to `f`.

The red-green-blue color `"#AABBCC"` can be written as `"#ABC"` in shorthand.  For example, `"#15c"` is shorthand for the color `"#1155cc"`.

Now, say the similarity between two colors `"#ABCDEF"` and `"#UVWXYZ"` is `-(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2`.

Given the color `"#ABCDEF"`, return a 7 character color that is most similar to `#ABCDEF`, and has a shorthand (that is, it can be represented as some `"#XYZ"`

**Example 1:**

<pre>
<strong>Input:</strong> color = "#09f166"
<strong>Output:</strong> "#11ee66"
<strong>Explanation:</strong>  
The similarity is -(0x09 - 0x11)^2 -(0xf1 - 0xee)^2 - (0x66 - 0x66)^2 = -64 -9 -0 = -73.
This is the highest among any shorthand color.
</pre>


**Note:**

* `color` is a string of length `7`.
* `color` is a valid RGB color: for `i > 0`, `color[i]` is a hexadecimal digit from `0` to `f`
* Any answer which has the same (highest) similarity as the best answer will be accepted.
* All inputs and outputs should use lowercase letters, and the output is 7 characters.


## 804. Unique Morse Code Words

题目描述:

International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: `"a"` maps to `".-"`, `"b"` maps to `"-..."`, `"c"` maps to `"-.-."`, and so on.

For convenience, the full table for the 26 letters of the English alphabet is given below:

```
[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
```

Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cba" can be written as "-.-..--...", (which is the concatenation "-.-." + "-..." + ".-"). We'll call such a concatenation, the transformation of a word.

Return the number of different transformations among all words we have.

<pre>
<strong>Example:</strong>
<strong>Input:</strong> words = ["gin", "zen", "gig", "msg"]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
The transformation of each word is:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

There are 2 different transformations, "--...-." and "--...--.".
</pre>

**Note:**

* The length of `words` will be at most `100`.
* Each `words[i]` will have length in range `[1, 12]`.
* `words[i]` will only consist of lowercase letters.


解答:

```php
class Solution
{

    /**
     * @param String[] $words
     * @return Integer
     */
    function uniqueMorseRepresentations($words)
    {
        $char2morse = ["a" => ".-", "b" => "-...", "c" => "-.-.", "d" => "-..", "e" => ".", "f" => "..-.", "g" => "--.", "h" => "....", "i" => "..", "j" => ".---", "k" => "-.-", "l" => ".-..", "m" => "--", "n" => "-.", "o" => "---", "p" => ".--.", "q" => "--.-", "r" => ".-.", "s" => "...", "t" => "-", "u" => "..-", "v" => "...-", "w" => ".--", "x" => "-..-", "y" => "-.--", "z" => "--.."];
        $morses = array_map($map = function ($word) use ($char2morse) {
            $char_array = str_split($word);
            $morse = "";
            foreach ($char_array as $char) {
                $morse .= $char2morse[$char];
            }
            return $morse;
        }, $words);
        return count(array_unique($morses));
    }
}
```

效果: 

> 执行用时: 12 ms, 在所有 PHP 提交中击败了 65.63% 的用户
> 
> 内存消耗: 14.5 MB, 在所有 PHP 提交中击败了 100.00% 的用户


## 819. Most Common Word


题目描述:


Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique.

Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.

 

**Example:**


<pre>
Input: 
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
Output: "ball"
Explanation: 
"hit" occurs 3 times, but it is a banned word.
"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. 
Note that words in the paragraph are not case sensitive,
that punctuation is ignored (even if adjacent to words, such as "ball,"), 
and that "hit" isn't the answer even though it occurs more because it is banned.
</pre>
 

**Note:**

* `1 <= paragraph.length <= 1000`.
* `0 <= banned.length <= 100`.
* `1 <= banned[i].length <= 10`.
* The answer is unique, and written in lowercase (even if its occurrences in `paragraph` may have uppercase symbols, and even if it is a proper noun.)
* `paragraph` only consists of letters, spaces, or the punctuation symbols `!?',;.`
* There are no hyphens or hyphenated words.
* Words only consist of letters, never apostrophes or other punctuation symbols.


解答:

```php
class Solution 
{

    /**
     * @param String $paragraph
     * @param String[] $banned
     * @return String
     */
    function mostCommonWord($paragraph, $banned) 
    {
        // 先去标点. 注意拿空格替换标点, 以免出现标点后无空格的奇葩排版情形.
        $paragraph = preg_replace("/[!?',;.]/", " ", $paragraph);
        // PHP是最好的语言!
        $count = str_word_count(strtolower($paragraph), 2);
        $word_array = array_count_values($count);
        $banned = array_flip($banned);
        $candidate_array = array_diff_key($word_array, $banned);
        arsort($candidate_array, SORT_NUMERIC);
        // 取单词=>出现次数的关联数组的首键. 此前不reset数组也可以过.
        return key($candidate_array);
    }
}
```


效果:

> 执行用时 : 8 ms, 在Most Common Word的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在Most Common Word的PHP提交中击败了 100.00% 的用户


这个题目也是体现了正则表达式的重要作用. 里面有几个点要注意一下: 一是文本字符串大小写是不统一的, 需要转; 二是标点的位置不固定, 可能前后有空格也可能没空格, 匹配去除的时候谨慎一些; 三是干出产值的时候我觉着还是把`$candidate_array`先`reset`一下再取首key比较好. 当然这里能过OJ也就算了.

## 824. Goat Latin

题目描述:

A sentence `str` is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.

We would like to convert the sentence to "*Goat Latin*" (a made-up language similar to Pig Latin.)

The rules of Goat Latin are as follows:

* If a word begins with a vowel (a, e, i, o, or u), append `"ma"` to the end of the word.
  For example, the word 'apple' becomes 'applema'.
* If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add `"ma"`.
  For example, the word `"goat"` becomes `"oatgma"`.
* Add one letter `'a'` to the end of each word per its word index in the sentence, starting with 1.
  For example, the first word gets `"a"` added to the end, the second word gets `"aa"` added to the end and so on.

Return the final sentence representing the conversion from `str` to Goat Latin. 


**Example 1:**

<pre>
<strong>Input:</strong> "I speak Goat Latin"
<strong>Output:</strong> "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> "The quick brown fox jumped over the lazy dog"
<strong>Output:</strong> "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"
</pre>

**Notes:**

* `str` contains only uppercase, lowercase and spaces. Exactly one space between each word.
* `1 <= str.length <= 150`.


解答:


```php
class Solution
{

    /**
     * @param String $str
     * @return String
     */
    function toGoatLatin($str)
    {
        $pieces = explode(' ', $str);
        $count = count($pieces);
        $vowels = ['a', 'A', 'e', 'E', 'i', 'I', 'o', 'O', 'u', 'U'];
        for ($i = 0; $i < $count; $i++) {
            if (!in_array($pieces[$i][0], $vowels)) {
                $char_array = str_split($pieces[$i]);
                $first_char = array_shift($char_array);
                $pieces[$i] = implode($char_array).$first_char;
            }
            $pieces[$i] .= ("ma".str_repeat('a', $i + 1));
        }
        return implode(' ', $pieces);
    }
}
```

效果:

> 执行用时: 4 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 14.7 MB, 在所有 PHP 提交中击败了 50.00% 的用户

Artisanal and elegant.


## 830. Positions of Large Groups

题目描述:

In a string `str` of lowercase letters, these letters form consecutive groups of the same character.

For example, a string like `str = "abbxxxxzyy"` has the groups `"a"`, `"bb"`, `"xxxx"`, `"z"` and `"yy"`.

Call a group *large* if it has 3 or more characters.  We would like the starting and ending positions of every large group.

The final answer should be in lexicographic order.

 

**Example 1:**


<pre>
<strong>Input:</strong> "abbxxxxzzy"
<strong>Output:</strong> [[3,6]]
<strong>Explanation:</strong> "xxxx" is the single large group with starting  3 and ending positions 6.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> "abc"
<strong>Output:</strong> []
<strong>Explanation:</strong> We have "a","b" and "c" but no large group.
</pre>

**Example 3:**


<pre>
<strong>Input:</strong> "abcdddeeeeaabbbcd"
<strong>Output:</strong> [[3,5],[6,9],[12,14]]
</pre>


**Note:**  `1 <= str.length <= 1000`


解答:

```php
class Solution 
{

    /**
     * @param String $str
     * @return Integer[][]
     */
    function largeGroupPositions($str) 
    {
        $result = [];
        $start = 0;
        $str_len = strlen($str);
        for ($end = 0; $end < $str_len; $end++) {
            // 当前后两字符不是一组的或是到字符串`$str`末尾就开始判断, 进行处理.
            if ($end == $count - 1 || $str[$end] !== $str[$end + 1]) {
                if ($end - $start + 1 >= 3) {
                    $result[] = [$start, $end];
                }
                $start = $end + 1;
            }
        }
        return $result;   
    }
}
```

效果:

> 执行用时 : 32 ms, 在所有 PHP 提交中击败了 25.00% 的用户
> 
> 内存消耗 : 15 MB, 在所有 PHP 提交中击败了 100.00% 的用户

## 832. Flipping an Image

题目描述:

Given a binary matrix `image`, we want to flip the image horizontally, then invert it, and return the resulting image.

To flip an image horizontally means that each row of the image is reversed.  For example, flipping `[1, 1, 0]` horizontally results in `[0, 1, 1]`.

To invert an image means that each `0` is replaced by `1`, and each `1` is replaced by `0`. For example, inverting `[0, 1, 1]` results in `[1, 0, 0]`.

**Example 1:**

<pre>
<strong>Input:</strong> [[1,1,0],[1,0,1],[0,0,0]]
<strong>Output:</strong> [[1,0,0],[0,1,0],[1,1,1]]
<strong>Explanation:</strong> First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].
Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
<strong>Output:</strong> [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
<strong>Explanation:</strong> First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].
Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
</pre>

**Notes:**

* 1 <= image.length = image[0].length <= 20
* 0 <= image[i][j] <= 1


解答:

```php
class Solution 
{

    /**
     * @param Integer[][] $image
     * @return Integer[][]
     */
    function flipAndInvertImage($image) 
    {
        $rowCount = count($image);
        // 先镜像.
        for ($i = 0; $i < $rowCount; $i++) {
            $image[$i] = array_reverse($image[$i]);
        }
        // 再取反.
        $columnCount = count($image[0]);
        for ($j = 0; $j < $columnCount; $j++) {
            for ($i = 0; $i < $rowCount; $i++) {
                if ($image[$i][$j] === 1) {
                    $image[$i][$j] = 0;
                } else {
                    $image[$i][$j] = 1;
                }
            }
        }
        return $image;
    }
}
```


效果:

> 执行用时: 20 ms, 在所有 PHP 提交中击败了 70.31% 的用户
>
> 内存消耗: 14.6 MB, 在所有 PHP 提交中击败了 92.86% 的用户

就是取反可能会坑...直接对元素操作即可.

## 852. Peak Index in a Mountain Array

题目描述:

Let's call an array `array` a mountain if the following properties hold:

* `array.length >= 3`
* There exists some `0 < i < array.length - 1` such that `array[0] < array[1] < ... < array[i-1] < array[i] > array[i+1] > ... > array[array.length - 1]`



Given an array that is definitely a mountain, return any `i` such that `array[0] < array[1] < ... < array[i-1] < array[i] > array[i+1] > ... > array[array.length - 1]`.

**Example 1:**


<pre>
Input: [0,1,0]
Output: 1
</pre>


**Example 2:**


<pre>
Input: [0,2,1,0]
Output: 1
</pre>


**Note:**

1. `3 <= array.length <= 10000`
2. `0 <= array[i] <= 10^6`
3. `array` is a mountain, as defined above.


解答:

```php
class Solution {

    /**
     * @param Integer[] $array
     * @return Integer
     */
    function peakIndexInMountainArray($array) {
        return array_search(max($array), $array); 
    }
}
```


效果:

> 执行用时 : 28 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 16.1 MB, 在所有 PHP 提交中击败了 25.00% 的用户


前面絮絮叨叨讲了一大通, 还以为这个题需要判断是不是单峰...




## 866. Prime Palindrome

题目描述:

Find the smallest prime palindrome greater than or equal to `num`.

Recall that a number is *prime* if it's only divisors are 1 and itself, and it is greater than 1. 

For example, 2,3,5,7,11 and 13 are primes.

Recall that a number is a *palindrome* if it reads the same from left to right as it does from right to left. 

For example, 12321 is a palindrome.

 

**Example 1:**


<pre>
<strong>Input:</strong> 6
<strong>Output:</strong> 7
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> 8
<strong>Output:</strong> 11
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> 13
<strong>Output:</strong> 101
</pre>


**Note:**

* `1 <= num <= 10^8`
* The answer is guaranteed to exist and be less than `2 * 10^8`.


解答:


```php
class Solution 
{

    /**
     * @param Integer $num
     * @return Integer
     */
    function primePalindrome($num) 
    {
        $palindromePrimes = [2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001];
        // 根据OJ提交结果来看, 在这儿需要拦一下.
        if ($num >= 9989900) {
            return 100030001;
        }
        for ($i = 0; $i < 780; $i++) {
            if ($palindromePrimes[$i] >= $num) {
                return $palindromePrimes[$i];
            }
        }
    }
}
```


效果: 

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


就算你不知道专业的数学网站, 那么你能谷歌吗? 谷歌一下就能找到前人已经给你算好的 Palindromic primes 的表, 都能到第 47900+ 个素数、99903430999, 99903730999, 99904240999, 99906260999, 99907070999, 99909790999... 这种的. 选出你要的然后操作 Sublime Text 就行了, 不要浪费时间造轮子. 

注意: option + 按住鼠标左键是垂直方向上选择.



## 867. Transpose Matrix


题目描述:

Given a matrix `matrix`, return the transpose of `matrix`.


The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.

**Example 1:**


<pre>
Input: [[1,2,3],[4,5,6],[7,8,9]]
Output: [[1,4,7],[2,5,8],[3,6,9]]
</pre>


**Example 2:**


<pre>
Input: [[1,2,3],[4,5,6]]
Output: [[1,4],[2,5],[3,6]]
</pre>


**Note:**

1. `1 <= matrix.length <= 1000`
2. `1 <= matrix[0].length <= 1000`

解答:

```php
class Solution 
{

    /**
     * @param Integer[][] $matrix
     * @return Integer[][]
     */
    function transpose($matrix) 
    {
        $transpose = [];
        foreach ($matrix[0] as $key => $value) {
            // PHP是最好的语言!
            $transpose[] = array_column($matrix, $key);
        }
        return $transpose;
    }
}
```


效果:

> 执行用时 : 32 ms, 在Transpose Matrix的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 16.4 MB, 在Transpose Matrix的PHP提交中击败了 7.69% 的用户


## 868. Binary Gap


Given a positive integer `number`, find and return the longest distance between two consecutive 1's in the binary representation of `number`.

If there aren't two consecutive 1's, return 0.

 

**Example 1:**


<pre>
<strong>Input:</strong> 22
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
22 in binary is 0b10110.
In the binary representation of 22, there are three ones, and two consecutive pairs of 1's.
The first consecutive pair of 1's have distance 2.
The second consecutive pair of 1's have distance 1.
The answer is the largest of these two distances, which is 2.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> 5
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
5 in binary is 0b101.
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> 6
<strong>Output:</strong> 1
<strong>Explanation:</strong> 
6 in binary is 0b110.
</pre>


**Example 4:**


<pre>
<strong>Input:</strong> 8
<strong>Output:</strong> 0
<strong>Explanation:</strong> 
8 in binary is 0b1000.
There aren't any consecutive pairs of 1's in the binary representation of 8, so we return 0.
</pre>


**Note:**

* `1 <= number <= 10^9`


解答:


```php
class Solution 
{

    /**
     * @param Integer $number
     * @return Integer
     */
    function binaryGap($number) 
    {
        if ($number === 0) {
            return 0;
        }
        $binary_char_array = str_split(decbin($number));
        $index_of_1_array = array_keys($binary_char_array, "1");
        $count = count($index_of_1_array);
        if ($count === 1) {
            return 0;
        } else {
            $longest_distance = $index_of_1_array[1] - $index_of_1_array[0];
            for ($i = 1; $i < $count - 1; $i++) {
                if ($index_of_1_array[$i + 1] - $index_of_1_array[$i] > $longest_distance) {
                    $longest_distance = $index_of_1_array[$i + 1] - $index_of_1_array[$i];
                }
            }
        }
        return $longest_distance;
    }
}
```


效果:

> 执行用时: 4 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 14.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


## 869. Reordered Power of 2

题目描述:

Starting with a positive integer `number`, we reorder the digits in any order (including the original order) such that the leading digit is not zero.

Return `true` if and only if we can do this in a way such that the resulting number is a power of 2.

 

**Example 1:**

<pre>
<strong>Input:</strong> 1
<strong>Output:</strong> true
</pre>


**Example 2:**

<pre>
<strong>Input:</strong> 10
<strong>Output:</strong> false
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> 16
<strong>Output:</strong> true
</pre>

**Example 4:**

<pre>
<strong>Input:</strong> 24
<strong>Output:</strong> false
</pre>


**Example 5:**

<pre>
<strong>Input:</strong> 46
<strong>Output:</strong> true
</pre>

**Note:**

1. `1 <= number <= 10^9`



解答:


```php
class Solution 
{

    /**
     * @param Integer $N
     * @return Boolean
     */
    function reorderedPowerOf2($number) 
    {
        $powers_of_2_digit_info = array_map($callable = function ($element) {
            return count_chars(strval($element), 1);
        }, [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912]);
        $number_digit_info = count_chars(strval($number), 1);
        if (in_array($number_digit_info, $powers_of_2_digit_info)) {
            return true;
        }
        return false;
    }
}
```

效果:

> 执行用时 : 16 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在所有 PHP 提交中击败了 100.00% 的用户



当时琢磨了半天为什么传个 46 会返回true, 心想 1011101<sub>(2)</sub> = 46<sub>(10)</sub> 和 2 的幂 0, 10, 100, 1000, ... 100..0, ... 也谈不上啥关系啊, 后面一看原来是重排成十进制 2 的幂就可以😂

看来还是要喝咖啡保持战斗力的😂


## 884. Uncommon Words from Two Sentences

题目描述:

We are given two sentences `a` and `b`.  (A *sentence* is a string of space separated words.  Each *word* consists only of lowercase letters.)

A word is *uncommon* if it appears exactly once in one of the sentences, and does not appear in the other sentence.

Return a list of all uncommon words. 

You may return the list in any order.


**Example 1:**


<pre>
<strong>Input:</strong> a = "this apple is sweet", b = "this apple is sour"
<strong>Output:</strong> ["sweet","sour"]
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> a = "apple apple", b = "banana"
<strong>Output:</strong> ["banana"]
</pre>


**Note:**

1. `0 <= a.length <= 200`
2. `0 <= b.length <= 200`
3. `a` and `b` both contain only spaces and lowercase letters.


解答:


```php
class Solution 
{

    /**
     * @param String $a
     * @param String $b
     * @return String[]
     */
    function uncommonFromSentences($a, $b) 
    {
        $uncommon_words = [];
        $a_word_info = array_count_values(explode(" ", $a));
        $a_word_list = array_keys($a_word_info);
        $b_word_info = array_count_values(explode(" ", $b));
        $b_word_list = array_keys($b_word_info);
        foreach ($a_word_info as $word => $count) {
            if ($count === 1) {
                if (!in_array($word, $b_word_list)) {
                    $uncommon_words[] = $word;
                }
            }
        }
        foreach ($b_word_info as $word => $count) {
            if ($count === 1) {
                if (!in_array($word, $a_word_list)) {
                    $uncommon_words[] = $word;
                }
            }
        }
        return $uncommon_words;
    }
}
```


效果:


> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 80.00% 的用户
> 
> 内存消耗 : 14.7 MB, 在所有 PHP 提交中击败了 50.00% 的用户


也可以拿 `array_filter()` 过滤出出现次数为 1 的单词做成的数组, 然后取


## 896. Monotonic Array

题目描述:

An array is *monotonic* if it is either monotone increasing or monotone decreasing.

An array `arr` is monotone increasing if for all `i <= j`, `arr[i] <= arr[j]`.  An array `arr` is monotone decreasing if for all `i <= j`, `arr[i] >= arr[j]`.

Return `true` if and only if the given array `arr` is monotonic.

 

**Example 1:**


<pre>
<strong>Input:</strong> [1,2,2,3]
<strong>Output:</strong> true
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> [6,5,4,4]
<strong>Output:</strong> true
</pre>

**Example 3:**


<pre>
<strong>Input:</strong> [1,3,2]
<strong>Output:</strong> false
</pre>


**Example 4:**


<pre>
<strong>Input:</strong> [1,2,4,5]
<strong>Output:</strong> true
</pre>


**Example 5:**

<pre>
<strong>Input:</strong> [1,1,1]
<strong>Output:</strong> true
</pre>


**Note:**


1. `1 <= arr.length <= 50000`
2. `-100000 <= arr[i] <= 100000`



解答:

```php
class Solution 
{

    /**
     * @param Integer[] $arr
     * @return Boolean
     */
    function isMonotonic($arr) 
    {
        $count = count($arr);
        $max = max($arr);
        $indexOfMax = array_search($max, $arr);
        if ($indexOfMax === 0) {
            for ($i = 0; $i < $count - 1; $i++) {
                if ($arr[$i] < $arr[$i + 1]) {
                    return false;
                }
            }
        } else {
            for ($i = 0; $i < $count - 1; $i++) {
                if ($arr[$i] > $arr[$i + 1]) {
                    return false;
                }
            }
        }
        return true;
    }
}
```

效果: 

> 执行用时 : 192 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 21.7 MB, 在所有 PHP 提交中击败了 100.00% 的用户

由于函数的特性等原因, 这个题不适合先排序, 再直接比较. 而且你再块的排序一般也是得个O(*n*log*n*)的时间复杂度, 耽误产值.

## 905. Sort Array By Parity


题目描述:

Given an array `arr` of non-negative integers, return an array consisting of all the even elements of `arr`, followed by all the odd elements of `arr`.

You may return any answer array that satisfies this condition.

 

**Example 1:**


<pre>
Input: [3,1,2,4]
Output: [2,4,3,1]
The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
</pre>

 

**Note:**

1. 1 <= arr.length <= 5000
2. 0 <= arr[i] <= 5000


解答:


```php
class Solution 
{

    /**
     * @param Integer[] $arr
     * @return Integer[]
     */
    function sortArrayByParity($arr) 
    {
        usort($arr, $cmp_by_parity = function ($a, $b) {
            if ($a % 2 == 0 && $b % 2 == 0) {
                return 0;
            }
            return ($a % 2 == 1) ? 1 : -1;
        });
        return $arr;
    }
}
```


效果:

> 执行用时 : 708 ms, 在Sort Array By Parity的PHP提交中击败了 5.13% 的用户
> 
> 内存消耗 : 15.7 MB, 在Sort Array By Parity的PHP提交中击败了 92.00% 的用户


`usort`函数的应用.


## 908. Smallest Range I

题目描述:

Given an array `array` of integers, for each integer `array[i]` we may choose any x with `-bound <= x <= bound`, and add `x` to `array[i]`.

After this process, we have some array `result`.

Return the smallest possible difference between the maximum value of `result` and the minimum value of `result`.

 

**Example 1:**

<pre>
<strong>Input:</strong> array = [1], K = 0
<strong>Output:</strong> 0
<strong>Explanation:</strong> result = [1]
</pre>


**Example 2:**

<strong>Input:</strong> array = [0,10], K = 2
<strong>Output:</strong> 6
<strong>Explanation:</strong> result = [2,8]

**Example 3:**

<strong>Input:</strong> array = [1,3,6], K = 3
<strong>Output:</strong> 0
<strong>Explanation:</strong> result = [3,3,3] or result = [4,4,4]
 

**Note:**

* `1 <= array.length <= 10000`
* `0 <= array[i] <= 10000`
* `0 <= bound <= 10000`


解答:


```php
class Solution
{

    /**
     * @param Integer[] $array
     * @param Integer $bound
     * @return Integer
     */
    function smallestRangeI($array, $bound)
    {
        return max(0, max($array) - min($array) - 2 * $bound);
    }
}

```

效果:

> 执行用时: 48 ms, 在所有 PHP 提交中击败了 66.67% 的用户
>
> 内存消耗: 16.3 MB, 在所有 PHP 提交中击败了 100.00% 的用户






## 912. Sort an Array

题目描述:



Given an array of integers `nums`, sort the array in ascending order.

 

**Example 1:**


<pre>
<strong>Input:</strong> [5,2,3,1]
<strong>Output:</strong> [1,2,3,5]
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> [5,1,1,2,0,0]
<strong>Output:</strong> [0,0,1,1,2,5]
</pre>

**Note:**

1. `1 <= A.length <= 10000`
2. `-50000 <= A[i] <= 50000`



解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer[]
     */
    function sortArray($nums) 
    {
        sort($nums, SORT_NUMERIC);
        return $nums;
    }
}
```

效果:

> 执行用时 : 56 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 22.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


要是觉着自己比语言开发组牛逼, 那就可以造一个排序的轮子, 我没任何意见.


## 914. X of a Kind in a Deck of Cards


题目描述:


In a deck of cards, each card has an integer written on it.

Return `true` if and only if you can choose `X >= 2` such that it is possible to split the entire deck into 1 or more groups of cards, where:

* Each group has exactly `X` cards.
* All the cards in each group have the same integer.
 

**Example 1:**


<pre>
<strong>Input:</strong> [1,2,3,4,4,3,2,1]
<strong>Output:</strong> true
<strong>Explanation:</strong> Possible partition [1,1],[2,2],[3,3],[4,4]
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> [1,1,1,2,2,2,3,3]
<strong>Output:</strong> false
<strong>Explanation:</strong> No possible partition.
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> [1]
<strong>Output:</strong> false
<strong>Explanation:</strong> No possible partition.
</pre>


**Example 4:**


<pre>
<strong>Input:</strong> [1,1]
<strong>Output:</strong> true
<strong>Explanation:</strong> Possible partition [1,1]
</pre>


**Example 5:**


<pre>
<strong>Input:</strong> [1,1,2,2,2,2]
<strong>Output:</strong> true
<strong>Explanation:</strong> Possible partition [1,1],[2,2],[2,2]
</pre>

**Note:**

1. `1 <= deck.length <= 10000`
2. `0 <= deck[i] < 10000`


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $deck
     * @return Boolean
     */
    function hasGroupsSizeX($deck) 
    {
        $integerInfo = array_count_values($deck);
        $countArray = array_unique(array_values($integerInfo));
        $size = count($countArray);
        $minCount = min($countArray);
        if ($minCount <= 1) {
            return false;
        }
        for ($i = 2; $i <= $minCount; $i++) {
            $remainderArray = array_map($callback = function ($count) use ($i) {
                return ($count % $i);
            }, $countArray);
            if (array_sum($remainderArray) === 0) {
                return true;
            }
        }
        return false;
    }
}
```

效果:

> 执行用时 : 44 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 16 MB, 在所有 PHP 提交中击败了 100.00% 的用户


竟然写出这种效果, 真是受宠若惊...

例子写得很良心了, 看完前两个差不多就知道该干啥了. 想法很简单, 就是看各个整数的个数的最大公约数是否大于等于2. 当然你这个最大公约数不会大于数组中的最小元素.

写回调的时候注意 `use` 变量的场合.


## 917. Reverse Only Letters

题目描述:


Given a string `str`, return the "reversed" string where all characters that are not a letter stay in the same place, and all letters reverse their positions.

 

**Example 1:**


<pre>
<strong>Input:</strong> "ab-cd"
<strong>Output:</strong> "dc-ba"
</pre>



**Example 2:**


<pre>
<strong>Input:</strong> "a-bC-dEf-ghIj"
<strong>Output:</strong> "j-Ih-gfE-dCba"
</pre>

**Example 3:**


<pre>
<strong>Input:</strong> "Test1ng-Leet=code-Q!"
<strong>Output:</strong> "Qedo1ct-eeLg=ntse-T!"
</pre>

**Note:**

1. `str.length <= 100`
2. `33 <= str[i].ASCIIcode <= 122` 
3. `str` doesn't contain `\` or `"`


解答: 


```php
class Solution {

    /**
     * @param String $str
     * @return String
     */
    function reverseOnlyLetters($str) 
    {
        $letterCollection = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
        $letterArray = [];
        $strArray = str_split($str);
        $count = count($strArray);
        for ($i = 0; $i < $count; $i++) {
            if (in_array($strArray[$i], $letterCollection)) {
                $letterArray[] = $strArray[$i];
                $strArray[$i] = "";
            }
        }

        for ($i = 0; $i < $count; $i++) {
            if ($strArray[$i] === "") {
                $strArray[$i] = array_pop($letterArray);
            }
        }
        return implode($strArray);
    }
}
```

效果:

> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 83.33% 的用户

和345. Reverse Vowels of a String差不多.


## 922. Sort Array By Parity II


Given an array `array` of non-negative integers, half of the integers in `array` are odd, and half of the integers are even.

Sort the array so that whenever `array[i]` is odd, `i` is odd; and whenever `array[i]` is even, `i` is even.

You may return any answer array that satisfies this condition.

 

**Example 1:**


<pre>
<strong>Input:</strong> [4,2,5,7]
<strong>Output:</strong> [4,5,2,7]
<strong>Explanation:</strong> [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.
</pre>

**Note:**

1. `2 <= array.length <= 20000`
2. `array.length % 2 == 0`
3. `0 <= array[i] <= 1000`


解答 1:


```php
class Solution 
{

    /**
     * @param Integer[] $array
     * @return Integer[]
     */
    function sortArrayByParityII($array) 
    {
        $odds = array_values(array_filter($array, $callback = function ($element) {
            return ($element % 2 === 1);
        }));
        $evens = array_values(array_filter($array, $callback = function ($element) {
            return ($element % 2 === 0);
        }));
        $half_capacity = count($array) / 2;
        for ($i = 0; $i < $half_capacity; $i++) {
            $array[2 * $i] = $evens[$i];
            $array[2 * $i + 1] = $odds[$i];
        }
        return $array;
    }
}
```


效果 1:

> 执行用时: 96 ms, 在所有 PHP 提交中击败了 64.00% 的用户
> 
> 内存消耗: 19.6 MB, 在所有 PHP 提交中击败了 9.09% 的用户

直接来了个糙快猛的做法. 注意 `array_filter()` 结果是保留原先的键值对应关系的. 你得到奇数或偶数之后, 另一半可以通过取差集也就是 `array_diff()` 来获得.

解答 2:

```php
class Solution 
{

    /**
     * @param Integer[] $array
     * @return Integer[]
     */
    function sortArrayByParityII($array) 
    {
        $capacity = count($array);
        $even_position = $capacity - 2;
        for ($odd_position = $capacity - 1; $odd_position > 0; $odd_position = $odd_position - 2) {
            if ($array[$odd_position] % 2 !== $odd_position % 2) {
                while ($array[$even_position] % 2 === $even_position % 2) {
                    $even_position = $even_position - 2;
                }
                [$array[$odd_position], $array[$even_position]] = [$array[$even_position], $array[$odd_position]];
            }
        }
        return $array;
    }
}
```

效果 2:

> 执行用时: 84 ms, 在所有 PHP 提交中击败了 92.00% 的用户
> 
> 内存消耗: 18.5 MB, 在所有 PHP 提交中击败了 36.36% 的用户



## 941. Valid Mountain Array

题目描述:

Given an array `arr` of integers, return `true` if and only if it is a *valid mountain array*.

Recall that `arr` is a mountain array if and only if:

* `arr.length >= 3`
* There exists some `i` with `0 < i < arr.length - 1` such that:
  * `arr[0] < arr[1] < ... arr[i-1] < arr[i]`
  * `arr[i] > arr[i+1] > ... > arr[arr.length - 1]`
 

**Example 1:**


<pre>
<strong>Input:</strong> [2,1]
<strong>Output:</strong> false
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> [3,5,5]
<strong>Output:</strong> false
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> [0,3,2,1]
<strong>Output:</strong> true
</pre>


**Note:**

1. `0 <= arr.length <= 10000`
2. `0 <= arr[i] <= 10000`


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $arr
     * @return Boolean
     */
    function validMountainArray($arr) 
    {
        $count = count($arr);
        if ($count < 3) {
            return false;
        }
        $max = max($arr);
        $indexOfMax = array_search($max, $arr);
        if ($arr[0] === $max || $arr[$count - 1] === $max) {
            return false;
        }
        for ($i = 0; $i < $indexOfMax; $i++) {
            if ($arr[$i] >= $arr[$i + 1]) {
                return false;
            }
        }
        for ($i = $indexOfMax; $i < $count - 1; $i++) {
            if ($arr[$i] <= $arr[$i + 1]) {
                return false;
            }
        }
        return true;
    }
}
```

效果:

> 执行用时 : 76 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 16.3 MB, 在所有 PHP 提交中击败了 100.00% 的用户


在组合数学中, 有个类似的概念叫单峰性, 当然了, 一般是用在二项式这方面. 念书的时候教我高代的一位[王教授](http://faculty.dlut.edu.cn/1988011006/zh_CN/index.htm)是做组合数学的, 也做过单峰性这方面儿的研究. 上课听他吹了不少组合数学的事儿讲了不少梗, 记得当时还找这位王老师借了本儿一位记者写的讲John Nash的书和E.T.Bell写的《数学大师》...这么多年过去了, 不知道王老师是否做出了更酷炫的结果.

扯远了. 这个题目主要是注意边界情况的处理, 崩的话都是崩在边界情况.


## 961. N-Repeated Element in Size 2N Array


题目描述:

In a array `arr` of size `2N`, there are `N+1` unique elements, and exactly one of these elements is repeated `N` times.

Return the element repeated `N` times.

 

**Example 1:**


<pre>
Input: [1,2,3,3]
Output: 3
</pre>


**Example 2:**


<pre>
Input: [2,1,2,5,3,2]
Output: 2
</pre>


**Example 3:**


<pre>
Input: [5,1,5,2,5,3,5,4]
Output: 5
</pre>

**Note:**


1. 4 <= arr.length <= 10000
2. 0 <= arr[i] < 10000
3. arr.length is even


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $arr
     * @return Integer
     */
    function repeatedNTimes($arr) 
    {
        $half_count = count($arr) / 2;
        // PHP是最好的语言!
        $time_count = array_count_values($arr);
        foreach ($time_count as $key => $value) {
            if ($value == $half_count) {
                return $key;
            }
        }
    }
}
```

效果:

> 执行用时 : 84 ms, 在N-Repeated Element in Size 2N Array的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 16.2 MB, 在N-Repeated Element in Size 2N Array的PHP提交中击败了 10.00% 的用户



## 970. Powerful Integers


题目描述:


Given two positive integers `x` and `y`, an integer is *powerful* if it is equal to `x^i + y^j` for some integers `i >= 0` and `j >= 0`.

Return a list of all *powerful* integers that have value less than or equal to `bound`.

You may return the answer in any order.  In your answer, each value should occur at most once.

 

**Example 1:**


<pre>
<strong>Input:</strong> x = 2, y = 3, bound = 10
<strong>Output:</strong> [2,3,4,5,7,9,10]
<strong>Explanation:</strong> 
2 = 2^0 + 3^0
3 = 2^1 + 3^0
4 = 2^0 + 3^1
5 = 2^1 + 3^1
7 = 2^2 + 3^1
9 = 2^3 + 3^0
10 = 2^0 + 3^2
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> x = 3, y = 5, bound = 15
<strong>Output:</strong> [2,4,6,8,10,14]
</pre>

 

**Note:**

* `1 <= x <= 100`
* `1 <= y <= 100`
* `0 <= bound <= 10^6`



解答:


```php
class Solution 
{

    /**
     * @param Integer $x
     * @param Integer $y
     * @param Integer $bound
     * @return Integer[]
     */
    function powerfulIntegers($x, $y, $bound) 
    {
        $powerBaseX = 0;
        if ($x !== 1) {
            $powerBaseX = floor(log($bound, $x));
        }
        $powerBaseY = 0;
        if ($y !== 1) {
            $powerBaseY = floor(log($bound, $y));
        }
        $powerfulIntegerArray = [];
        for ($i = 0; $i <= $powerBaseX; $i++) {
            for ($j = 0; $j <= $powerBaseY; $j++) {
                $powerfulInteger = $x ** $i + $y ** $j;
                if ($powerfulInteger <= $bound) {
                    $powerfulIntegerArray[] = $powerfulInteger;
                }
            }
        }
        return array_unique($powerfulIntegerArray);
    }
}
```


效果:


> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在所有 PHP 提交中击败了 100.00% 的用户


关键是注意这个底数为1的情况, 得单独拿出来讨论.


## 973. K Closest Points to Origin

题目描述:


We have a list of `points` on the plane.  Find the `k` closest points to the origin `(0, 0)`.

(Here, the distance between two points on a plane is the Euclidean distance.)

You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)

 

**Example 1:**


<pre>
<strong>Input:</strong> points = [[1,3],[-2,2]], k = 1
<strong>Output:</strong> [[-2,2]]
<strong>Explanation:</strong> 
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].
</pre>



**Example 2:**


<pre>
<strong>Input:</strong> points = [[3,3],[5,-1],[-2,4]], k = 2
<strong>Output:</strong> [[3,3],[-2,4]]
(The answer [[-2,4],[3,3]] would also be accepted.)
</pre>
 

**Note:**

1. `1 <= k <= points.length <= 10000`
2. `-10000 < points[i][0] < 10000`
3. `-10000 < points[i][1] < 10000`


解答:

```php
class Solution 
{

    /**
     * @param Integer[][] $points
     * @param Integer $k
     * @return Integer[][]
     */
    function kClosest($points, $k) 
    {
        // PHP是最好的语言!!!
        usort($points, $comparator = function ($point1, $point2) {
            return ($point1[0] * $point1[0] + $point1[1] * $point1[1] > $point2[0] * $point2[0] + $point2[1] * $point2[1]);
        });
        return array_slice($points, 0, $k);
    }
}
```

效果:

> 执行用时 : 576 ms, 在所有 PHP 提交中击败了 80.00% 的用户
> 
> 内存消耗 : 28.3 MB, 在所有 PHP 提交中击败了 100.00% 的用户


注意看一下[PHP手册](https://www.php.net/manual/zh/language.types.array.php), 手册上很明确地说了:

> 数组和对象*不能*被用为键名。坚持这么做会导致警告：Illegal offset type


所以你想建立平面点到和点到原点距离的想法是不能直接实现的...

以后要是混上技术面主管的话, 347. Top K Frequent Elements、692. Top K Frequent Words和这个973. K Closest Points to Origin我肯定是会从里面出题考的...


## 976. Largest Perimeter Triangle

题目描述:

Given an array `nums` of positive lengths, return the largest perimeter of a triangle with **non-zero area**, formed from 3 of these lengths.

If it is impossible to form any triangle of non-zero area, return `0`.

 

**Example 1:**


<pre>
Input: [2,1,2]
Output: 5
</pre>


**Example 2:**


<pre>
Input: [1,2,1]
Output: 0
</pre>


**Example 3:**


<pre>
Input: [3,2,3,4]
Output: 10
</pre>


**Example 4:**


<pre>
Input: [3,6,2,3]
Output: 8
</pre>



**Note:**

1. 3 <= nums.length <= 10000
2. 1 <= nums[i] <= 10^6


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function largestPerimeter($nums) 
    {
        rsort($nums);
        $count = count($nums);
        for ($i = 0; $i < $count - 2; $i++) {
            if ($nums[$i] < $nums[$i + 1] + $nums[$i + 2]) {
                return $nums[$i] + $nums[$i + 1] + $nums[$i + 2];
            }
        }
        return 0;
    }
}
```

效果:

> 执行用时 : 100 ms, 在Largest Perimeter Triangle的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 16.1 MB, 在Largest Perimeter Triangle的PHP提交中击败了 71.43% 的用户


## 977. Squares of a Sorted Array


题目描述:

Given an array of integers `arr` sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.

 

**Example 1:**


<pre>
Input: [-4,-1,0,3,10]
Output: [0,1,9,16,100]
</pre>



**Example 2:**


<pre>
Input: [-7,-3,2,3,11]
Output: [4,9,9,49,121]
</pre>



**Note:**


1. `1 <= arr.length <= 10000`
2. `-10000 <= arr[i] <= 10000`
3. `arr` is sorted in non-decreasing order.


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $arr
     * @return Integer[]
     */
    function sortedSquares($arr) 
    {
        $arr = array_map($square = function ($a) {
            return $a * $a;
        }, $arr);
        sort($arr, SORT_NUMERIC);
        return $arr;
    }
}
```

效果:

> 执行用时 : 124 ms, 在Squares of a Sorted Array的PHP提交中击败了 73.47% 的用户
> 
> 内存消耗 : 17.3 MB, 在Squares of a Sorted Array的PHP提交中击败了 87.93% 的用户


注意: `array_map`函数返回的是一个数组. 较`array_walk`函数而言, `array_map`可以直接对数组中元素进行操作.

## 989. Add to Array-Form of Integer


题目描述:

For a non-negative integer `X`, the *array-form* of <code><em>X</em></code> is an array of its digits in left to right order.  For example, if `X = 1231`, then the array form is `[1,2,3,1]`.

Given the array-form `arr` of a non-negative integer `X`, return the array-form of the integer `X+num`.

 

**Example 1:**


```
Input: arr = [1,2,0,0], num = 34
Output: [1,2,3,4]
Explanation: 1200 + 34 = 1234
```


**Example 2:**


```
Input: arr = [2,7,4], num = 181
Output: [4,5,5]
Explanation: 274 + 181 = 455
```



**Example 3:**


```
Input: arr = [2,1,5], num = 806
Output: [1,0,2,1]
Explanation: 215 + 806 = 1021
```


**Example 4:**


```
Input: arr = [9,9,9,9,9,9,9,9,9,9], num = 1
Output: [1,0,0,0,0,0,0,0,0,0,0]
Explanation: 9999999999 + 1 = 10000000000
```
 

**Note：**

1. `1 <= arr.length <= 10000`
2. `0 <= arr[i] <= 9`
3. `0 <= num <= 10000`
4. If `arr.length > 1`, then `arr[0] != 0`


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $arr
     * @param Integer $num
     * @return Integer[]
     */
    function addToArrayForm($arr, $num) 
    {
        if ($arr === [0] && $num === 0) {
            return [0];
        }
        $num1Len = count($arr);
        $num1Str = implode('', $arr);
        $num2Str = strval($num);
        $num2Len = strlen($num2Str);
        $largerLen = max($num1Len, $num2Len);
        // 初始化一个容量为两个数长度较大的那个长度+1的数组用来存放结果, 因为结果最长不会超过这个容量. 
        $resultArr = array_fill(0, $largerLen + 1, 0);
        // 在加数前面补0直到位数一样(较大的位数). 
        $paddedNum1 = str_pad($num1Str, $largerLen, '0', STR_PAD_LEFT);
        $paddedNum2 = str_pad($num2Str, $largerLen, '0', STR_PAD_LEFT);
        for ($i = $largerLen - 1; $i >= 0; $i--) {
            // 同一位置的对应位相加再加上本来有的位(就是进位)再做处理的中间结果
            $temp = $paddedNum1[$i] + $paddedNum2[$i] + $resultArr[$i + 1];
            $resultArr[$i + 1] = $temp % 10;
            $resultArr[$i] += floor($temp / 10); // 高位就是乘完加进位取整除以10  
        }
        // 去掉数组前面的0. PHP是最好的语言!
        while ($resultArr[0] == 0) {
            array_shift($resultArr);
        }
        return $resultArr;
    }
}
```

效果:

> 执行用时 : 128 ms, 在所有 PHP 提交中击败了 75.00% 的用户
> 
> 内存消耗 : 16.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


同67. Add Binary、415. Add Strings. 想法都是共通的. 也是对`array_shift()`函数的一个应用.


## 997. Find the Town Judge

题目描述:


In a town, there are `n` people labelled from `1` to `n`.  There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

1. The town judge trusts nobody.
2. Everybody (except for the town judge) trusts the town judge.
3. There is exactly one person that satisfies properties 1 and 2.

You are given `trust`, an array of pairs `trust[i] = [a, b]` representing that the person labelled `a` trusts the person labelled `b`.

If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return `-1`.

 

**Example 1:**


<pre>
<strong>Input:</strong> n = 2, trust = [[1,2]]
<strong>Output:</strong> 2
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> n = 3, trust = [[1,3],[2,3]]
<strong>Output:</strong> 3
</pre>

**Example 3:**


<pre>
<strong>Input:</strong> n = 3, trust = [[1,3],[2,3],[3,1]]
<strong>Output:</strong> -1
</pre>


**Example 4:**


<pre>
<strong>Input:</strong> n = 3, trust = [[1,2],[2,3]]
<strong>Output:</strong> -1
</pre>


**Example 5:**


<pre>
<strong>Input:</strong> n = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
<strong>Output:</strong> 3
</pre>

**Note:**

1. `1 <= n <= 1000`
2. `trust.length <= 10000`
3. `trust[i]` are all different
4. `trust[i][0] != trust[i][1]`
5. `1 <= trust[i][0], trust[i][1] <= n`

解答:

```php
class Solution 
{

    /**
     * @param Integer $n
     * @param Integer[][] $trust
     * @return Integer
     */
    function findJudge($n, $trust) 
    {
        // 注意把这个情况摘出来.
        if ($n === 1) {
            return 1;
        }
        $truster_array = array_column($trust, 0);
        $trustee_array = array_column($trust, 1);
        $trustee_info = array_count_values($trustee_array);
        $judge_array = array_diff(range(1, $n), $truster_array);
        if (!empty($judge_array)) {
            $judge = array_values($judge_array)[0];
            if ($trustee_info[$judge] === $n - 1) {
                return $judge;
            }
        }
        return -1;
    }
}
```

效果:

> 执行用时 : 404 ms, 在所有 PHP 提交中击败了 87.50% 的用户
> 
> 内存消耗 : 28.3 MB, 在所有 PHP 提交中击败了 71.43% 的用户

主要是要注意两个要素: 

1. 法官不信任任何人(取差集); 
2. 所有人都信任法官(法官对应的被相信数为总人数减一).

要是我混上面试的技术主管的话肯定也会拿这个题考人.


## 1002. Find Common Characters

题目描述:

Given an array `array` of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (**including duplicates**).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.

You may return the answer in any order.

 

**Example 1:**

<pre>
<strong>Input:</strong> ["bella","label","roller"]
<strong>Output:</strong> ["e","l","l"]
</pre>


**Example 2:**

<pre>
<strong>Input:</strong> ["cool","lock","cook"]
<strong>Output:</strong> ["c","o"]
</pre>


**Note:**

1. `1 <= array.length <= 100`
2. `1 <= array[i].length <= 100`
3. `array[i][j]` is a lowercase letter


解答 1:

```php
class Solution 
{

    /**
     * @param String[] $array
     * @return String[]
     */
    function commonChars($array)
    {
        $byteValueInfos = array_map($callback = function ($element) {
            return count_chars($element, 1);
        }, $array);

        $byteValues = array_map("array_keys", $byteValueInfos);

        // 获取所有单词都有的字母对应的 byteValue.
        // commonByteValues: 所有单词都有的字母对应的 byte value.
        $commonByteValues = array_intersect(...$byteValues);

        // 没有共同字母的话, 就返回一个空数组.
        if (empty($commonByteValues)) {
            return [];
        }

        // 有交集的话, 先形成一个共同字母 - 共同字母出现次数的关联数组.
        $commonCharInfos = [];
        foreach ($commonByteValues as $byteValue) {
            $counts = [];
            foreach ($byteValueInfos as $byteValueInfo) {
                $counts[] = $byteValueInfo[$byteValue];
            }
            $commonCharInfos[chr($byteValue)] = min($counts);
        }

        $result = [];
        foreach ($commonCharInfos as $commonChar => $count) {
            $result = array_merge($result, array_fill(0, $count, $commonChar));
        }

        return $result;
    }
}
```

效果 1:

> 执行用时: 20 ms, 在所有 PHP 提交中击败了 88.89% 的用户
> 
> 内存消耗: 15.3 MB, 在所有 PHP 提交中击败了 20.00% 的用户


这个地方可以用 `array_map()` 写得优雅一些:

```php
foreach ($commonByteValues as $byteValue) {
    $counts = [];
    foreach ($byteValueInfos as $byteValueInfo) {
        $counts[] = $byteValueInfo[$byteValue];
    }
    $commonCharInfos[chr($byteValue)] = min($counts);
}
```

解答 2:

```php
class Solution 
{

    /**
     * @param String[] $array
     * @return String[]
     */
    function commonChars($array)
    {
        $byteValueInfos = array_map($callback = function ($element) {
            return count_chars($element, 1);
        }, $array);

        $byteValues = array_map("array_keys", $byteValueInfos);

        // 获取所有单词都有的字母对应的 byteValue.
        // commonByteValues: 所有单词都有的字母对应的 byte value.
        $commonByteValues = array_intersect(...$byteValues);

        // 没有共同字母的话, 就返回一个空数组.
        if (empty($commonByteValues)) {
            return [];
        }

        // 有交集的话, 先形成一个共同字母 - 共同字母出现次数的关联数组.
        $commonCharInfos = [];
        foreach ($commonByteValues as $byteValue) {
            // 统计共同字母在每个单词中出现的次数, 然后取最小值存到字典里.
            $counts = array_map($callback = function ($info) use ($byteValue) {
                return $info[$byteValue];
            }, $byteValueInfos);
            $commonCharInfos[chr($byteValue)] = min($counts);
        }

        $result = [];
        foreach ($commonCharInfos as $commonChar => $count) {
            $result = array_merge($result, array_fill(0, $count, $commonChar));
        }

        return $result;
    }
}
```

效果 2:

> 执行用时: 16 ms, 在所有 PHP 提交中击败了 88.89% 的用户
> 
> 内存消耗: 15.4 MB, 在所有 PHP 提交中击败了 20.00% 的用户

也可以拿 `substr_count()` 去数, 不过这样会比较慢.


解答 3(数组版做法):

```php
class Solution 
{

    /**
     * @param String[] $array
     * @return String[]
     */
    function commonChars($array)
    {
        $char_array_collection = array_map($callback = function ($word) {
            return str_split($word);
        }, $array);
        $common_char_set = array_unique(array_intersect(...$char_array_collection));
        if (empty($common_char_set)) {
            return [];
        }
        $common_char_info_array = [];
        foreach ($common_char_set as $common_char) {
            $char_count_array = array_map($callback = function ($char_array) use ($common_char) {
                return count(array_keys($char_array, $common_char));
            }, $char_array_collection);
            $common_char_info_array[$common_char] = min($char_count_array);
        }
        $common_char_list = [];
        foreach ($common_char_info_array as $common_char => $count) {
            $common_char_list = array_merge($common_char_list, array_fill(0, $count, $common_char));
        }
        return $common_char_list;
    }
}
```

效果:

> 执行用时: 28 ms, 在所有 PHP 提交中击败了 44.44% 的用户
> 
> 内存消耗: 16 MB, 在所有 PHP 提交中击败了 20.00% 的用户


还不如直接用字符串做, 写完以后才发现并没有什么明显的好处...


## 1009. Complement of Base 10 Integer

题目描述:

Every non-negative integer `N` has a binary representation. For example, `5` can be represented as `"101"` in binary, `11` as `"1011"` in binary, and so on. Note that except for `N = 0`, there are no leading zeroes in any binary representation.

The *complement* of a binary representation is the number in binary you get when changing every `1` to a `0` and `0` to a `1`.  For example, the complement of `"101"` in binary is `"010"` in binary.

For a given number `N` in base-10, return the complement of it's binary representation as a base-10 integer.


**Example 1:**

```
Input: 5
Output: 2
Explanation: 5 is "101" in binary, with complement "010" in binary, which is 2 in base-10.
```


**Example 2:**

```
Input: 7
Output: 0
Explanation: 7 is "111" in binary, with complement "000" in binary, which is 0 in base-10.
```


**Example 3:**

```
Input: 10
Output: 5
Explanation: 10 is "1010" in binary, with complement "0101" in binary, which is 5 in base-10.
``` 

**Note:**

> 1. 0 <= N < 10^9

解答:

```php
class Solution 
{

    /**
     * @param Integer $N
     * @return Integer
     */
    function bitwiseComplement($N) 
    {
        $i = 1;
        while ($N > $i) {
            $i = $i * 2 + 1;
        }
        return $i - $N;
    }
}
```

效果:

> 执行用时 : 8 ms, 在Complement of Base 10 Integer的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.8 MB, 在Complement of Base 10 Integer的PHP提交中击败了 20.00% 的用户



## 1013. Partition Array Into Three Parts With Equal Sum


题目描述:

Given an array `array` of integers, return `true` if and only if we can partition the array into three **non-empty** parts with equal sums.

Formally, we can partition the array if we can find indexes `i+1 < j` with `(A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])`

 

**Example 1:**

<pre>
<strong>Input:</strong> [0,2,1,-6,6,-7,9,1,2,0,1]
<strong>Output:</strong> true
<strong>Explanation:</strong> 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
</pre>


**Example 2:**

<pre>
<strong>Input:</strong> [0,2,1,-6,6,7,9,-1,2,0,1]
<strong>Output:</strong> false
</pre>

**Example 3:**


<pre>
<strong>Input:</strong> [3,3,6,5,-2,2,5,1,-9,4]
<strong>Output:</strong> true
<strong>Explanation:</strong> 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4
</pre>


**Note:**

1. `3 <= array.length <= 50000`
2. `-10000 <= array[i] <= 10000`


解答:


```php
class Solution 
{

    /**
     * @param Integer[] $array
     * @return Boolean
     */
    function canThreePartsEqualSum($array) 
    {
        $sum = array_sum($array);
        if ($sum % 3 != 0) {
            return false;
        }
        $partion = $sum / 3;
        $count = count($array);
        $header_sum = 0;
        $front_delimiter = -1;
        for ($i = 0; $i < $count; $i++) {
            $header_sum += $array[$i];
            if ($header_sum === $partion) {
                $front_delimiter = $i;
                break;
            }
        }
        $footer_sum = 0;
        $end_delimiter = $count;
        for ($j = $count - 1; $j >= 0; $j--) {
            $footer_sum += $array[$j];
            if ($footer_sum === $partion) {
                $end_delimiter = $j;
                break;
            }
        }
        if ($front_delimiter >= 0 && $end_delimiter > $front_delimiter && $end_delimiter < $count) {
            return true;
        }
        return false;
    }
}
```

效果:

> 执行用时 : 144 ms, 在所有 PHP 提交中击败了 90.00% 的用户
> 
> 内存消耗 : 21.4 MB, 在所有 PHP 提交中击败了 100.00% 的用户


注意题目要的是三个非空的, 再就是比较善良的是这个题目的三个非空的都是各自下标连续的.


## 1029. Two City Scheduling

题目描述:

There are `2N` people a company is planning to interview. The cost of flying the `i`-th person to city `A` is `costs[i][0]`, and the cost of flying the `i`-th person to city `B` is `costs[i][1]`.

Return the minimum cost to fly every person to a city such that exactly `N` people arrive in each city.


**Example 1:**


<pre>
<strong>Input:</strong> [[10,20],[30,200],[400,50],[30,20]]
<strong>Output:</strong> 110
<strong>Explanation:</strong> 
The first person goes to city A for a cost of 10.
The second person goes to city A for a cost of 30.
The third person goes to city B for a cost of 50.
The fourth person goes to city B for a cost of 20.

The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.
</pre>


**Note:**

* `1 <= costs.length <= 100`
* It is guaranteed that `costs.length` is even.
* `1 <= costs[i][0], costs[i][1] <= 1000`


解答:

```php
class Solution 
{

    /**
     * @param Integer[][] $costs
     * @return Integer
     */
    function twoCitySchedCost($costs) 
    {
        usort($costs, $comparator = function($cost1, $cost2) {
            // 语言环境是PHP 7.2, 所以可以用太空船运算符.
            return (($cost2[1] - $cost2[0]) <=> ($cost1[1] - $cost1[0]));
        });
        $count = count($costs);
        $halfCount = $count / 2;
        $minTotalCost = 0;
        for ($i = 0; $i < $count; $i++) {
            if ($i < $halfCount) {
                $minTotalCost += $costs[$i][0];
            }
            if ($i >= $halfCount) {
                $minTotalCost += $costs[$i][1];
            }
        }
        return $minTotalCost;
    }
}
```


效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 15 MB, 在所有 PHP 提交中击败了 100.00% 的用户


以每组费用到B的花费和到A的花费的差值作为排序的标准, 差值大就意味着到A划算, 反之就是到B划算. 

貌似也是我头一次用到太空船运算符...



## 1046. Last Stone Weight

**题目描述:**

We have a collection of rocks, each rock has a positive integer weight.

Each turn, we choose the two **heaviest** rocks and smash them together.  Suppose the stones have weights `x` and `y` with `x <= y`.  The result of this smash is:

* If `x == y`, both stones are totally destroyed;
* If `x != y`, the stone of weight `x` is totally destroyed, and the stone of weight `y` has new weight `y-x`.


At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)

 

**Example 1:**


<pre>
<strong>Input:</strong> [2,7,4,1,8,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> 
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.
</pre>

**Note:**

1. `1 <= stones.length <= 30`
2. `1 <= stones[i] <= 1000`

解答:

```php
class Solution 
{

    /**
     * @param Integer[] $stones
     * @return Integer
     */
    function lastStoneWeight($stones) 
    {
        rsort($stones);
        while (count($stones) > 1) {
            $firstHeaviest = array_shift($stones);
            $secondHeaviest = array_shift($stones);
            if ($firstHeaviest - $secondHeaviest != 0) {
                $difference = abs($firstHeaviest - $secondHeaviest);
                array_unshift($stones, $difference);
                rsort($stones);
            }
        }
        return count($stones) == 0 ? 0 : $stones[0];
    }
}
```


效果:

> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户


第把想用`array_reduce()`函数写, 不过这个回调函数好像不太好弄...

## 1047. Remove All Adjacent Duplicates In String

题目描述:

Given a string `str` of lowercase letters, a *duplicate removal* consists of choosing two adjacent and equal letters, and removing them.

We repeatedly make duplicate removals on str until we no longer can.

Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.

 

**Example 1:**


<pre>
<strong>Input:</strong> "abbaca"
<strong>Output:</strong> "ca"
<strong>Explanation:</strong> 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
</pre>

**Note:**

1. `1 <= str.length <= 20000`
2. `str`consists only of English lowercase letters.



解答1:

```php
class Solution 
{

    /**
     * @param String $str
     * @return String
     */
    function removeDuplicates($str) 
    {
        do {
            $str = str_replace(["aa", "bb", "cc", "dd", "ee", "ff", "gg", "hh", "ii", "jj", "kk", "ll", "mm", "nn", "oo", "pp", "qq", "rr", "ss", "tt", "uu", "vv", "ww", "xx", "yy", "zz"], "", $str, $count);
        } while ($count > 0);
        return $str;
    }
}
```


效果1: 

> 执行用时 : 40 ms, 在所有 PHP 提交中击败了 81.25% 的用户
> 
> 内存消耗 : 14.5 MB, 在所有 PHP 提交中击败了 100.00% 的用户



解答2:

```php
class Solution 
{

    /**
     * @param String $str
     * @return String
     */
    function removeDuplicates($str) 
    {
        do {
            $str = preg_replace('/([a-z])\1/', "", $str, -1, $count);
        } while ($count > 0);
        return $str;
    }
}
```


效果2:

> 执行用时 : 24 ms, 在所有 PHP 提交中击败了 93.75% 的用户
> 
> 内存消耗 : 14.9 MB, 在所有 PHP 提交中击败了 100.00% 的用户




同20. Valid Parentheses.


用正则表达式的时候, 模式字符串是用半角单引号对来引, 而不是拿半角双引号对来引, 这个非常容易坑!!! 当然了, 我平时写正则表达式确实也是比较少就是了...

如果你想匹配连续相同的3位小写英文字母字符串, 那模式就是 `'/([a-z])\1{2}/'`; 想匹配连续相同的4位数字字符串, 那模式就是 `'/([0-9])\1{3}/'`. 注意这个题你上 `'/([a-z]){2}/'` 的话并不会得到想要的结果.

## 1050. Actors and Directors Who Cooperated At Least Three Times (上锁题目, 需要氪会员)


题目描述:

`Table: ActorDirector`


```
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| actor_id    | int     |
| director_id | int     |
| timestamp   | int     |
+-------------+---------+
timestamp is the primary key column for this table.
```


Write a SQL query for a report that provides the pairs `(actor_id, director_id)` where the actor have cooperated with the director at least 3 times.


**Example:**


```
ActorDirector table:
+-------------+-------------+-------------+
| actor_id    | director_id | timestamp   |
+-------------+-------------+-------------+
| 1           | 1           | 0           |
| 1           | 1           | 1           |
| 1           | 1           | 2           |
| 1           | 2           | 3           |
| 1           | 2           | 4           |
| 2           | 1           | 5           |
| 2           | 1           | 6           |
+-------------+-------------+-------------+

Result table:
+-------------+-------------+
| actor_id    | director_id |
+-------------+-------------+
| 1           | 1           |
+-------------+-------------+
The only pair is (1, 1) where they cooperated exactly 3 times.
```



## 1051. Height Checker



题目描述:


Students are asked to stand in non-decreasing order of heights for an annual photo.

Return the minimum number of students not standing in the right positions.  (This is the number of students that must move in order for all students to be standing in non-decreasing order of height.)

 

**Example 1:**


<pre>
<strong>Input:</strong> [1,1,4,2,1,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
Students with heights 4, 3 and the last 1 are not standing in the right positions.
</pre>

**Note:**

1. `1 <= heights.length <= 100`
2. `1 <= heights[i] <= 100`



解答:


```php
class Solution 
{

    /**
     * @param Integer[] $heights
     * @return Integer
     */
    function heightChecker($heights) 
    {
        $originHeights = $heights;
        sort($heights);
        $wrongPositionCount = 0;
        $count = count($heights);
        for ($i = 0; $i < $count; $i++) {
            if ($heights[$i] !== $originHeights[$i]) {
                $wrongPositionCount += 1;
            }
        }
        return $wrongPositionCount;
    }
}
```

效果:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 68.00% 的用户
> 
> 内存消耗 : 14.6 MB, 在所有 PHP 提交中击败了 100.00% 的用户

先排序, 然后拿排序的结果和原数组比, 计数相同位置值不同的情况.



## 1064. Fixed Point (上锁题目, 需要氪会员)


题目描述:

Given an array `arr` of distinct integers sorted in ascending order, return the smallest index `i` that satisfies `arr[i] == i`. Return `-1` if no such `i` exists.


**Example 1:**

<pre>
<strong>Input:</strong> [-10,-5,0,3,7]
<strong>Output:</strong> 3
<strong>Explanation:</strong> For the given array, <code>arr[0] = -10, arr[1] = -5, arr[2] = 0, arr[3] = 3</code>, thus the output is <code>3</code>.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> [0,2,5,8,17]
<strong>Output:</strong> 0
<strong>Explanation:</strong> <code>arr[0] = 0</code>, thus the output is <code>0</code>.
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> [-10,-5,3,4,7,9]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There is no such <code>i</code> that <code>arr[i] = i</code>, thus the output is <code>-1</code>.
</pre>

**Note:**

1. `1 <= arr.length < 10^4`
2. `-10^9 <= arr[i] <= 10^9`



不知道这个题目的目的是要干什么, 引入不动点的定义嘛...


## 1071. Greatest Common Divisor of Strings

题目描述:


For strings `S` and `T`, we say "`T` divides `S`" if and only if `S = T + ... + T`  (`T` concatenated with itself 1 or more times)

Return the largest string `X` such that `X` divides str1 and `X` divides `str2`.

 

**Example 1:**


<pre>
<strong>Input:</strong> str1 = "ABCABC", str2 = "ABC"
<strong>Output:</strong> "ABC"
</pre>


**Example 2:**

<pre>
<strong>Input:</strong> str1 = "ABABAB", str2 = "ABAB"
<strong>Output:</strong> "AB"
</pre>



**Example 3:**


<pre>
<strong>Input:</strong> str1 = "LEET", str2 = "CODE"
<strong>Output:</strong> ""
</pre>

**Note:**


1. `1 <= str1.length <= 1000`
2. `1 <= str2.length <= 1000`
3. `str1[i]` and `str2[i]` are English uppercase letters.


解答:


```php
class Solution 
{

    /**
     * @param String $str1
     * @param String $str2
     * @return String
     */
    function gcdOfStrings($str1, $str2) 
    {
        $str1Len = strlen($str1);
        $str2Len = strlen($str2);
        if ($str1Len === $str2Len) {
            if ($str1 == $str2) {
                return $str1;
            } else {
                return "";
            }
        } elseif ($str1Len > $str2Len) {
            $temp = substr($str1, $str2Len);
            return self::gcdOfStrings($temp, $str2);
        } else {
            $temp = substr($str2, $str1Len);
            return self::gcdOfStrings($temp, $str1);
        }
        return $str1;
    }
}
```

效果:

> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.5 MB, 在所有 PHP 提交中击败了 100.00% 的用户


更相减损术.


## 1078. Occurrences After Bigram

题目描述:

Given words `first` and `second`, consider occurrences in some `text` of the form "`first second third`", where `second` comes immediately after `first`, and `third` comes immediately after `second`.

For each such occurrence, add "`third`" to the answer, and return the answer.

 

**Example 1:**


<pre>
<strong>Input:</strong> text = "alice is a good girl she is a good student", first = "a", second = "good"
<strong>Output:</strong> ["girl","student"]
</pre>



**Example 2:**


<pre>
<strong>Input:</strong> text = "we will we will rock you", first = "we", second = "will"
<strong>Output:</strong> ["we","rock"]
</pre>


**Note:**

1. `1 <= text.length <= 1000`
2. `text` consists of space separated words, where each word consists of lowercase English letters.
3. `1 <= first.length, second.length <= 10`
4. `first` and `second` consist of lowercase English letters.



解答:


```php
class Solution 
{

    /**
     * @param String $text
     * @param String $first
     * @param String $second
     * @return String[]
     */
    function findOcurrences($text, $first, $second) 
    {
        $parts = explode(" ", $text);
        $count = count($parts);
        $result = [];
        $first_positions = array_keys($parts, $first);
        foreach ($first_positions as $position) {
            if ($position < $count - 2) {
                if ($parts[$position + 1] === $second) {
                    $result[] = $parts[$position + 2];
                }
            }
        }
        return $result;
    }
}
```


效果:


> 执行用时: 8 ms, 在所有 PHP 提交中击败了 86.67% 的用户
> 
> 内存消耗: 14.8 MB, 在所有 PHP 提交中击败了 100.00% 的用户



就按照题目要求写就可以. 好像也很难再写出花了.

也是练习一下 `array_keys()` 函数的用法, 这个函数有时候还是比较有用的.


## 1085. Sum of Digits in the Minimum Number (上锁题目, 需要氪会员)


题目描述:


Given an array `A` of positive integers, let `S` be the sum of the digits of the minimal element of `A`.

Return 0 if `S` is odd, otherwise return 1.

 

**Example 1:**


<pre>
<strong>Input:</strong> [34,23,1,24,75,33,54,8]
<strong>Output:</strong> 0
<strong>Explanation:</strong> 
The minimal element is 1, and the sum of those digits is S = 1 which is odd, so the answer is 0.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> [99,77,33,66,55]
<strong>Output:</strong> 1
<strong>Explanation:</strong> 
The minimal element is 33, and the sum of those digits is S = 3 + 3 = 6 which is even, so the answer is 1.
</pre>

**Note:**

1. `1 <= A.length <= 100`
2. `1 <= A[i].length <= 100`


这个数组元素应该是会给字符串吧...

## 1093. Statistics from a Large Sample

题目描述:

We sampled integers between `0` and `255`, and stored the results in an array `count`:  `count[k]` is the number of integers we sampled equal to `k`.

Return the minimum, maximum, mean, median, and mode of the sample respectively, as an array of **floating point numbers**.  The mode is guaranteed to be unique.

<i>(Recall that the median of a sample is:</i>

* <i>The middle element, if the elements of the sample were sorted and the number of elements is odd;</i>
* <i>The average of the middle two elements, if the elements of the sample were sorted and the number of elements is even.)</i>
 

**Example 1:**

<pre>
<strong>Input:</strong> count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
<strong>Output:</strong> [1.00000,3.00000,2.37500,2.50000,3.00000]
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
<strong>Output:</strong> [1.00000,4.00000,2.18182,2.00000,1.00000]
</pre>

**Constraints:**

1. `count.length == 256`
2. `1 <= sum(count) <= 10^9`
3. The mode of the sample that count represents is unique.
4. Answers within `10^-5` of the true value will be accepted as correct.


解答(超时了):

```php
class Solution 
{

    /**
     * @param Integer[] $nums
     * @return Float[]
     */
    function sampleStats($nums) 
    {
        // 过滤掉没出现在上市队伍中的兄弟. 
        // 已经是值和采样个数对应好的关系, 过滤完之后不需要 sort().
        $nums = array_filter($nums, $callback = function ($element) {
            return $element != 0;
        });
        $capacity = array_sum($nums); // 数组元素个数.
        $sum = 0; // 数组元素之和.
        foreach ($nums as $value => $count) {
            $sum += $value * $count;
        }
        $list = [];
        foreach ($nums as $num => $count) {
            $list = array_merge($list, array_fill(0, $count, $num));
        }
        $minimum = $list[0]; // 最小值
        $maximum = $list[$capacity - 1]; // 最大值
        $mean = $sum / $capacity; // 平均数
        $mode = array_search(max($nums), $nums); // 中位数
        // 下面开始计算众数.
        $median = 0;
        if ($capacity % 2 === 0) {
            $median = ($list[$capacity / 2] + $list[$capacity / 2 - 1]) / 2;
        }
        if ($capacity % 2 === 1) {
            $median = $list[($capacity + 1) / 2];
        }
        return [$minimum, $maximum, $mean, $median, $mode];
    }
}
```

这个解答超时了, 先放着, 以后有灵感了再改. 估计应该是在 `array_fill()` 那炸的. 再就我在本地服务器里拿

```php
$nums = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,257,819,1370,1910,2472,3076,3532,4156,4754,5152,5821,6353,7065,7528,8108,8517,9251,9651,10310,10861,11405,11845,12400,13192,13748,14075,14547,15271,15951,16442,16917,17456,17994,18479,19080,19774,20383,20758,21499,21802,21751,21632,21205,20682,20409,19697,19427,18993,18487,18125,17646,16936,16733,16147,15808,15645,14892,14363,13998,13521,13164,12401,12147,11623,11228,10911,10518,10070,9632,9194,8840,8318,7803,7327,6891,6515,5872,5570,5159,4661,4181,3832,3208,2883,2398,2001,1570,1059,717,229,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
```

的用例也能跑:

![large_sample_result.png](https://i.loli.net/2019/09/02/d67TRUYBCcIf3yr.png)

其中那个 `62847146` 是元素总和. 不很清楚这个 OJ 用了什么先进的运行技巧. 


## 1095. Find in Mountain Array (无 PHP 提交 OJ)

<em>(This problem is an <strong>interactive problem</strong>.)</em>

You may recall that an array `A` is a mountain *array* if and only if:

* `A.length >= 3`
* There exists some `i` with `0 < i < A.length - 1` such that:
  * `A[0] < A[1] < ... A[i-1] < A[i]`
  * `A[i] > A[i+1] > ... > A[A.length - 1]`


Given a mountain array `mountainArr`, return the **minimum** `index` such that `mountainArr.get(index) == target`.  If such an `index` doesn't exist, return -1.

**You can't access the mountain array directly**.  You may only access the array using a `MountainArray` interface:

* `MountainArray.get(k)` returns the element of the array at index k (0-indexed).
* `MountainArray.length()` returns the length of the array.


Submissions making more than `100` calls to `MountainArray.get` will be judged *Wrong Answer*.  Also, any solutions that attempt to circumvent the judge will result in disqualification.

 

**Example 1:**


<pre>
<strong>Input:</strong> array = [1,2,3,4,5,3,1], target = 3
<strong>Output:</strong> 2
<strong>Explanation:</strong> 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.
</pre>


**Example 2:**

<pre>
<strong>Input:</strong> array = [0,1,2,4,2,1], target = 3
<strong>Output:</strong> -1
<strong>Explanation:</strong> 3 does not exist in the array, so we return -1.
</pre>

<strong>Constraints:</strong>


1. `3 <= mountain_arr.length() <= 10000`
2. `0 <= target <= 10^9`
3. `0 <= mountain_arr.get(index) <= 10^9`


## 1099. Two Sum Less Than Bound (上锁题目, 需要氪会员)

题目描述:

Given an array `array` of integers and integer `bound`, return the maximum `sum` such that there exists `i < j` with `array[i] + array[j] = sum` and `sum < bound`. If no `i, j` exist satisfying this equation, return -1.

 

**Example 1:**

<pre>
<strong>Input:</strong> array = [34,23,1,24,75,33,54,8], bound = 60
<strong>Output:</strong> 58
<strong>Explanation:</strong> 
We can use 34 and 24 to sum 58 which is less than 60.
</pre>


**Example 2:**

<pre>
<strong>Input:</strong> array = [10,20,30], bound = 15
<strong>Output:</strong> -1
<strong>Explanation:</strong> 
In this case it's not possible to get a pair sum less that 15.
</pre>
 

**Note:**

1. `1 <= array.length <= 100`
2. `1 <= array[i] <= 1000`
3. `1 <= bound <= 2000`


改了下题目标题, 你能接受大写单字母作为变量名吗? 反正我是不能.

## 1103. Distribute Candies to People


题目描述:

We distribute some number of `candies`, to a row of <code><strong>n = num_people</strong></code> people in the following way:

We then give 1 candy to the first person, 2 candies to the second person, and so on until we give `n` candies to the last person.

Then, we go back to the start of the row, giving `n + 1` candies to the first person, `n + 2` candies to the second person, and so on until we give `2 * n` candies to the last person.

This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift).

Return an array (of length `num_people` and sum `candies`) that represents the final distribution of candies.

 

**Example 1:**


<pre>
<strong>Input:</strong> candies = 7, num_people = 4
<strong>Output:</strong> [1,2,3,1]
<strong>Explanation:</strong>
On the first turn, ans[0] += 1, and the array is [1,0,0,0].
On the second turn, ans[1] += 2, and the array is [1,2,0,0].
On the third turn, ans[2] += 3, and the array is [1,2,3,0].
On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> candies = 10, num_people = 3
<strong>Output:</strong> [5,2,3]
<strong>Explanation:</strong> 
On the first turn, ans[0] += 1, and the array is [1,0,0].
On the second turn, ans[1] += 2, and the array is [1,2,0].
On the third turn, ans[2] += 3, and the array is [1,2,3].
On the fourth turn, ans[0] += 4, and the final array is [5,2,3].
</pre>


**Constraints:**

* `1 <= candies <= 10^9`
* `1 <= num_people <= 1000`


解答:


```php
class Solution 
{

    /**
     * @param Integer $candies
     * @param Integer $num_people
     * @return Integer[]
     */
    function distributeCandies($candies, $num_people) 
    {
        $count = 1;
        $result = array_fill(0, $num_people, 0);
        while ($count * ($count + 1) / 2 < $candies) {
            $result[($count - 1) % $num_people] += $count;
            $count++;
        }
        $result[($count - 1) % $num_people] += ($candies - ($count * ($count - 1) / 2));
        return $result;
    }
}
```


效果: 

> 执行用时 : 16 ms, 在所有 PHP 提交中击败了 44.44% 的用户
> 
> 内存消耗 : 14.8 MB, 在所有 PHP 提交中击败了 100.00% 的用户



## 1108. Defanging an IP Address

题目描述:

Given a valid (IPv4) IP `address`, return a defanged version of that IP address.

*A defanged IP address* replaces every period `"."` with `"[.]"`.
 

**Example 1:**


<pre>
<strong>Input:</strong> address = "1.1.1.1"
<strong>Output:</strong> "1[.]1[.]1[.]1"
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> address = "255.100.50.0"
<strong>Output:</strong> "255[.]100[.]50[.]0"
</pre>

**Constraints:**

* The given `address` is a valid IPv4 address.


解答:

```php
class Solution 
{

    /**
     * @param String $address
     * @return String
     */
    function defangIPaddr($address) 
    {
        return str_replace('.', '[.]', $address);
    }
}
```


效果:

> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.7 MB , 在所有 PHP 提交中击败了 100.00% 的用户


这个比较简单...

## 1118. Number of Days in a Month (上锁题目, 需要氪会员)

题目描述:

Given a year `year` and a month `month`, return how many days there are in that month.

**Example 1:**

<pre>
<strong>Input:</strong> year = 1992, month = 7
<strong>Output:</strong> 31
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> year = 2000, month = 2
<strong>Output:</strong> 29
</pre>

**Example 3:**

<pre>
<strong>Input:</strong> year = 1900, month = 2
<strong>Output:</strong> 28
</pre>

**Note:**

1. `1583 <= year <= 2100`
2. `1 <= month <= 12`

也是个弱智题目. 即便你什么都不会的话, 可以考虑:

```php
cal_days_in_month ( int $calendar , int $month , int $year ) : int
```

至于这个 `$calendar` 该用什么, 可以上 [PHP Manual - Function Reference - Date and Time Related Extensions - Calendar 这个页面](https://php.net/manual/en/calendar.constants.php)去找和 for [cal_days_in_month()](https://www.php.net/manual/en/function.cal-days-in-month.php) use the xxx calendar 相关的.


## 1119. Remove Vowels from a String (上锁题目, 需要氪会员)

题目描述:

Given a string `str`, remove the vowels 'a', 'e', 'i', 'o' and 'u' from it, and return the new string.

**Example 1:**

<pre>
<strong>Input:</strong> "leetcodeisacommunityforcoders"
<strong>Output:</strong> "ltcdscmmntyfrcdrs"
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> "aeiou"
<strong>Output:</strong> ""
</pre>


**Note:**

* 1. `str` consists of lower English letters only.
* 2. `1 <= str.length <= 1000`


虽然这个题由于上锁提交不了, 但是这个题是真心蠢.


## 1122. Relative Sort Array

题目描述:

Given two arrays `arr1` and `arr2`, the elements of `arr2` are distinct, and all elements in `arr2` are also in `arr1`.

Sort the elements of `arr1` such that the relative ordering of items in `arr1` are the same as in `arr2`.  Elements that don't appear in `arr2` should be placed at the end of `arr1` in **ascending** order.


**Example 1:**


<pre>
<strong>Input:</strong> arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
<strong>Output:</strong> [2,2,2,1,4,3,3,9,6,7,19]
</pre>

**Constraints:**

* `arr1.length, arr2.length <= 1000`
* `0 <= arr1[i], arr2[i] <= 1000`
* Each `arr2[i]` is distinct.
* Each `arr2[i]` is in `arr1`.



解答: 

```php
class Solution 
{

    /**
     * @param Integer[] $arr1
     * @param Integer[] $arr2
     * @return Integer[]
     */
    function relativeSortArray($arr1, $arr2) 
    {
        $difference = array_diff($arr1, $arr2);
        sort($difference, SORT_NUMERIC);
        $elementsFromArray2 = array_diff($arr1, $difference);
        $valueInfo = array_count_values($elementsFromArray2);
        $result = [];
        foreach ($arr2 as $num) {
            $result = array_merge($result, array_fill(0, $valueInfo[$num], $num));
        }
        $result = array_merge($result, $difference);
        return $result;
    }
}
```

效果:

> 执行用时 : 12 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.9 MB, 在所有 PHP 提交中击败了 100.00% 的用户



## 1128. Number of Equivalent Domino Pairs

题目描述:


Given a list of `dominoes`, `dominoes[i] = [a, b]` is equivalent to `dominoes[j] = [c, d]` if and only if either (`a==c` and `b==d`), or (`a==d` and `b==c`) - that is, one domino can be rotated to be equal to another domino.

Return the number of pairs `(i, j)` for which `0 <= i < j < dominoes.length`, and `dominoes[i]` is equivalent to `dominoes[j]`.

 

**Example 1:**


<pre>
<strong>Input:</strong> dominoes = [[1,2],[2,1],[3,4],[5,6]]
<strong>Output:</strong> 1
</pre>
 

**Constraints:**

* `1 <= dominoes.length <= 40000`
* `1 <= dominoes[i][j] <= 9`


解答:

```php
class Solution 
{

    /**
     * @param Integer[][] $dominoes
     * @return Integer
     */
    function numEquivDominoPairs($dominoes) 
    {
        $equivalentPairsCount = 0;
        $count = count($dominoes);
        // 先把每一个domino弄成前小后大的形式, 注意foreach的时候似乎array_reverse()了也没什么卵用.
        for ($i = 0; $i < $count; $i++) {
            if ($dominoes[$i][0] > $dominoes[$i][1]) {
                $dominoes[$i] = array_reverse($dominoes[$i]);
            }
        }
        $dominoInfo = [];
        // 数组和对象无法作为关联数组的键, 因此不能直接用array_count_values().
        foreach ($dominoes as $domino) {
            $count = $domino[0] . ', ' . $domino[1];
            if (array_key_exists($count, $dominoInfo)) {
                $dominoInfo[$count]++;
            } else {
                $dominoInfo[$count] = 1;
            }
        }
        foreach ($dominoInfo as $count) {
            if ($count > 1) {
                $equivalentPairsCount += ($count * ($count - 1) / 2);
            }
        }
        return $equivalentPairsCount;
    }
}
```

效果:

> 执行用时 : 128 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 51.5 MB, 在所有 PHP 提交中击败了 100.00% 的用户

主要是学会技巧: [array_count_values of a multi dimensional array?](https://stackoverflow.com/questions/17642469/array-count-values-of-a-multi-dimensional-array).



## 1133. Largest Unique Number

题目描述:

Given an array of integers `arr`, return the largest integer that only occurs once.

If no integer occurs once, return -1.

 

**Example 1:**


<pre>
<strong>Input:</strong> [5,7,3,9,4,9,8,3,1]
<strong>Output:</strong> 8
<strong>Explanation:</strong> 
The maximum integer in the array is 9 but it is repeated. The number 8 occurs only once, so it's the answer.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> [9,9,8,8]
<strong>Output:</strong> -1
<strong>Explanation:</strong> 
There is no number that occurs only once.
</pre>
 

**Note:**

1. `1 <= arr.length <= 2000`
2. `0 <= arr[i] <= 1000`


解答:


```php
class Solution 
{

    /**
     * @param Integer[] $arr
     * @return Integer
     */
    function largestUniqueNumber($arr) 
    {
        $valueInfo = array_count_values($arr);
        asort($valueInfo);
        $uniqueNumberArray = [];
        foreach ($valueInfo as $number => $occurrence) {
            if ($occurrence === 1) {
                $uniqueNumberArray[] = $number;
            }
        }
        var_dump($uniqueNumberArray);
        return (empty($uniqueNumberArray) ?  -1 :  max($uniqueNumberArray));
    }
}
```


第 5 场双周赛的第一题, 比赛中, 看不出来效果.






## 1134. Armstrong Number

题目描述:


The k-digit number `number` is an Armstrong number if and only if the k-th power of each digit sums to `number`.

Given a positive integer `number`, return true if and only if it is an Armstrong number.

 

**Example 1:**


<pre>
<strong>Input:</strong> 153
<strong>Output:</strong> true
<strong>Explanation:</strong> 
153 is a 3-digit number, and 153 = 1^3 + 5^3 + 3^3.
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> 123
<strong>Output:</strong> false
<strong>Explanation:</strong> 
123 is a 3-digit number, and 123 != 1^3 + 2^3 + 3^3 = 36.
</pre> 

**Note:**

1. `1 <= number <= 10^8`

解答:

```php
class Solution 
{

    /**
     * @param Integer $number
     * @return Boolean
     */
    function isArmstrong($number) 
    {
        return in_array($number, [1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407, 1634, 8208, 9474, 54748, 92727, 93084, 548834, 1741725, 4210818, 9800817, 9926315, 24678050, 24678051, 88593477]);
    }
}
```

第 5 场双周赛的第二题, 比赛中, 看不出来效果.

作为数学院出来的人, 要善于使用数学资料.


## 1137. N-th Tribonacci Number


题目描述:


The Tribonacci sequence T<sub>n</sub> is defined as follows: 

T<sub>0</sub> = 0, T<sub>1</sub> = 1, T<sub>2</sub> = 1, and T<sub>n+3</sub> = T<sub>n</sub> + T<sub>n+1</sub> + T<sub>n+2</sub> for n >= 0.

Given `n`, return the value of T<sub>n</sub>.

 

**Example 1:**


<pre>
<strong>Input:</strong> n = 4
<strong>Output:</strong> 4
<strong>Explanation:</strong>
T<sub>3</sub> = 0 + 1 + 1 = 2
T<sub>4</sub> = 1 + 1 + 2 = 4
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> n = 25
<strong>Output:</strong> 1389537
</pre>
 

**Constraints:**

* **0 <= n <= 37**
* The answer is guaranteed to fit within a 32-bit integer, ie. **answer <= 2^31 - 1**.

解答:


```php
class Solution 
{

    /**
     * @param Integer $n
     * @return Integer
     */
    function tribonacci($n) 
    {
        $tribonacciNumberArray = [0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474, 1132436852, 2082876103];
        return $tribonacciNumberArray[$n];
    }
}
```


效果:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.7 MB, 在所有 PHP 提交中击败了 100.00% 的用户


## 1150. Check If a Number Is Majority Element in a Sorted Array (上锁题目, 需要氪会员)


题目描述:

Given an array `nums` sorted in non-decreasing order, and a number `target`, return `true` if and only if `target` is a majority element.

A *majority element* is an element that appears more than `N/2` times in an array of length `N`.


**Example 1:**

<pre>
<strong>Input:</strong> nums = [2,4,5,5,5,5,5,6,6], target = 5
<strong>Output:</strong> true
<strong>Explanation:</strong> 
The value 5 appears 5 times and the length of the array is 9.
Thus, 5 is a majority element because 5 > 9/2 is true.
</pre>


**Example 2:**


<pre>
<strong>Input:</strong> nums = [10,100,101,101], target = 101
<strong>Output:</strong> false
<strong>Explanation:</strong> 
The value 101 appears 2 times and the length of the array is 4.
Thus, 101 is not a majority element because 2 > 4/2 is false.
</pre>


**Note:**

1. `1 <= nums.length <= 1000`
2. `1 <= nums[i] <= 10^9`
3. `1 <= target <= 10^9`



感觉不难啊...`count()` 完整个数组元素个数然后 `array_values()` 完根据 `target` 键去获得值, 拿这个 `target` 的出现次数和数组容量值的一半来比较就完事儿了.


## 1152. Analyze User Website Visit Pattern (上锁题目, 需要氪会员)


题目描述:


We are given some website visits: the user with name `username[i]` visited the website `website[i]` at time `timestamp[i]`.

A *3-sequence* is a list of websites of length 3 sorted in ascending order by the time of their visits. (The websites in a 3-sequence are not necessarily distinct.)

Find the 3-sequence visited by the largest number of users. If there is more than one solution, return the lexicographically smallest such 3-sequence.

 

**Example 1:**


<pre>
<strong>Input:</strong> username = ["joe","joe","joe","james","james","james","james","mary","mary","mary"], timestamp = [1,2,3,4,5,6,7,8,9,10], website = ["home","about","career","home","cart","maps","home","home","about","career"]
<strong>Output:</strong> ["home","about","career"]
<strong>Explanation:</strong> 
The tuples in this example are:
["joe", 1, "home"]
["joe", 2, "about"]
["joe", 3, "career"]
["james", 4, "home"]
["james", 5, "cart"]
["james", 6, "maps"]
["james", 7, "home"]
["mary", 8, "home"]
["mary", 9, "about"]
["mary", 10, "career"]
The 3-sequence ("home", "about", "career") was visited at least once by 2 users.
The 3-sequence ("home", "cart", "maps") was visited at least once by 1 user.
The 3-sequence ("home", "cart", "home") was visited at least once by 1 user.
The 3-sequence ("home", "maps", "home") was visited at least once by 1 user.
The 3-sequence ("cart", "maps", "home") was visited at least once by 1 user.
</pre> 

**Note:**

1. `3 <= N = username.length = timestamp.length = website.length <= 50`
2. `1 <= username[i].length <= 10`
3. `0 <= timestamp[i] <= 10^9`
4. `1 <= website[i].length <= 10`
5. Both `username[i]` and `website[i]` contain only lowercase characters.
6. It is guaranteed that there is at least one user who visited at least 3 websites.
7. No user visits two websites at the same time.



## 1154. Day of the Year

题目描述:

Given a string `date` representing a [Gregorian calendar](https://en.wikipedia.org/wiki/Gregorian_calendar) date formatted as `YYYY-MM-DD`, return the day number of the year.

 

**Example 1:**


<pre>
<strong>Input:</strong> date = "2019-01-09"
<strong>Output:</strong> 9
<strong>Explanation:</strong> Given date is the 9th day of the year in 2019.
</pre>


**Example 2:**

<pre>
<strong>Input:</strong> date = "2019-02-10"
<strong>Output:</strong> 41
</pre>


**Example 3:**


<pre>
<strong>Input:</strong> date = "2003-03-01"
<strong>Output:</strong> 60
</pre>


**Example 4:**

<pre>
<strong>Input:</strong> date = "2004-03-01"
<strong>Output:</strong> 61
</pre>


**Constraints:**


* `date.length == 10`
* `date[4] == date[7] == '-'`, and all other `date[i]`'s are digits
* `date` represents a calendar date between Jan 1st, 1900 and Dec 31, 2019.


解答1:


```php
class Solution 
{

    /**
     * @param String $date
     * @return Integer
     */
    function dayOfYear($date) 
    {
        // 注意: 格式字符 z 的意义是 The day of the year (starting from 0).
        // 所以从 date() 返回的结果还要再加个 1, 不然数是不对的.
        return date('z', strtotime($date)) + 1;
    }
}
```


效果1:

> 执行用时 : 8 ms, 在所有 PHP 提交中击败了 83.33% 的用户
> 
> 内存消耗 : 15.1 MB, 在所有 PHP 提交中击败了 100.00% 的用户


解答2:


```php
class Solution 
{

    /**
     * @param String $date
     * @return Integer
     */
    function dayOfYear($date) 
    {
        $parts = explode('-', $date);
        // 注意参数顺序.
        $timestamp = mktime(0, 0, 0, $parts[1], $parts[2], $parts[0]);
        return date('z', $timestamp) + 1;
    }
}
```


效果2:


> 执行用时 : 4 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗 : 14.8 MB, 在所有 PHP 提交中击败了 100.00% 的用户


主要是练习时间方面的函数的使用.

时间方面, 主要(但不局限于)是有以下这么几个看起来比较主要的函数:

* [date](https://www.php.net/manual/en/function.date.php)
* [mktime](https://www.php.net/manual/en/function.mktime.php)
* [strtotime](https://www.php.net/manual/en/function.strtotime.php)


如果再有问题的话, (项目里头)就上 Carbon 吧: [Carbon - A simple PHP API extension for DateTime.](https://carbon.nesbot.com).

提过程中发现的几点要注意的问题:

* 一个是 `mktime()` 函数的签名如下:

  ```php
mktime ([ int $hour = date("H") [, int $minute = date("i") [, int $second = date("s") [, int $month = date("n") [, int $day = date("j") [, int $year = date("Y") [, int $is_dst = -1 ]]]]]]] ) : int
  ```

  注意这个年月日在 `mktime()` 函数的参数列表中的顺序.
  
* 再一个是你在 Markdown 文档里如果有什么没被渲染出来, 那很可能是你的 `<pre>` 标签的闭合标签 `</pre>` 后面多了一个空格之类的.


不明白这也要造个轮子的意义何在. 你要说你这实现比官方函数功能强大比官方函数运行处理快那你写个轮子倒还凑合.

最后, 第 1185 题和这个题比较类似. 都是考察 `date()` 这个函数.


## 1160. Find Words That Can Be Formed by Characters (第 150 场周赛第一题)

题目描述:

You are given an array of strings `words` and a string `chars`.

A string is *good* if it can be formed by characters from `chars` (each character can only be used once).

Return the sum of lengths of all good strings in `words`.

 

**Example 1:**


<pre>
<strong>Input:</strong> words = ["cat","bt","hat","tree"], chars = "atach"
<strong>Output:</strong> 6
<strong>Explanation:</strong> 
The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> words = ["hello","world","leetcode"], chars = "welldonehoneyr"
<strong>Output:</strong> 10
<strong>Explanation:</strong> 
The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.
</pre>

**Note:**

1. `1 <= words.length <= 1000`
2. `1 <= words[i].length, chars.length <= 100`
3. All strings contain lowercase English letters only.


解答:

```php
class Solution 
{

    /**
     * @param String[] $words
     * @param String $chars
     * @return Integer
     */
    function countCharacters($words, $chars) 
    {
        $length_sum = 0;
        $alphabet_char_info = count_chars($chars, 1);
        foreach ($words as $word) {
            $can_be_formed = true;
            $wordlist_char_info = count_chars($word, 1);
            foreach ($wordlist_char_info as $byteValue => $count) {
                if ($count > $alphabet_char_info[$byteValue]) {
                    $can_be_formed = false;
                    break;
                }
            }
            if ($can_be_formed) {
                $length_sum += strlen($word);
            }
        }
        return $length_sum;
    }
}
```


效果:

> 执行用时: 52 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 15.4 MB, 在所有 PHP 提交中击败了 100.00% 的用户


这个题做法和 383. Ransom Note 差不多. 注意 `count_chars()` 函数一般是带双参数、第二个参数是 1 那么用.



## 1062. Longest Repeating Substring

题目描述:

Given a string `str`, find out the length of the longest repeating substring(s). Return `0` if no repeating substring exists.

 

**Example 1:**

<pre>
<strong>Input:</strong> "abcd"
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no repeating substring.
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> "abbaba"
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest repeating substrings are "ab" and "ba", each of which occurs twice.
</pre>


**Example 3:**

<pre>
<strong>Input:</strong> "aabcaabdaab"
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest repeating substring is "aab", which occurs 3 times.
</pre>


**Example 4:**

<pre>
<strong>Input:</strong> "aaaaa"
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest repeating substring is "aaaa", which occurs twice.
</pre>

**Note:**

1. The string `str` consists of only lowercase English letters from `'a'` - `'z'`.
2. `1 <= str.length <= 1500`


解答:

```php 
class Solution 
{
    
    static function longestCommonString($a, $b)
    {
        $range = min(strlen($a), strlen($b));
        $result = "";

        for ($i = 0; $i < $range; $i++) {
            if ($a[$i] == $b[$i]) {
                $result = $result . $a[$i];
            } else {
                break;
            }
        }

        return $result;
    }

    /**
     * @param String $str
     * @return Integer
     */
    function LongestRepeatingSubstring($str)
    {
        if ($str == null) {
            return 0;
        }

        $str_len = strlen($str);
        $substrings = [];

        for ($i = 0; $i < $str_len; $i++) {
            $substrings[$i] = substr($str, $i);
        }

        sort($substrings);

        $result = "";

        for ($i = 0; $i < $str_len - 1; $i++) {
            $longestCommonString = self::longestCommonString($substrings[$i], $substrings[$i + 1]);

            if (strlen($longestCommonString) > strlen($result)) {
                $result = $longestCommonString;
            }
        }

        return strlen($result);
    }

}
```

效果:

> 执行用时 : 48 ms, 在Longest Repeating Substring的PHP提交中击败了 100.00% 的用户
> 
> 内存消耗 : 16.2 MB, 在Longest Repeating Substring的PHP提交中击败了 100.00% 的用户


我当时做的时候这个是 5006 题, 而且我当时还做出了结果, 不知道为啥给我算尝试过...


## 1163. Last Substring in Lexicographical Order(第 150 场周赛第四题)


题目描述:


Given a string `str`, return the last substring of `str` in lexicographical order.

 

**Example 1:**

<pre>
<strong>Input:</strong> "abab"
<strong>Output:</strong> "bab"
<strong>Explanation:</strong> The substrings are ["a", "ab", "aba", "abab", "b", "ba", "bab"]. The lexicographically maximum substring is "bab".
</pre>

**Example 2:**


<pre>
<strong>Input:</strong> "leetcode"
<strong>Output:</strong> "tcode"
</pre>


**Note:**

1. `1 <= str.length <= 10^5`
2. `str` contains only lowercase English letters.


解答:


```php
class Solution 
{

    /**
     * @param String $str
     * @return String
     */
    function lastSubstring($str) 
    {
        $char_array = str_split($str);
        $max_char = max($char_array);
        $max_char_position_array = array_keys($char_array, $max_char);
        $result = substr($str, $max_char_position_array[0]);
        // 如果位置数组中只有一个元素, 当然就是返回这个最大字母开头一直到原字符串末尾的子串
        if (count($max_char_position_array) === 1) {
            return $result;
        }
        // 超过两个元素, 就挨个取相对较大的来比. 注意不要把满足条件的子串放到数组里排序, 这样会超内存.
        foreach ($max_char_position_array as $max_char_position) {
            $result = (strcmp($result, substr($str, $max_char_position)) > 0 ? $result : substr($str, $max_char_position));
        }
        return $result;
    }
}
```


效果:

> 执行用时: 608 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 24.3 MB, 在所有 PHP 提交中击败了 100.00% 的用户


居然撸粗来一个 hard 题, 泪目...

![hard](https://upload.cc/i1/2019/08/18/Zul5AL.png)

注意 `array_keys()` 函数的用法, 它是可以返回具有指定值的元素的位置集合的.

`array_keys()` 函数的签名和描述如下:

> 1. `array_keys ( array $array ) : array`
> 2. `array_keys ( array $array , mixed $search_value [, bool $strict = FALSE ] ) : array`
> 
> `array_keys()` returns the keys, numeric and string, from the **array**.
> 
> If a **search_value** is specified, then only the keys for that value are returned. Otherwise, all the keys from the **array** are returned.


如果是进行字符串比较的话, 直接大于小于能不能比懒得专门查了, 想查了再去查. 这里我用的是 `strcmp` 函数.

## 1170. Compare Strings by Frequency of the Smallest Character

题目描述:

Let's define a function `f(string)` over a non-empty string `string`, which calculates the frequency of the smallest character in `string`. For example, if `string = "dcce"` then `f(string) = 2` because the smallest character is `"c"` and its frequency is 2.

Now, given string arrays `queries` and `words`, return an integer array answer, where each `answer[i]` is the number of words such that `f(queries[i]) < f(word)`, where `word` is a word in `words`.

 

**Example 1:**

<pre>
<strong>Input:</strong> queries = ["cbd"], words = ["zaaaz"]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> On the first query we have f("cbd") = 1, f("zaaaz") = 3 so f("cbd") < f("zaaaz").
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> queries = ["bbb","cc"], words = ["a","aa","aaa","aaaa"]
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> On the first query only f("bbb") < f("aaaa"). On the second query both f("aaa") and f("aaaa") are both > f("cc").
</pre>

**Constraints:**

* `1 <= queries.length <= 2000`
* `1 <= words.length <= 2000`
* `1 <= queries[i].length, words[i].length <= 10`
* `queries[i][j]`, `words[i][j]` are English lowercase letters.

解答:

```php
class Solution
{

    /**
     * @param String[] $queries
     * @param String[] $words
     * @return Integer[]
     */
    function numSmallerByFrequency($queries, $words)
    {
        // 先把 f 算子作用到 words 集合上的结果跑出来.
        $words_smallest_character_frequency = array_map($map = function ($word) {
            $word_char_array = str_split($word);
            return count(array_keys($word_char_array, min($word_char_array)));
        }, $words);
        $result = array_map($callback = function ($query) use ($words_smallest_character_frequency) {
            // 再将 f 算子作用到每个 query 元素上.
            $query_char_array = str_split($query);
            $query_smallest_character_frequency = count(array_keys($query_char_array, min($query_char_array)));
            // 将对每个 query 元素的计算结果和对之前单词集合的计算结果进行比较, 然后统计.
            return count(array_filter($words_smallest_character_frequency, $filter = function ($word_smallest_character_frequency) use ($query_smallest_character_frequency) {
                return $query_smallest_character_frequency < $word_smallest_character_frequency;
            }));
        }, $queries);
        return $result;
    }
}
```

效果:

> 执行用时: 824 ms, 在所有 PHP 提交中击败了 20.00% 的用户
> 
> 内存消耗: 15.3 MB, 在所有 PHP 提交中击败了 100.00% 的用户

练习一下 closure 的写法, 当然在其他的语言这个东西可能会被称为 lambda/block. 虽然看着比较复杂, 但是知道自己想干什么以后还是比较简单的. 注意 `use` 外部变量就行, 都是写过不知道多少遍的东西了.

再就后面明显有一行超过 120 字了, 但是没办法, 缩进了又感觉不太好看, 将就着看吧. 我这个字数的大头都在变量名上.


## 1176. Diet Plan Performance


A dieter consumes `calories[i]` calories on the `i`-th day.  For every consecutive sequence of `period` days, they look at *T*, the total calories consumed during that sequence of `period` days:

* If `T < lower`, they performed poorly on their diet and lose 1 point; 
* If `T > upper`, they performed well on their diet and gain 1 point;
* Otherwise, they performed normally and there is no change in points.

Return the total number of points the dieter has after all `calories.length` days.

Note that: The total points could be negative.


**Example 1:**

<pre>
<strong>Input:</strong> calories = [1,2,3,4,5], period = 1, lower = 3, upper = 3
<strong>Output:</strong> 0
<strong>Explaination:</strong> calories[0], calories[1] < lower and calories[3], calories[4] > upper, total points = 0.
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> calories = [3,2], period = 2, lower = 0, upper = 1
<strong>Output:</strong> 1
<strong>Explaination:</strong> calories[0] + calories[1] > upper, total points = 1.
</pre>

**Example 3:**

<pre>
<strong>Input:</strong> calories = [6,5,0,0], period = 2, lower = 1, upper = 5
<strong>Output:</strong> 0
<strong>Explaination:</strong> calories[0] + calories[1] > upper, lower <= calories[1] + calories[2] <= upper, calories[2] + calories[3] < lower, total points = 0.
</pre>

**Constraints:**

* `1 <= period <= calories.length <= 10^5`
* `0 <= calories[i] <= 20000`
* `0 <= lower <= upper`


解答:

```php
class Solution 
{

    /**
     * @param Integer[] $calories
     * @param Integer $period
     * @param Integer $lower
     * @param Integer $upper
     * @return Integer
     */
    function dietPlanPerformance($calories, $period, $lower, $upper) 
    {
        $total_points = 0;
        $slice_sum = array_sum(array_slice($calories, 0, $period - 1));
        $sample_count = count($calories) + 1 - $period;
        for ($i = 0; $i < $sample_count; $i++) {
            $slice_sum += $calories[$i + $period - 1];
            if ($slice_sum > $upper) {
                $total_points += 1;
            }
            if ($slice_sum < $lower) {
                $total_points -= 1;
            }
            $slice_sum -= $calories[$i];
        }
        return $total_points;
    }
}
```

效果: 

> 执行用时: 84 ms, 在所有 PHP 提交中击败了 66.67% 的用户
> 
> 内存消耗: 24.4 MB, 在所有 PHP 提交中击败了 100.00% 的用户


取一个连续周期容量的数组切片, 然后维护改变量就行.

注意这个题是从前 `$period` 天一直到后 `$period` 天的都要算. 不是每 `$period` 天一算不足 `$period` 天的就不算了这种.

当时不知道干啥去了没整理这个题的答案, 结果为了整理答案的时候发现像这么写:

```php
class Solution 
{

    /**
     * @param Integer[] $calories
     * @param Integer $period
     * @param Integer $lower
     * @param Integer $upper
     * @return Integer
     */
    function dietPlanPerformance($calories, $period, $lower, $upper) 
    {
        $total_points = 0;
        $sample_count = count($calories) + 1 - $period;
        $slice = array_slice($calories, 0, $period);
        for ($i = 0; $i < $sample_count; $i++) {
            if (array_sum($slice) > $upper) {
                $total_points += 1;
            }
            if (array_sum($slice) < $lower) {
                $total_points -= 1;
            }
            array_shift($slice);
            array_push($slice, $calories[$period + $i]);
        }
        return $total_points;
    }
}
```

之前能给你过, 现在算超时. 还是要注意优化一下的...

![dieplanperformance.png](https://i.loli.net/2019/09/10/BPQAoHjEu72KIe3.png)

## 1184. Distance Between Bus Stops

A bus has `n` stops numbered from `0` to `n - 1` that form a circle. We know the distance between all pairs of neighboring stops where `distance[i]` is the distance between the stops number `i` and `(i + 1) % n`.

The bus goes along both directions i.e. clockwise and counterclockwise.

Return the shortest distance between the given `start` and `destination` stops.

**Example 1:**

![1184-1.jpg](https://i.loli.net/2019/09/12/XmzvU8wHEDfQSP9.jpg)

<pre>
<strong>Input:</strong> distance = [1,2,3,4], start = 0, destination = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> Distance between 0 and 1 is 1 or 9, minimum is 1.
</pre>

**Example 2:**

![1184-2.jpg](https://i.loli.net/2019/09/12/QPlyizDMCsZc9Ae.jpg)

<pre>
<strong>Input:</strong> distance = [1,2,3,4], start = 0, destination = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong> Distance between 0 and 2 is 3 or 7, minimum is 3.
</pre>

**Example 3:**

![1184-3.jpg](https://i.loli.net/2019/09/12/WULlrb5mN2Yi96s.jpg)

<pre>
<strong>Input:</strong> distance = [1,2,3,4], start = 0, destination = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> Distance between 0 and 3 is 6 or 4, minimum is 4.
</pre>

Constraints:

* `1 <= n <= 10^4`
* `distance.length == n`
* `0 <= start, destination < n`
* `0 <= distance[i] <= 10^4`

解答:

```php
class Solution
{

    /**
     * @param Integer[] $distance
     * @param Integer $start
     * @param Integer $destination
     * @return Integer
     */
    function distanceBetweenBusStops($distance, $start, $destination)
    {
        $total = array_sum($distance);
        if ($destination < $start) {
            $antiClockwise = array_sum(array_slice($distance, $destination, $start - $destination));
            return min($total - $antiClockwise, $antiClockwise);
        }
        $clockwise = array_sum(array_slice($distance, $start, $destination - $start));
        return min($total - $clockwise, $clockwise);   
    }
}
```

效果:

> 执行用时: 12 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 15.8 MB, 在所有 PHP 提交中击败了 100.00% 的用户

比较简单, 就是图多一点儿...

注意这个题 `array_slice()` 的时候别把 slice 的长度算错就行, 直接用 `后 - 前` 即可, 不是 `后 - 前 + 1`.

## 1185. Day of the Week

Given a date, return the corresponding day of the week for that date.

The input is given as three integers representing the `day`, `month` and `year` respectively.

Return the answer as one of the following values `{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}`.

 

**Example 1:**

<pre>
<strong>Input:</strong> day = 31, month = 8, year = 2019
<strong>Output:</strong> "Saturday"
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> day = 18, month = 7, year = 1999
<strong>Output:</strong> "Sunday"
</pre>

**Example 3:**

<pre>
<strong>Input:</strong> day = 15, month = 8, year = 1993
<strong>Output:</strong> "Sunday"
</pre>


**Constraints:**

* The given dates are valid dates between the years `1971` and `2100`.


解答:


```php
class Solution
{

    /**
     * @param Integer $day
     * @param Integer $month
     * @param Integer $year
     * @return String
     */
    function dayOfTheWeek($day, $month, $year)
    {
        $daysOfTheWeeks = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        // PHP 是最好的语言!
        return $daysOfTheWeeks[date('N',strtotime("{$year}-{$month}-{$day}")) % 7];
    }
}
```

> 执行用时: 12 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 15.1 MB, 在所有 PHP 提交中击败了 100.00% 的用户

第 1154 题的精神继承版. 会用函数就行. 

找格式控制符, 没有难度吧?


![date().png](https://i.loli.net/2019/09/10/h9ZUPQ1l6zqS4YN.png)


## 1189. Maximum Number of Balloons

题目描述:

Given a string `text`, you want to use the characters of `text` to form as many instances of the word "**balloon**" as possible.

You can use each character in `text` **at most once**. Return the maximum number of instances that can be formed.


**Example 1:**

![1189-1.jpg](https://i.loli.net/2019/09/16/XILMt2gDGck8C1O.jpg)

<pre>
<strong>Input:</strong> text = "nlaebolko"
<strong>Output:</strong> 1
</pre>

**Example 2:**

![1189-2.jpg](https://i.loli.net/2019/09/16/3DyJvezGP21ULWR.jpg)

<pre>
<strong>Input:</strong> text = "loonbalxballpoon"
<strong>Output:</strong> 2
</pre>

**Example 3:**

<pre>
<strong>Input:</strong> text = "leetcode"
<strong>Output:</strong> 0
</pre>

**Constraints:**

* `1 <= text.length <= 10^4`
* `text` consists of lower case English letters only.

解答: 

```php
class Solution
{

    /**
     * @param String $text
     * @return Integer
     */
    function maxNumberOfBalloons($text)
    {
        $chars_info = count_chars($text, 1);
        $unique_chars_info = [$chars_info[ord("b")], $chars_info[ord("a")], $chars_info[ord("n")]];
        $multiple_chars_info = [$chars_info[ord("l")], $chars_info[ord("o")]];
        $least_multiple_char_count = min($multiple_chars_info);
        $least_unique_char_count = min($unique_chars_info);
        return min(floor($least_multiple_char_count / 2), floor($least_unique_char_count / 1));
    }
}
```

效果: 

> 执行用时: 0 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 14.7 MB, 在所有 PHP 提交中击败了 100.00% 的用户

![1189](https://upload.cc/i1/2019/09/16/cULT4m.png)

😂


## 1207. Unique Number of Occurrences

题目描述:

Given an array of integers `array`, write a function that returns `true` if and only if the number of occurrences of each value in the array is unique.

**Example 1:**

<pre>
<strong>Input:</strong> array = [1,2,2,1,1,3]
<strong>Output:</strong> true
<strong>Explanation:</strong> The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.
</pre>

**Example 2:**

<pre>
<strong>Input:</strong> array = [1,2]
<strong>Output:</strong> false
</pre>

**Example 3:**

<pre>
<strong>Input:</strong> array = [-3,0,1,-3,1,1,1,-3,10,0]
<strong>Output:</strong> true
</pre>

**Constraints:**

* 1 <= array.length <= 1000
* -1000 <= array[i] <= 1000


解答:

```php
class Solution
{

    /**
     * @param Integer[] $array
     * @return Boolean
     */
    function uniqueOccurrences($array)
    {
        $nums_info = array_count_values($array);
        if (count(array_keys($nums_info)) === count(array_unique(array_values($nums_info)))) {
            return true;
        } else {
            return false;
        }
    }
}
```

效果:

> 执行用时: 8 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 14.8 MB, 在所有 PHP 提交中击败了 100.00% 的用户

十一做题, 为祖国母亲70岁生日庆生~

## 1213. Intersection of Three Sorted Arrays

题目描述:

Given three integer arrays `arr1`, `arr2` and `arr3` **sorted** in **strictly increasing** order, return a sorted array of **only** the integers that appeared in **all** three arrays.


**Example 1:**


<pre>
<strong>Input:</strong> arr1 = [1,2,3,4,5], arr2 = [1,2,5,7,9], arr3 = [1,3,4,5,8]
<strong>Output:</strong> [1,5]
<strong>Explanation:</strong> Only 1 and 5 appeared in the three arrays.
</pre>


**Note:**

1. `1 <= arr1.length, arr2.length, arr3.length <= 1000`
2. `1 <= arr1[i], arr2[i], arr3[i] <= 2000`

本题翻译是由我提供的233:

![采纳.png](https://i.loli.net/2019/07/06/5d1ff0cd8c12b13150.png)

解答:


```php
class Solution 
{

    /**
     * @param Integer[] $arr1
     * @param Integer[] $arr2
     * @param Integer[] $arr3
     * @return Integer[]
     */
    function arraysIntersection($arr1, $arr2, $arr3) 
    {
        return array_intersect($arr1, $arr2, $arr3);
    }
}
```

效果:

> 执行用时: 44 ms, 在所有 PHP 提交中击败了 100.00% 的用户
> 
> 内存消耗: 14.9 MB, 在所有 PHP 提交中击败了 100.00% 的用户


有难度吗?


## LCP 1. 猜数字(无 PHP 提交 OJ)

题目描述:

X 教授和万磁王在玩猜数字。万磁王每次从 1, 2, 3 中随机选择一个，X 教授每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 X 教授猜对了几次？

 

输入的 `guess` 数组为 X 教授每次的猜测，`answer` 数组为 万磁王 每次的选择。`guess` 和 `answer` 的长度都等于 3。

 

**示例 1：**

<pre>
<strong>输入：</strong>guess = [1,2,3], answer = [1,2,3]
<strong>输出：</strong>3
<strong>解释：</strong>X 教授每次都猜对了。
</pre>

**示例 2：**

<pre>
<strong>输入：</strong>guess = [2,2,3], answer = [3,2,1]
<strong>输出：</strong>1
<strong>解释：</strong>X 教授 只猜对了第二次。
</pre>

**限制：**

1. `guess` 的长度 = 3
2. `answer` 的长度 = 3
3. `guess` 的元素取值为 `{1, 2, 3}` 之一。
4. `answer` 的元素取值为 `{1, 2, 3}` 之一。


解答:

```javascript
/**
 * @param {number[]} guess
 * @param {number[]} answer
 * @return {number}
 */
var game = function(guess, answer) {
    let count = 0
    for (let i = 0; i < 3; i++) {
        if (guess[i] === answer[i]) {
            count++
        }
    }
    return count
}
```

效果:

> 执行用时: 56 ms, 在所有 JavaScript 提交中击败了 88.64% 的用户
> 
> 内存消耗: 33.8 MB, 在所有 JavaScript 提交中击败了 100.00% 的用户


这帮人写 JavaScript 的风格还是不错的, 要是他们写 PHP 的风格也能有这一半就好了😂