---
layout: post
title: "传输层协议"
description: "面向技术面试官写作."
date: 2019-10-10
tags: [提高姿势水平]
comments: true
share: true
---

> 面向技术面试官写作.

写了个开头感觉有些 Hold 不住, 先记一下写作素材:

* [面试官，不要再问我三次握手和四次挥手](https://segmentfault.com/a/1190000020610336)
* [TCP/IP Illustrated, Volume 1：The Protocols]() 第 10 章(UDP)、第 13 章(TCP)的位置

* TOC
{:toc}

这个是我还是一个网管的时候学过, 但是水平不是很好就是了, 现在找个机会重新看一下.

传输层定义了主机应用程序之间端到端的连通性. 传输层中最为常见的两个协议分别是传输控制协议 TCP(Transmission Control Protocol) 和用户数据报协议 UDP (User Datagram Protocol)。

我们的目标不是没有蛀牙, 而是:

* 掌握 TCP 和 UDP 的工作原理;
* 描述 TCP 和 UDP 的报文格式;
* 了解常见服务的应用端口号.

## 0. TCP/IP 模型

TCP/IP 模型分为四层:

* 应用层
* 传输层
* 网络层
* 网络接口层

在 TCP/IP 模型中, 层与层相对独立但是相互之间也具备非常密切的协作关系。
TCP/IP 模型将网络分为四层. TCP/IP 模型不关注底层物理介质, 主要关注终端之间的逻辑数据流转发. TCP/IP 模型的核心是网络层和传输层: 网络层解决网络之间的逻辑转发问题, 传输层保证源端到目的端之间的可靠传输. 最上层的应用层通过各种协议向终端用户提供业务应用.

### 0.1 数据封装

![数据封装.png](https://i.loli.net/2019/10/10/FmOM4PZSp9qikYN.png)

应用数据需要经过 TCP/IP 每一层处理之后才能通过网络传输到目的端, 每一层上都使用该层的协议数据单元 PDU(Protocol Data Unit) 彼此交换信息. 不同层的 PDU 中包含有不同的信息, 因此 PDU 在不同层被赋予了不同的名称. 如上层数据在传输层添加 TCP 报头后得到的 PDU 被称为 Segment (数据段); 数据段被传递给网络层, 网络层添加 IP 报头得到的 PDU 被称为 Packet (数据包); 数据包被传递到数据链路层, 封装数据链路层报头得到的 PDU 被称为 Frame (数据帧); 最后, 帧被转换为比特 (Bit), 通过网络介质传输. 这种协议栈逐层向下传递数据并添加报头和报尾的过程称为封装.


## 1. TCP

![tcp例子.png](https://i.loli.net/2019/10/10/WE6PZhL9tkw2SDT.png)

TCP 位于 TCP/IP 模型的传输层, 它是一种面向连接的端到端协议. TCP 作为传输控制协议, 可以为主机提供可靠的数据传输. TCP 需要依赖网络协议为主机提供可用的传输路径. 在上图中, 两台主机在通信之前, 需要TCP在它们之间建立可靠的传输通道.

### 1.1 TCP 端口号

TCP 允许一个主机同时运行多个应用进程. 每台主机可以拥有多个应用端口, 每对端口号、源和目标 IP 地址的组合唯一地标识了一个会话. 端口分为知名端口和动态端口. 有些网络服务会使用固定的端口, 这类端口称为知名端口, 端口号范围为 0-1023. 如 FTP、HTTP、Telnet、SNMP 服务均使用知名端口. 动态端口号范围从 1024 到 65535, 这些端口号一般不固定分配给某个服务, 也就是说许多服务都可以使用这些端口. 只要运行的程序向系统提出访问网络的申请, 那么系统就可以从这些端口号中分配一个供该程序使用.

| 协议 | 端口号 |
|---|---|
| FTP | 20、21 |
| HTTP | 80 |
| Telnet | 23 |
| SMTP | 25 |

说到 HTTP, 就想起 Apache, 就想起 Tomcat... 不过既然我们写 PHP 的话, Tomcat 和 Catalina 和我们基本就没有半毛钱关系.

### 1.2 TCP 建立连接(connection sets up/is established)

![tcp建立连接.png](https://i.loli.net/2019/10/10/ADTYcJFoQv9e4q8.png)

TCP 是一种可靠的、面向连接的全双工传输层协议.

TCP 连接的建立是一个三次握手的过程. 如上图所示:

1. 主机 A (通常也称为客户端)发送一个标识了 SYN 的数据段, 表示期望与服务器 A 建立连接, 此数据段的序列号 (`seq`) 为 `a`.
2. 服务器 A 回复标识了 SYN+ACK 的数据段, 此数据段的序列号 (`seq`) 为 `b`, 确认序列号为主机 A 的序列号加 1 (`a + 1`), 以此作为对主机 A 的 SYN 报文的确认.
3. 主机 A 发送一个标识了 ACK 的数据段, 此数据段的序列号 (seq) 为 `a + 1`, 确认序列号为服务器 A 的序列号加 1 (`b + 1`), 以此作为对服务器 A 的 SYN 报文段的确认.


### 1.3 TCP 关闭连接(connection termination)

![tcp关闭连接.png](https://i.loli.net/2019/10/10/LEfmkDBaTZ4uovI.png)

TCP 支持全双工模式传输数据, 这意味着同一时刻两个方向都可以进行数据的传输. 在传输数据之前, TCP 通过三次握手建立的实际上是两个方向的连接, 因此在传输完毕后, 两个方向的连接必须都关闭.

TCP 连接的建立是一个三次握手的过程, 而 TCP 连接的终止则要经过四次挥手(英文中都是 handshake).

如上图所示:

1. 主机 A 想终止连接，于是发送一个标识了 FIN, ACK 的数据段, 序列号为 `a`, 确认序列号为 `b`.
2. 服务器 A 回应一个标识了 ACK 的数据段, 序列号为 `b`, 确认序号为 `a + 1`, 作为对主机 A 的 FIN 报文的确认.
3. 服务器 A 想终止连接, 于是向主机 A 发送一个标识了 FIN, ACK 的数据段, 序列号为 `b`, 确认序列号为 `a + 1`.
4. 主机 A 回应一个标识了 ACK 的数据段, 序列号为 `a + 1`, 确认序号为 `b + 1`, 作为对服务器 A 的 FIN 报文的确认. 

以上四次交互便完成了两个方向连接的关闭.